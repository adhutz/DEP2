[{"path":"/articles/01_Quick_start.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick start","text":"DEP2 provides differentially expressed/enriched analysis toolkit mass spectrometry based quantitative proteomics data utilizing limma package statistical analysis (Ritchie et al. 2015). DEP2 upgraded version previous package DEP (Zhang et al. 2018) provides comprehensive workflow proteomics analysis, encompassing data processing, missing value imputation, hypothesis test, visualization downstream functional exploration. DEP2 provide three types differential proteomics analysis: pipeline proteins-level expression/enrichment analysis, starting protein-level quantity data. pipeline proteins-level expression/enrichment analysis, starting peptide-level quantity data. pipeline post-translation modification(PTM)-specified proteomics, performed upon modified peptides quantities. addition, DEP2 also includes packaged RNA-seq data analysis pipeline DESeq2.","code":""},{"path":"/articles/01_Quick_start.html","id":"load-required-packages","dir":"Articles","previous_headings":"","what":"Load Required Packages","title":"Quick start","text":"","code":"library(DEP2) library(dplyr) library(ggplot2) library(ComplexHeatmap)"},{"path":"/articles/01_Quick_start.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example Data","title":"Quick start","text":"section, showcase utilization DEP2 pipelines employing data multiple-omics study silicosis mouse model (Wang et al., 2022), built-data package. datasets included built-data within DEP2 package. Additionally, data can accessed table format repository github.com/mildpiggy/OmicsExample.","code":"## The proteomics data represented in protein-level format (proteingroup.txt output from MaxQuant). data(Silicosis_pg)   ## The proteomics data represented in peptide-level format (peptides.txt output from MaxQuant). data(Silicosis_peptide)   ## Experiment design table providing annotations for the samples. data(Silicosis_ExpDesign)  ## Phosphoproteomics data (Phospho(STY)Sites.txt output from MaxQuant). data(Silicosis_phos)   ## RNA-seq counts data. data(Silicosis_counts)"},{"path":"/articles/01_Quick_start.html","id":"get-start","dir":"Articles","previous_headings":"","what":"Get Start","title":"Quick start","text":"four pipelines can executed step--step outlined :","code":""},{"path":"/articles/01_Quick_start.html","id":"proteingroup-workflow","dir":"Articles","previous_headings":"Get Start","what":"Proteingroup Workflow","title":"Quick start","text":"conventional workflow starts protein-level data.","code":"## 1. Construct SummarizedExperiement unique_pg <- make_unique(Silicosis_pg, names = \"Gene.names\", ids = \"Protein.IDs\") ecols <- grep(\"LFQ.intensity.\", colnames(unique_pg)) se <- make_se(unique_pg,                                      columns = ecols,                expdesign = Silicosis_ExpDesign              )  ## 2. Filter filt <- filter_se(se,                   thr = 1,                   filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\"                   )  ## 3. Normalize norm <- normalize_vsn(filt)  ## 4. Impute filt <- DEP2::impute(norm,fun = \"MinDet\")  ## 5. Differential test diff <- test_diff(filt,type = \"control\", control = \"PBS\")  dep <- add_rejections(diff, alpha = 0.05, lfc = 1)"},{"path":"/articles/01_Quick_start.html","id":"ptm-peptides-workflow","dir":"Articles","previous_headings":"Get Start","what":"PTM-Peptides Workflow","title":"Quick start","text":"workflow designed modified peptide data.","code":"## 1. Construct SummarizedExperiement unique_ptm <- make_unique_ptm(Silicosis_phos,                                gene_name = \"Gene.names\", protein_ID = \"Protein\",                               aa = \"Amino.acid\", pos = \"Position\") ecols <- grep(\"Intensity.\", colnames(unique_ptm)) se_ptm <- make_se(unique_ptm,                                          columns = ecols,                    expdesign = Silicosis_ExpDesign                   )  ## 2. Filter filt_ptm <- filter_se(se_ptm,                      thr = 1,                      filter_formula = ~ Reverse!=\"+\" &                         Potential.contaminant!=\"+\" &                         Localization.prob > 0.7                      )  ## 3. Normalize norm_ptm <- normalize_vsn(filt_ptm)  ## 4. Impute filt_ptm <- DEP2::impute(norm_ptm, fun = \"QRILC\")  ## 5. Differential test diff_ptm <- test_diff(filt_ptm,type = \"control\", control = \"PBS\")  dep_ptm <- add_rejections(diff_ptm, alpha = 0.01)"},{"path":"/articles/01_Quick_start.html","id":"peptides-aggregation-workflow","dir":"Articles","previous_headings":"Get Start","what":"Peptides Aggregation Workflow","title":"Quick start","text":"workflow aggregates peptides proteins.","code":"## 1. Construct SummarizedExperiement ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE) pe = make_pe_parse(Silicosis_peptide,                      columns = ecols,   # columns is the 'Intensity' colunmns                     mode = \"delim\", sep = \"_\",                     remove_prefix = TRUE                    )  ## 2. Filter pe = filter_pe(pe,                 thr = 1,                fraction = 0.3,                 filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\"                 )  ## 3. Impute pe <- impute_pe(pe, fun = \"QRILC\", name = \"peptideImp\")  ## 4. Normalize pe <- normalize_pe(pe,method = \"quantiles.robust\", i = \"peptideImp\")  ## 5. Aggregate peptides quantity to proteins' begin_time = Sys.time() pe <- aggregate_pe(pe, fcol = \"Proteins\", reserve = \"Gene.names\") print(Sys.time() - begin_time) ## Required few minutes  ## 6. Transform a SummarizedExperiement of protein quantities. se <- pe2se(pe, names = \"Gene.names\", ids = \"smallestProteingroups\")   ## 7. Differential test diff_pep <- test_diff(se,type = \"control\", control = \"PBS\") dep_pep <- add_rejections(diff_pep, alpha = 0.01)"},{"path":"/articles/01_Quick_start.html","id":"rna-seq-workflow","dir":"Articles","previous_headings":"Get Start","what":"RNA-seq workflow","title":"Quick start","text":"DEP2 packages simple pipeline DESeq2 RNA-seq data (gene counts).","code":"## 0. Check the depend packages check_RNAseq_depends() #> [1] TRUE  ## 1. Construct DESeqDataSet  dds <- make_dds_parse(Silicosis_counts,mode = \"delim\")  ## 2. Filter dds <- filter_se(dds, fraction = 0.3, thr = 1, rowsum_threshold = 35)  ## 3. Transform ID (optional) dds <- ID_transform(dds, fromtype = \"ENSEMBL\", species = \"Mouse\") #> org.Mm.eg.db head(rownames(dds)) #> [1] \"Gnai3\" \"Cdc45\" \"Apoh\"  \"Narf\"  \"Cav2\"  \"Klf6\"  ## 3. Differential test diff <- test_diff_deg(dds, type = \"control\", control = \"PBS\") #> Performing DESeq analysis...  #> Formatting analysis result...  #> Calulate a rlog & log2 transform assay, stored in rlg or ntd slot... deg <- add_rejections(diff, alpha = 0.01, lfc = 1)"},{"path":"/articles/01_Quick_start.html","id":"result-visualization-and-table-export","dir":"Articles","previous_headings":"Get Start","what":"Result Visualization and Table Export","title":"Quick start","text":"DEP2 provides functions visualize differential test results. plot_heatmap can draw ComplexHeatmap upon SE DEGdata object add_rejections.      Another common figure omics study volcano plot, can created using plot_volcano.    Exporting table S4 object inherits SE class straightforward. Functions like SummarizedExperiment::colData rowData can easily extract information object. DEP2 contains get_significant get_df_wide generate significant result table full dataset analysis result.","code":"class(dep) #> [1] \"SummarizedExperiment\" #> attr(,\"package\") #> [1] \"SummarizedExperiment\"  ## Sort the conditions dep = Order_cols(dep, order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\"))  ## Heatmap on centered values DEP2::plot_heatmap(dep,                    cluster_column = F,                    kmeans = T,        # kmeans cluster rows                    col_limit = 4      # limit of the color scale                    ) ## Heatmap on contrast log2 foldchange DEP2::plot_heatmap(dep,                    type = \"contrast\",                    cluster_column = F,                    kmeans = T,                     col_limit = 4) ## Manual contrast DEP2::plot_heatmap(dep,                    manual_contrast = c(\"W6_vs_PBS\",\"W4_vs_PBS\"),                    cluster_column = F,                    kmeans = T,                            col_limit = 4) ## Change color panel  DEP2::plot_heatmap(dep,                    type = \"contrast\",                    color = \"PiYG\",                    cluster_column = F,                    kmeans = T,                    col_limit = 4) ## Parameters in ComplexHeatmap::Heatmap are available ht <- DEP2::plot_heatmap(dep,                          cluster_column = F,                          kmeans = T,                          cluster_rows = F                          ) ## Heatmap can be saved as follow # pdf(\"ht.pdf\") # ht # dev.off() plot_volcano(dep) plot_volcano(deg,               contrast = \"W6_vs_PBS\",  # contrast              label_number = 20              ) #> Warning: Removed 40 rows containing missing values (`geom_point()`). #> Warning: ggrepel: 1 unlabeled data points (too many overlaps). Consider #> increasing max.overlaps library(ggplot2) (volc <- plot_volcano(deg, contrast = \"W4_vs_PBS\") + xlim(-10,10)) #> Scale for x is already present. #> Adding another scale for x, which will replace the existing scale. #> Warning: Removed 40 rows containing missing values (`geom_point()`). # ggplot2::ggsave(filename = \"volcano.png\") # export to file ## Significant table sig_tb <- get_signicant(dep,                         return_type = \"table\"                          ) sig_tb_W6_vs_PBS <- get_signicant(dep,                                   return_type = \"table\" ,                                   contrasts = \"W6_vs_PBS\"                                   )  ## Full table full_tb <- get_df_wide(dep)  dim(sig_tb) #> [1] 54 29 dim(sig_tb_W6_vs_PBS) #> [1] 23 29 dim(full_tb) #> [1] 9595   95  ## Save table in R # write.csv(full_tb,\"fulldataset.cs\",row.names = F)"},{"path":"/articles/01_Quick_start.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Quick start","text":"","code":"#> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 18.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1  #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1 #>  #> locale: #>  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     #>  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    #>  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Asia/Shanghai #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] grid      stats4    stats     graphics  grDevices utils     datasets  #> [8] methods   base      #>  #> other attached packages: #>  [1] org.Mm.eg.db_3.17.0         AnnotationDbi_1.62.2        #>  [3] ComplexHeatmap_2.16.0       ggplot2_3.4.2               #>  [5] dplyr_1.1.2                 DEP2_0.3.7.3                #>  [7] R6_2.5.1                    limma_3.56.2                #>  [9] MSnbase_2.26.0              ProtGenerics_1.32.0         #> [11] mzR_2.34.1                  Rcpp_1.0.11                 #> [13] MsCoreUtils_1.12.0          SummarizedExperiment_1.30.2 #> [15] Biobase_2.60.0              GenomicRanges_1.52.0        #> [17] GenomeInfoDb_1.36.1         IRanges_2.34.1              #> [19] S4Vectors_0.38.1            BiocGenerics_0.46.0         #> [21] MatrixGenerics_1.12.2       matrixStats_1.0.0           #> [23] BiocStyle_2.28.0            #>  #> loaded via a namespace (and not attached): #>   [1] splines_4.3.1               norm_1.0-11.1               #>   [3] bitops_1.0-7                tibble_3.2.1                #>   [5] lpsymphony_1.28.1           preprocessCore_1.62.1       #>   [7] XML_3.99-0.14               lifecycle_1.0.3             #>   [9] mixsqp_0.3-48               edgeR_3.42.4                #>  [11] doParallel_1.0.17           rprojroot_2.0.3             #>  [13] lattice_0.21-8              MASS_7.3-60                 #>  [15] MultiAssayExperiment_1.26.0 magrittr_2.0.3              #>  [17] sass_0.4.6                  rmarkdown_2.23              #>  [19] jquerylib_0.1.4             yaml_2.3.7                  #>  [21] doRNG_1.8.6                 askpass_1.1                 #>  [23] reticulate_1.30             DBI_1.1.3                   #>  [25] RColorBrewer_1.1-3          zlibbioc_1.46.0             #>  [27] Rtsne_0.16                  purrr_1.0.1                 #>  [29] AnnotationFilter_1.24.0     itertools_0.1-3             #>  [31] RCurl_1.98-1.12             sandwich_3.0-2              #>  [33] circlize_0.4.15             GenomeInfoDbData_1.2.10     #>  [35] ggrepel_0.9.3               irlba_2.3.5.1               #>  [37] umap_0.2.10.0               RSpectra_0.16-1             #>  [39] missForest_1.5              pkgdown_2.0.7               #>  [41] ncdf4_1.21                  codetools_0.2-19            #>  [43] DelayedArray_0.26.6         tidyselect_1.2.0            #>  [45] gmm_1.8                     shape_1.4.6                 #>  [47] farver_2.1.1                GenomicAlignments_1.36.0    #>  [49] jsonlite_1.8.7              GetoptLong_1.0.5            #>  [51] e1071_1.7-13                survival_3.5-5              #>  [53] iterators_1.0.14            systemfonts_1.0.4           #>  [55] bbmle_1.0.25                foreach_1.5.2               #>  [57] tools_4.3.1                 ragg_1.2.5                  #>  [59] glue_1.6.2                  xfun_0.39                   #>  [61] DESeq2_1.40.2               withr_2.5.0                 #>  [63] numDeriv_2016.8-1.1         BiocManager_1.30.21         #>  [65] fastmap_1.1.1               fansi_1.0.4                 #>  [67] openssl_2.0.6               digest_0.6.33               #>  [69] truncnorm_1.0-9             imputeLCMD_2.1              #>  [71] textshaping_0.3.6           colorspace_2.1-0            #>  [73] RSQLite_2.3.1               utf8_1.2.3                  #>  [75] tidyr_1.3.0                 generics_0.1.3              #>  [77] data.table_1.14.8           class_7.3-22                #>  [79] httr_1.4.6                  S4Arrays_1.0.4              #>  [81] pkgconfig_2.0.3             gtable_0.3.3                #>  [83] blob_1.2.4                  impute_1.74.1               #>  [85] XVector_0.40.0              htmltools_0.5.5             #>  [87] bookdown_0.34               MALDIquant_1.22.1           #>  [89] clue_0.3-64                 scales_1.2.1                #>  [91] tmvtnorm_1.5                png_0.1-8                   #>  [93] ashr_2.2-54                 knitr_1.43                  #>  [95] rstudioapi_0.15.0           reshape2_1.4.4              #>  [97] rjson_0.2.21                coda_0.19-4                 #>  [99] bdsmatrix_1.3-6             proxy_0.4-27                #> [101] cachem_1.0.8                zoo_1.8-12                  #> [103] GlobalOptions_0.1.2         stringr_1.5.0               #> [105] parallel_4.3.1              mzID_1.38.0                 #> [107] vsn_3.68.0                  desc_1.4.2                  #> [109] apeglm_1.22.1               pillar_1.9.0                #> [111] vctrs_0.6.3                 pcaMethods_1.92.0           #> [113] slam_0.1-50                 randomForest_4.7-1.1        #> [115] IHW_1.28.0                  cluster_2.1.4               #> [117] evaluate_0.21               magick_2.7.4                #> [119] invgamma_1.1                mvtnorm_1.2-2               #> [121] cli_3.6.1                   locfit_1.5-9.8              #> [123] compiler_4.3.1              Rsamtools_2.16.0            #> [125] rlang_1.1.1                 crayon_1.5.2                #> [127] rngtools_1.5.2              SQUAREM_2021.1              #> [129] labeling_0.4.2              fdrtool_1.2.17              #> [131] TCseq_1.23.0                emdbook_1.3.13              #> [133] QFeatures_1.10.0            affy_1.78.1                 #> [135] plyr_1.8.8                  fs_1.6.2                    #> [137] stringi_1.7.12              BiocParallel_1.34.2         #> [139] assertthat_0.2.1            munsell_0.5.0               #> [141] Biostrings_2.68.1           lazyeval_0.2.2              #> [143] glmnet_4.1-7                Matrix_1.5-4.1              #> [145] bit64_4.0.5                 KEGGREST_1.40.0             #> [147] highr_0.10                  igraph_1.5.0                #> [149] memoise_2.0.1               affyio_1.70.0               #> [151] bslib_0.5.0                 bit_4.0.5                   #> [153] downloader_0.4"},{"path":[]},{"path":"/articles/02_Data_import.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Data import","text":"DEP2 package utilizes make_unique function format protein/PTM-peptide-level tables imports S4 objects via make_se/pe function. parameters functions can adjusted accommodate different result tables generated search quantitative software. , present workflow provide detailed information inputs four different quantitative software programs.","code":""},{"path":"/articles/02_Data_import.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example data","title":"Data import","text":"obtained benchmark proteomics dataset spiking Yeast E.coli lysate Hela background. raw data obtained using Orbitrap Fusion Lumos Tribrid equipment either DDA DIA mode. DDA data searched quantified using MaxQuant FragPipe, DIA data analyzed using DIA-NN Spectronaut library-free mode. example tables used paper can found repository.","code":"# Download OmicsExample firstly # Change the path to Omics Example example_path = \"the/path/to/OmicsExample\" knitr::opts_knit$set(   root.dir = example_path   )  library(DEP2) library(dplyr)"},{"path":"/articles/02_Data_import.html","id":"constructing-s4-object","dir":"Articles","previous_headings":"","what":"Constructing S4 object","title":"Data import","text":"DEP2 analysis workflow build upon S4 object, initial step format table convert S4 container.","code":""},{"path":"/articles/02_Data_import.html","id":"converting-protein-level-data-into-se-format","dir":"Articles","previous_headings":"Constructing S4 object","what":"Converting protein-level data into SE format","title":"Data import","text":"protein-level data, gene name protein ID used feature identifier. DEP2 provides make_unique make_unique_ptm functions format feature identifiers proteomics results. make_unique function cleans identifiers, keeps first name/ID group, makes repeated identifiers unique adding suffix (‘ProXXX’, ‘ProXXX.1’, ‘ProXXX.2’). Repeated identifiers common library search performed isoforms unreviewed sequences. names ids parameters gene/protein names IDs. unique identifiers saved new columns “name” “id”. , make_se function can convert ‘uniqued’ table SE object.","code":""},{"path":"/articles/02_Data_import.html","id":"conversion-from-maxquant-proteingroups","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format","what":"Conversion from MaxQuant proteinGroups","title":"Data import","text":"pipeline, DEP2 use table proteinGroups.txt input. names ids columns “Gene.names” “Gene.names”, respectively. pipeline DEP2 uses SE object container store expression assay, features information (row data) experiment design (columns data). make_unique identifiers, DEP2 provides make_se/make_se_parse functions convert SummarizedExperiment object. former required input experiment design table annotate samples, must contain three columns: ‘label’, ‘condition’, ‘replicate’. ‘parse’ functions can automatically assign experiment design table parsing column names abundance assay. experiment design extracted colnames:","code":"# Load proteinGroups table mq_pgfile <- \"./A_spikeIn/MaxQuant_output/proteinGroups.txt.gz\"  pg <- read.csv(mq_pgfile,sep = \"\\t\") ## Generate unique names and ids unique_pg <- make_unique(pg,                           name = \"Gene.names\", #gene                           ids = \"Protein.IDs\"   #protein                          )  ## New columns \"name\" and \"id\", which is necessary to function make_se head(unique_pg[,c(\"name\",\"ID\",\"Gene.names\",\"Protein.IDs\")]) #>         name         ID #> 1      NUDT4     Q9NZJ9 #> 2     P0DPI2     P0DPI2 #> 3 A0A0U1RRE5 A0A0U1RRE5 #> 4 A0A0U1RRL7 A0A0U1RRL7 #> 5     JW5951 A0A385XJE6 #> 6       UBA6     A0AVT1 #>                                                                                                             Gene.names #> 1                                                                                                                NUDT4 #> 2                                                                                                                      #> 3                                                                                                                      #> 4                                                                                                                      #> 5 JW5951;JW5936;JW5935;JW5928;JW5914;JW5895;JW1882;insH11;insH10;insH9;insH8;insH7;insH6;insH4;insH3;insH2;insH1;insH5 #> 6                                                                                                                 UBA6 #>                                                                                                                                Protein.IDs #> 1                                                                                                          Q9NZJ9;A0A024RBG1;Q96G61;Q8NFP7 #> 2                                                                                                                        P0DPI2;A0A0B4J2D5 #> 3                                                                                                                               A0A0U1RRE5 #> 4                                                                                                                               A0A0U1RRL7 #> 5 A0A385XJE6;P0CE65;P0CE64;P0CE63;P0CE62;P0CE61;P0CE60;P0CE59;P0CE58;P0CE57;P0CE56;P0CE55;P0CE54;P0CE53;P0CE52;P0CE51;P0CE50;P0CE49;P76071 #> 6                                                                                                                                   A0AVT1 ## Expression columns in the input data ecols <- grep(\"LFQ.intensity.\", colnames(unique_pg))  ## Experiment design table expDesign_file <- \"./A_spikeIn/MaxQuant_output/expdesign.txt.gz\" expdesign <- read.table(expDesign_file, sep = \"\\t\", header = T) expdesign #>   label condition replicate #> 1  A1_1        A1         1 #> 2  A1_2        A1         2 #> 3  A1_3        A1         3 #> 4  B1_1        B1         1 #> 5  B1_2        B1         2 #> 6  B1_3        B1         3  ## Convert SE with expdesign table se <- make_se(unique_pg, columns = ecols, expdesign = expdesign)  ## Convert SE with expdesign table using parse function se <- make_se_parse(unique_pg, columns = ecols, mode = \"delim\") ## How experiment design is extracted from colnames. Split by delim or by character number  sample_names = c(\"Quantity.A_1\",\"Quantity.A_2\",\"Quantity.B_1\",                  \"Quantity.B_3\",\"Quantity.B_2\",\"Quantity.A_3\") get_exdesign_parse(sample_names,mode = \"delim\", sep = \"_\", remove_prefix = TRUE) #>   label  ID condition replicate #> 1   A_1 A_1         A         1 #> 2   A_2 A_2         A         2 #> 3   B_1 B_1         B         1 #> 4   B_3 B_3         B         3 #> 5   B_2 B_2         B         2 #> 6   A_3 A_3         A         3  sample_names = c(\"Quantity.A1\",\"Quantity.A2\",\"Quantity.B1\",                  \"Quantity.B3\",\"Quantity.B2\",\"Quantity.A3\") get_exdesign_parse(sample_names,mode = \"char\", chars = 1, remove_prefix = TRUE) #>   label ID condition replicate #> 1    A1 A1         A         1 #> 2    A2 A2         A         2 #> 3    B1 B1         B         1 #> 4    B3 B3         B         3 #> 5    B2 B2         B         2 #> 6    A3 A3         A         3"},{"path":"/articles/02_Data_import.html","id":"conversion-from-fragpipe-combined_protein","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format","what":"Conversion from FragPipe combined_protein","title":"Data import","text":"Next, use table combined_protein.tsv FragPipe input. Unique identifier. names ids columns “Gene” “Protein.ID”. Convert SE. , used “MaxLFQ Intensity” values. “Intesity” also practicable, may bring effect test result.","code":"# Load combined_protein.tsv table FragP_pgfile <- \"./A_spikeIn/FragPipe_output/combined_protein.tsv.gz\"  FragP_pg <- read.csv(FragP_pgfile,sep = \"\\t\") ## Generate unique names and ids unique_FragP_pg <- make_unique(FragP_pg,                                 name = \"Gene\",  #gene                                 ids = \"Protein.ID\"   #protein                                )  ## new columns name and id, which is necessary to make_se head(unique_FragP_pg[,c(\"name\", \"ID\", \"Gene\", \"Protein.ID\")]) #>     name     ID   Gene Protein.ID #> 1   ADH1 P00330   ADH1     P00330 #> 2 P00761 P00761            P00761 #> 3 CSN1S1 P02662 CSN1S1     P02662 #> 4 CSN1S2 P02663 CSN1S2     P02663 #> 5   CSN2 P02666   CSN2     P02666 #> 6   CSN3 P02668   CSN3     P02668 ## Expression col in the combined_protein.tsv ecols <- grep(\".MaxLFQ.Intensity\", colnames(unique_FragP_pg),value = T) ecols #> [1] \"A_1.MaxLFQ.Intensity\" \"A_2.MaxLFQ.Intensity\" \"A_3.MaxLFQ.Intensity\" #> [4] \"B_1.MaxLFQ.Intensity\" \"B_3.MaxLFQ.Intensity\"  ## Convert SE with expdesign table se <- make_se_parse(unique_FragP_pg,                      columns = ecols,                      mode = \"delim\",                     remove_suffix = TRUE    ## remove the col suffix \".MaxLFQ.Intensity\"                     )  ## The suffix is removed in SE colData(se) #> DataFrame with 5 rows and 4 columns #>           label          ID   condition   replicate #>     <character> <character> <character> <character> #> A_1         A_1         A_1           A           1 #> A_2         A_2         A_2           A           2 #> A_3         A_3         A_3           A           3 #> B_1         B_1         B_1           B           1 #> B_3         B_3         B_3           B           3 colnames(se) #> [1] \"A_1\" \"A_2\" \"A_3\" \"B_1\" \"B_3\""},{"path":"/articles/02_Data_import.html","id":"conversion-from-dia-nn-result","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format","what":"Conversion from DIA-NN result","title":"Data import","text":"example , make_se make_se_parse accept wide-format tables row represents features (protein proteingroup), rows contain identification information quantification information samples. However, long-format tables also widely used many cases, report.tsv output DIA-NN MSstats output. Function reshape_long2wide can turn long-format tables wide tables. Next, show difference handling wide- long-tables.","code":""},{"path":"/articles/02_Data_import.html","id":"wide-table-output","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format > Conversion from DIA-NN result","what":"Wide table output","title":"Data import","text":"report.pg_matrix.tsv DIA-NN wide-format table similar proteinGroups. Unique identifier. name ids columns “Genes” “Protein.Group”. Convert SE. expression columns directly named file names samples. recommend renaming columns renaming MS files DIAN-NN search.","code":"# Load combined_protein.tsv table Diann_pgfile <- \"./A_spikeIn/Diann_output/report.pg_matrix.tsv.gz\"  Diann_pg <- read.csv(Diann_pgfile,sep = \"\\t\", fileEncoding=\"latin1\") ## Generate unique names and ids unique_diann_pg <- make_unique(Diann_pg,                                 name = \"Genes\",  #gene                                 ids = \"Protein.Group\"   #protein                                )  ## New columns ”name“ and \"ID\", which is necessary to make_se head(unique_diann_pg[,c(\"name\", \"ID\", \"Genes\", \"Protein.Group\")]) #>        name         ID           Genes     Protein.Group #> 1 YER079C-A A0A023PZB8       YER079C-A        A0A023PZB8 #> 2   PPIAL4C A0A0B4J2A2 PPIAL4C;PPIAL4G A0A0B4J2A2;P0DN37 #> 3     GATD3 A0A0B4J2D5    GATD3;GATD3B A0A0B4J2D5;P0DPI2 #> 4   PIGBOS1 A0A0B4J2F0         PIGBOS1        A0A0B4J2F0 #> 5      SIK1 A0A0B4J2F2      SIK1;SIK1B A0A0B4J2F2;P57059 #> 6   CENPVL1 A0A0U1RR11 CENPVL1;CENPVL2 A0A0U1RR11;P0DPI3 ## Expression col in the DIA-NN report.pg_matrix ecols <- grep(\".raw$\", colnames(unique_diann_pg),value = T) ecols #> [1] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_1.raw\" #> [2] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_2.raw\" #> [3] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_3.raw\" #> [4] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_1.raw\" #> [5] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_2.raw\" #> [6] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_3.raw\"  ## Convert SE with expdesign table se <- make_se_parse(unique_diann_pg,                      columns = ecols,                      mode = \"delim\",                     remove_prefix = TRUE,   ## remove the file prefix                      remove_suffix = TRUE    ## remove the col suffix \".raw\"                     )  ## The file prefix and suffix is removed in SE colData(se) #> DataFrame with 6 rows and 4 columns #>            label          ID   condition   replicate #>      <character> <character> <character> <character> #> A6_1        A6_1        A6_1          A6           1 #> A6_2        A6_2        A6_2          A6           2 #> A6_3        A6_3        A6_3          A6           3 #> B6_1        B6_1        B6_1          B6           1 #> B6_2        B6_2        B6_2          B6           2 #> B6_3        B6_3        B6_3          B6           3 colnames(se) #> [1] \"A6_1\" \"A6_2\" \"A6_3\" \"B6_1\" \"B6_2\" \"B6_3\""},{"path":"/articles/02_Data_import.html","id":"long-table-output","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format > Conversion from DIA-NN result","what":"Long table output","title":"Data import","text":"Unlike cases, report.tsv DIA-NN long format. Function reshape_long2wide can reshape long tables wide format, constructing SE object. Reshape long-table. reshaping result ‘Genes’ column extends ‘Protein.Q.Value’ 6 columns, representing different sample. variables shrink_ident_cols combined string concatenating values feature separating ‘;’. variables extend_ident_cols expanded multiple columns, column containing values sample (e.g., “Q.Value”). Unique identifier. names ids columns “Genes” “Protein.Group”. Convert SE. expression columns also directly named file names samples.","code":"## Load combined_protein.tsv table Diann_repfile <- \"./A_spikeIn/Diann_output/report.tsv.gz\" # Diann_repfile <- \"./example_data/OmicsExample/A_spikeIn/Diann_output/report.tsv.gz\" Diann_rep <- read.csv(Diann_repfile,sep = \"\\t\") # dim(Diann_rep) # 390479 rows, each row is a precursor. #> [1] 390479     64  ## Filter out proteingroups exceeding the threshold value Diann_rep = dplyr::filter(Diann_rep, PG.Q.Value < 0.01)   ## Table report.tsv stores both Precursor- and PG-level quality DT::datatable(head(Diann_rep) %>% mutate_if(is.character, utf8::utf8_encode), options = list(scrollX = T,pageLength = 6)) Diann_rep_wided = reshape_long2wide(Diann_rep,                                     sample_col = \"File.Name\",      # the column labeling sample names                                     feature_col = \"Protein.Group\", # PG IDs                                     expression_col = \"PG.MaxLFQ\",  # PG quantity. Normalized one is also ok。                                     shrink_ident_cols  = \"Genes\",  # Gene names                                     extend_ident_cols =  \"Protein.Q.Value\",  # optional, some identification info.                                     remove_sample_prefix = FALSE,  # remove prefix in sample_col                                     remove_sample_suffix = FALSE   # remove suffix in sample_col                                     ) DT::datatable(head(Diann_rep_wided,3), options = list(scrollX = T,pageLength = 3)) ## Generate unique names and ids unique_diann_pg2 <- make_unique(Diann_rep_wided,                                  name = \"Genes\",  #gene                                  ids = \"Protein.Group\"   #protein                                 )  ## new columns name and id, which is necessary to make_se head(unique_diann_pg2[,c(\"name\", \"ID\", \"Genes\", \"Protein.Group\")],4) #>      name         ID                                           Genes #> 1   GATD3 A0A0B4J2D5                                    GATD3;GATD3B #> 2 PIGBOS1 A0A0B4J2F0                                         PIGBOS1 #> 3    SIK1 A0A0B4J2F2                                      SIK1;SIK1B #> 4   insA1 A0A385XJ53 insA1;insA2;insA3;insA4;insA5;insA6;insA8;insA9 #>                                                 Protein.Group #> 1                                           A0A0B4J2D5;P0DPI2 #> 2                                                  A0A0B4J2F0 #> 3                                           A0A0B4J2F2;P57059 #> 4 A0A385XJ53;P0CF07;P0CF08;P0CF09;P0CF10;P0CF11;P0CF12;P0CF13 ## Expression col in the DIA-NN report.pg_matrix ecols <- grep(\".raw$\", colnames(unique_diann_pg2),value = T) ecols # contains Protein.Q.Value columns #>  [1] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_1.raw\"                 #>  [2] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_2.raw\"                 #>  [3] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_3.raw\"                 #>  [4] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_1.raw\"                 #>  [5] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_2.raw\"                 #>  [6] \"F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_3.raw\"                 #>  [7] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_1.raw\" #>  [8] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_2.raw\" #>  [9] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_A6_3.raw\" #> [10] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_1.raw\" #> [11] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_2.raw\" #> [12] \"Protein.Q.Value.F..DIA_5.20211207_LM_SA_ZXF_LY_FZH_Hela_AH109_DH5.Á_FASP_DIA_B6_3.raw\"  ecols = ecols[1:6]  ## Convert SE with expdesign table se <- make_se_parse(unique_diann_pg2,                      columns = ecols,                      mode = \"delim\",                     remove_prefix = TRUE,   ## remove the file prefix                      remove_suffix = TRUE    ## remove the col suffix \".raw\"                     )  ## The file prefix and suffix is removed in SE colData(se) #> DataFrame with 6 rows and 4 columns #>            label          ID   condition   replicate #>      <character> <character> <character> <character> #> A6_1        A6_1        A6_1          A6           1 #> A6_2        A6_2        A6_2          A6           2 #> A6_3        A6_3        A6_3          A6           3 #> B6_1        B6_1        B6_1          B6           1 #> B6_2        B6_2        B6_2          B6           2 #> B6_3        B6_3        B6_3          B6           3 colnames(se) #> [1] \"A6_1\" \"A6_2\" \"A6_3\" \"B6_1\" \"B6_2\" \"B6_3\""},{"path":"/articles/02_Data_import.html","id":"conversion-from-spectronaut-report","dir":"Articles","previous_headings":"Constructing S4 object > Converting protein-level data into SE format","what":"Conversion from Spectronaut Report","title":"Data import","text":"Spectronaut offers ability customize output table. example, use built-MSstats style table, long-format. Reshape long table. Unique identifier. names Protein.Group located “Genes” “Protein.Group” columns. Convert SE. expression columns directly named file names samples.","code":"Spe_repfile <- \"./A_spikeIn/Spectronaut_output/DIA_MSStats_Report.xls.gz\" Spe_rep <- read.csv(Spe_repfile,sep = \"\\t\")  dim(Spe_rep) # 318132 rows, each row is a precursor. #> [1] 449106     12  ## Store both Precursor-, Peptides- and PG-level quality DT::datatable(head(Spe_rep) %>% mutate_if(is.character, utf8::utf8_encode), options = list(scrollX = T,pageLength = 6)) Spe_rep_wided = reshape_long2wide(Spe_rep,                                   sample_col = \"R.FileName\",      # the column labeling sample names                                   feature_col = \"PG.ProteinGroups\", # PG IDs                                   expression_col = \"PG.Quantity\",   # PG quantity.                                   shrink_ident_cols  = c(\"PG.Genes\",\"PG.Qvalue\"),  # Gene names                                   remove_sample_prefix = TRUE,    # remove prefix in sample_col                                   remove_sample_suffix = FALSE                                     ) DT::datatable(head(Spe_rep_wided), options = list(scrollX = T,pageLength = 6)) ## Generate unique names and ids unique_spe_pg <- make_unique(Spe_rep_wided,                               name = \"PG.Genes\",  #gene                               ids = \"PG.ProteinGroups\"   #protein                              )  ## new columns name and id, which is necessary to make_se head(unique_spe_pg[,c(\"name\", \"ID\", \"PG.Genes\", \"PG.ProteinGroups\")],4) #>      name         ID                                        PG.Genes #> 1  NUDT4B A0A024RBG1                                    NUDT4B;NUDT4 #> 2  GATD3B A0A0B4J2D5                                    GATD3B;GATD3 #> 3 MMP24OS A0A0U1RRL7                                         MMP24OS #> 4   insA9 A0A385XJ53 insA9;insA1;insA2;insA3;insA4;insA5;insA6;insA8 #>                                              PG.ProteinGroups #> 1                                           A0A024RBG1;Q9NZJ9 #> 2                                           A0A0B4J2D5;P0DPI2 #> 3                                                  A0A0U1RRL7 #> 4 A0A385XJ53;P0CF07;P0CF08;P0CF09;P0CF10;P0CF11;P0CF12;P0CF13 ## Expression columns in the Spectronaut output ecols <- 2:7 colnames(unique_spe_pg)[ecols] #> [1] \"A5_1\" \"A5_2\" \"A5_3\" \"B5_1\" \"B5_2\" \"B5_3\"  ## Convert SE with expdesign table se <- make_se_parse(unique_spe_pg,                      columns = ecols,                      mode = \"delim\",                     remove_prefix = TRUE,   ## remove the file prefix                      remove_suffix = FALSE   ## no suffix in this case                     )  ## The file prefix and suffix is removed in SE colData(se) #> DataFrame with 6 rows and 4 columns #>            label          ID   condition   replicate #>      <character> <character> <character> <character> #> A5_1        A5_1        A5_1          A5           1 #> A5_2        A5_2        A5_2          A5           2 #> A5_3        A5_3        A5_3          A5           3 #> B5_1        B5_1        B5_1          B5           1 #> B5_2        B5_2        B5_2          B5           2 #> B5_3        B5_3        B5_3          B5           3 colnames(se) #> [1] \"A5_1\" \"A5_2\" \"A5_3\" \"B5_1\" \"B5_2\" \"B5_3\""},{"path":"/articles/02_Data_import.html","id":"converting-peptide-level-data-to-a-qfeatures-object","dir":"Articles","previous_headings":"Constructing S4 object","what":"Converting peptide-level data to a QFeatures object","title":"Data import","text":"DEP2 provides pipeline, using QFeature package, aggregate summarize peptide quantities protein-level.protein-level quantities used preceding section counted upstream software mostly summarized using maxLFQ algorithm. DEP2 offers aggregation strategies peptide--protein analysis pipeline. following code snippet demonstrates conversion peptide-level data QFeatures object using different software outputs.","code":""},{"path":"/articles/02_Data_import.html","id":"conversion-from-maxquant-peptides","dir":"Articles","previous_headings":"Constructing S4 object > Converting peptide-level data to a QFeatures object","what":"Conversion from MaxQuant peptides","title":"Data import","text":"first step load peptide-level data QFeatures class via make_pe make_pe_pars function. start reading peptides.txt file MaxQuant txt directory. convert data QFeatures object, extract ‘intensity’ columns.","code":"mq_pepfile <- \"./A_spikeIn/MaxQuant_output/peptides.txt.gz\"  mq_pep <- read.csv(mq_pepfile,sep = \"\\t\") ecols <- grep(\"Intensity.\", colnames(mq_pep)) ## the peptides intensity cols mq_pe <- make_pe(mq_pep, columns = ecols, expdesign = expdesign) mq_pe #> An instance of class QFeatures containing 1 assays: #>  [1] peptideRaw: SummarizedExperiment with 69582 rows and 6 columns"},{"path":"/articles/02_Data_import.html","id":"conversion-from-fragpipe-combined_peptides","dir":"Articles","previous_headings":"Constructing S4 object > Converting peptide-level data to a QFeatures object","what":"Conversion from FragPipe combined_peptides","title":"Data import","text":"Next, process combined_peptide.tsv file generated FragPipe. use ‘Intensity’ columns expression columns.","code":"FragP_pepfile <- \"./A_spikeIn/FragPipe_output/combined_peptide.tsv.gz\"  FragP_pep <- read.csv(FragP_pepfile,sep = \"\\t\") ecols <- grep(\"[0-9].Intensity\", colnames(FragP_pep),value = T)  ## the peptides intensity cols  FragP_pe <- make_pe_parse(FragP_pep, columns = ecols,                            mode = \"delim\",                            remove_suffix = T ## remove suffix                           ) colData(FragP_pe) #> DataFrame with 5 rows and 4 columns #>           label          ID   condition replicate #>     <character> <character> <character> <integer> #> A_1         A_1         A_1           A         1 #> A_2         A_2         A_2           A         2 #> A_3         A_3         A_3           A         3 #> B_1         B_1         B_1           B         1 #> B_3         B_3         B_3           B         3"},{"path":"/articles/02_Data_import.html","id":"conversion-from-dia-nn-report","dir":"Articles","previous_headings":"Constructing S4 object > Converting peptide-level data to a QFeatures object","what":"Conversion from DIA-NN report","title":"Data import","text":"reshape peptide quantities wide table using reshape_long2wide function. ‘Stripped.Sequence’ column represents peptide IDs. stripped peptide may multiple precursors due variable modifications different charge states. peptides, function retains maximum expression values.","code":"## filter out proteingroups exceed the threshold value Diann_rep = dplyr::filter(Diann_rep, PG.Q.Value < 0.01)  Diann_pep_wided = reshape_long2wide(Diann_rep,                                     sample_col = \"File.Name\",      # the column labeling sample names                                     feature_col = \"Stripped.Sequence\", # PG IDs                                     expression_col = \"Precursor.Quantity\",  # PG quantity. Normalized one is also ok。                                     shrink_ident_cols  = c(\"Protein.Group\",\"Genes\"),  # Gene names                                     extend_ident_cols =  c(\"Global.Q.Value\"),  # optional, some identification info.                                     remove_sample_prefix = FALSE,  # remove prefix in sample_col                                     remove_sample_suffix = FALSE   # remove suffix in sample_col                                     ) DT::datatable(head(Diann_pep_wided), options = list(scrollX = T,pageLength = 6)) ecols = 2:7  pe <- make_pe_parse(Diann_pep_wided, columns = ecols,                      mode = \"delim\",                      remove_suffix = T ## remove suffix                     )"},{"path":"/articles/02_Data_import.html","id":"conversion-from-spectronaut-result","dir":"Articles","previous_headings":"Constructing S4 object > Converting peptide-level data to a QFeatures object","what":"Conversion from Spectronaut result","title":"Data import","text":"Spectronaut result also store peptide-level quantities. Reshape long-table. Convert QFeatures object","code":"Spe_repfile <- \"./A_spikeIn/Spectronaut_output/DIA_MSStats_Report.xls.gz\" Spe_rep <- read.csv(Spe_repfile,sep = \"\\t\") # dim(Spe_rep) # 318132 rows, each row is a precursor. #> [1] 449106     12  ## Store both Precursor-, Peptides- and PG-level quality DT::datatable(head(Spe_rep) %>% mutate_if(is.character, utf8::utf8_encode), options = list(scrollX = T,pageLength = 6)) Spe_rep_wided2 = reshape_long2wide(Spe_rep,                                    sample_col = \"R.FileName\",      # the column labeling sample names                                    feature_col = \"PEP.StrippedSequence\", # peptide sequence                                    expression_col = \"PEP.Quantity\",      # peptide quantity.                                    shrink_ident_cols  = c(\"PG.Genes\",\"PG.ProteinAccessions\"),  # Gene names and protien IDs                                    remove_sample_prefix = TRUE,    # remove prefix in sample_col                                    remove_sample_suffix = FALSE                                      ) ecols = 2:7  pe <- make_pe_parse(Spe_rep_wided2, columns = ecols,                      mode = \"delim\",                      remove_suffix = T ## remove suffix                     ) colData(pe) #> DataFrame with 6 rows and 4 columns #>            label          ID   condition replicate #>      <character> <character> <character> <integer> #> A5_1        A5_1        A5_1          A5         1 #> A5_2        A5_2        A5_2          A5         2 #> A5_3        A5_3        A5_3          A5         3 #> B5_1        B5_1        B5_1          B5         1 #> B5_2        B5_2        B5_2          B5         2 #> B5_3        B5_3        B5_3          B5         3"},{"path":"/articles/02_Data_import.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Data import","text":"","code":"#> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 18.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1  #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1 #>  #> locale: #>  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     #>  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    #>  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Asia/Shanghai #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] dplyr_1.1.2                 DEP2_0.3.7.3                #>  [3] R6_2.5.1                    limma_3.56.2                #>  [5] MSnbase_2.26.0              ProtGenerics_1.32.0         #>  [7] mzR_2.34.1                  Rcpp_1.0.11                 #>  [9] MsCoreUtils_1.12.0          SummarizedExperiment_1.30.2 #> [11] Biobase_2.60.0              GenomicRanges_1.52.0        #> [13] GenomeInfoDb_1.36.1         IRanges_2.34.1              #> [15] S4Vectors_0.38.1            BiocGenerics_0.46.0         #> [17] MatrixGenerics_1.12.2       matrixStats_1.0.0           #> [19] BiocStyle_2.28.0            #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3          rstudioapi_0.15.0           #>   [3] jsonlite_1.8.7              shape_1.4.6                 #>   [5] umap_0.2.10.0               MultiAssayExperiment_1.26.0 #>   [7] magrittr_2.0.3              MALDIquant_1.22.1           #>   [9] rmarkdown_2.23              GlobalOptions_0.1.2         #>  [11] fs_1.6.2                    zlibbioc_1.46.0             #>  [13] ragg_1.2.5                  vctrs_0.6.3                 #>  [15] memoise_2.0.1               Rsamtools_2.16.0            #>  [17] RCurl_1.98-1.12             askpass_1.1                 #>  [19] BiocBaseUtils_1.2.0         itertools_0.1-3             #>  [21] htmltools_0.5.5             S4Arrays_1.0.4              #>  [23] missForest_1.5              mzID_1.38.0                 #>  [25] sass_0.4.6                  bslib_0.5.0                 #>  [27] htmlwidgets_1.6.2           desc_1.4.2                  #>  [29] plyr_1.8.8                  impute_1.74.1               #>  [31] cachem_1.0.8                GenomicAlignments_1.36.0    #>  [33] igraph_1.5.0                lifecycle_1.0.3             #>  [35] iterators_1.0.14            pkgconfig_2.0.3             #>  [37] Matrix_1.5-4.1              fastmap_1.1.1               #>  [39] GenomeInfoDbData_1.2.10     clue_0.3-64                 #>  [41] digest_0.6.33               fdrtool_1.2.17              #>  [43] pcaMethods_1.92.0           colorspace_2.1-0            #>  [45] DESeq2_1.40.2               rprojroot_2.0.3             #>  [47] RSpectra_0.16-1             crosstalk_1.2.0             #>  [49] textshaping_0.3.6           randomForest_4.7-1.1        #>  [51] fansi_1.0.4                 compiler_4.3.1              #>  [53] rngtools_1.5.2              proxy_0.4-27                #>  [55] withr_2.5.0                 doParallel_1.0.17           #>  [57] downloader_0.4              BiocParallel_1.34.2         #>  [59] MASS_7.3-60                 openssl_2.0.6               #>  [61] DelayedArray_0.26.6         rjson_0.2.21                #>  [63] tools_4.3.1                 glue_1.6.2                  #>  [65] QFeatures_1.10.0            grid_4.3.1                  #>  [67] Rtsne_0.16                  cluster_2.1.4               #>  [69] reshape2_1.4.4              generics_0.1.3              #>  [71] gtable_0.3.3                class_7.3-22                #>  [73] preprocessCore_1.62.1       tidyr_1.3.0                 #>  [75] data.table_1.14.8           utf8_1.2.3                  #>  [77] XVector_0.40.0              foreach_1.5.2               #>  [79] pillar_1.9.0                stringr_1.5.0               #>  [81] circlize_0.4.15             splines_4.3.1               #>  [83] lattice_0.21-8              survival_3.5-5              #>  [85] tidyselect_1.2.0            ComplexHeatmap_2.16.0       #>  [87] locfit_1.5-9.8              Biostrings_2.68.1           #>  [89] knitr_1.43                  bookdown_0.34               #>  [91] edgeR_3.42.4                xfun_0.39                   #>  [93] DT_0.28                     stringi_1.7.12              #>  [95] lazyeval_0.2.2              yaml_2.3.7                  #>  [97] evaluate_0.21               codetools_0.2-19            #>  [99] tibble_3.2.1                BiocManager_1.30.21         #> [101] cli_3.6.1                   affyio_1.70.0               #> [103] reticulate_1.30             systemfonts_1.0.4           #> [105] munsell_0.5.0               jquerylib_0.1.4             #> [107] TCseq_1.23.0                png_0.1-8                   #> [109] XML_3.99-0.14               parallel_4.3.1              #> [111] ellipsis_0.3.2              pkgdown_2.0.7               #> [113] ggplot2_3.4.2               assertthat_0.2.1            #> [115] doRNG_1.8.6                 AnnotationFilter_1.24.0     #> [117] bitops_1.0-7                glmnet_4.1-7                #> [119] scales_1.2.1                affy_1.78.1                 #> [121] e1071_1.7-13                ncdf4_1.21                  #> [123] purrr_1.0.1                 crayon_1.5.2                #> [125] GetoptLong_1.0.5            rlang_1.1.1                 #> [127] vsn_3.68.0"},{"path":"/articles/03_DEP2_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"DEP2 analysis workflow","text":"DEP2 downstream analysis toolkit mass spectrometry-based quantitative proteomics data. package contains integrated workflow proteomics analysis, including data processing, missing value imputation, hypothesis test, visualization downstream function exploration. accepts various proteomics results generated upstream search quantitative software provides functions format table. vignette, utilize built-data DEP2. native tables upstream software available repository. Now, DEP2 provide three types differential proteomics analysis: Protein-Level Expression/Enrichment Analysis Pipeline pipeline basically follows method DEP, requires protein-level quantitative result (e.g., proteingroups.txt). Protein Expression/Enrichment Analysis Pipeline Peptide-protein aggregation. pipeline utilizes peptide protein summarization strategies QFeatures, requires peptide-level quantitative result (e.g. peptide.txt). Pipeline Post-Translational Modification (PTM)-Specific Proteomics. pipeline derived first one requires PTM pepeide data input. includes additional modification information analysis. addition proteomics analysis pipelines, DEP2 packages optional RNA-seq analysis pipeline DESeq2. Downstream exploration functions also integrated workflow, including functional enrichment provided clusterProfiler (Wu et al. 2021) ReactomePA`, protein-protein interaction inference STRING database, time-course expression pattern clustering though cmeans cluster.","code":""},{"path":[]},{"path":"/articles/03_DEP2_analysis.html","id":"differentially-expression-analysis","dir":"Articles","previous_headings":"","what":"Differentially expression analysis","title":"DEP2 analysis workflow","text":"steps four analysis pipelines different slightly, input table read . details, please refer vignette titled Data import.","code":""},{"path":"/articles/03_DEP2_analysis.html","id":"protein-level-expressionenrichment-analysis-pipeline","dir":"Articles","previous_headings":"Differentially expression analysis","what":"Protein-Level Expression/Enrichment Analysis Pipeline","title":"DEP2 analysis workflow","text":"Loading data  Converting SE object Filtering result table may contain undesired features reverse sequences contaminant protein hits. Additionally, missing values (MVs) inevitable label-free MS-based proteomics, especially DDA data. Low quantity features many missing values can introduce noise bias analysis, potentially leading false positive.Filtering reverse, contaminant, low-quality features many missing values necessary performing statistical tests improve accuracy reliability statistical tests. filter_se function can used filter features based either MVs threshold specified criteria.  Normalization DEP DEP2 workflow, assay log2-transformed SE construction. proteingroup assay normalized using variance stabilizing transformation(vsn).  imputation Even filtering, considerable proportion MVs may still remain assay.  MVs can classified missing random (MAR), missing random (MNAR) based frequency intensity NA signals. DEP2::impute function provides kinds imputation methods SE objects. addition methods Inheriting DEP, impute also includes imputation functions MSnbase MsCoreUtils packages. methods include: – Left-censored imputation methods, replace: “MinDet,” “MinProb,” “min”(LOD), “QRILC,” “zero,” “man”(impute left-shifted distribution) – Local similarity methods: “knn,” “nbavg” – Global-structure methods: “MLE,” “BPCA” details imputation, please refer vignettes imputation DEP MSnbase packages. Additionally, DEP2 includes two machine learning based imputation impute: “RF” “GSimp”. “RF” uses missForest::missForest function, train random forest based observed parts dataset. “GSimp” Gibbs sampler based left-censored imputation method proposed Runmin Wei, Jingye Wang, etc. two methods may take long time iteration reported draw better estimation missing values.  distribution mean intensity proteingroups without MVs difference among imputation methods.  Left-censored approaches MinProb GSimp replace MVs conservatively low values, local similarity method “knn” global data learning method “RF” impute relatively larger values. two kinds methods cater MNAR MAR, respectively. However, “knn” impute mean value row contains 50% missing values. Hypothesis testing test_diff function performs moderated t-test using limma. DEP, p-values corrected, using fdrtool classify significantly regulated/enriched candidates stable proteins. DEP2 additionally provides two alternative frequently-used FDR control methods: “Benjamini-Hochberg fdr” “Storey’s qvalue.” Function add_rejections can classify significant hits according L2FC (lfc) adjusted p value (alpha) threshold. Use plot_volcano function quickly visualize results.   addition intersect method, add_rejections can draw curve cutoff approach described Eva C.Keilhauer. Instead intersect straight lines, approach uses curve lines \\(y > c/(x - x_0)\\), \\(x\\) log2 FC, \\(y\\) adjusted p values features. parameters c \\(x_0\\) represent curvature minimum L2FC, respectively. value \\(x_0\\) determined using standard deviation \\(\\sigma\\) \\(x_0 = x_0.fold*\\sigma\\). \\(\\sigma\\) standard deviation Gaussian curve distribution log2 fold changes contrast.  can check \\(\\sigma\\) fitted Gaussian curve via plot_diff_hist function.  plot_heatmap function can plot heatmap significant candidates.","code":"# ProteinGroups table data(\"Silicosis_pg\")  # Format name(gene symbol) and id(protein ID).  # Generate a unique names for each protein. names and ids are columns in table unique_pg <- make_unique(Silicosis_pg, names = \"Gene.names\",                           ids = \"Protein.IDs\", delim = \";\") # Take expression columns(LFQ intensity in this cases). ecols <- grep(\"LFQ.intensity.\", colnames(unique_pg))  # Construct SE. The experiement design is exctracted from column. se_pg <- DEP2::make_se_parse(unique_pg, columns = ecols, mode = \"delim\",                               sep = \"_\", remove_prefix = T, log2transform = T) ## Filter on MVs. filter_pg <- filter_se(se_pg,                        thr = 1,  ## the threshold of missing number in at least one condition                        fraction = 0.3 ## the threshold of missing occupancy in each protein                                               ) #> filter base on missing number is <= 1 in at least one condition. #> filter base on missing number fraction < 0.3 in each row  ## Further filter can be performed though filter_formula. ### Fox example, remove decoys or contaminants. filter_pg <- filter_se(filter_pg,                        filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ## filter upon Reverse and contaminant                       ) #> filter base on giving formula ### Or set a unique.peptide threshold. filter_pg <- filter_se(filter_pg,                        filter_formula = ~ Unique.peptides > 0) #> filter base on giving formula   get_df_wide(se_pg)$Reverse %>% table #> . #>           +  #> 10378   340 get_df_wide(filter_pg)$Reverse %>% table #> . #>       #> 8982  (plot_frequency(se_pg) + ggtitle(\"Identification overlap before filter\")) /    (plot_frequency(filter_pg) + ggtitle(\"Identification overlap after before filter\")) norm_pg <- normalize_vsn(filter_pg)  plot_normalization(filter_pg, norm_pg) plot_missval(filter_pg) set.seed(35) sample_rows <- sample(1:nrow(norm_pg), 300) norm_pg_sample = norm_pg[sample_rows,] # random sample 150 features to reduce runing time plot_detect(norm_pg_sample) ## Impute missing data using random draws from a Gaussian distribution centered around a minimal value (for MNAR) imp_pg_MinProb <- DEP2::impute(norm_pg_sample, fun = \"MinProb\", q = 0.01) #> [1] 0.31744  ## Impute missing data using k-nearest neighbour approach imp_pg_knn <- DEP2::impute(norm_pg_sample, fun = \"knn\")  ## Impute missing data using missForest imp_pg_RF <- DEP2::impute(norm_pg_sample, fun = \"RF\", ntree = 50, mtry = 5)   ## Impute missing data using Gibbs imp_pg_GSimp <- DEP2::impute(norm_pg_sample, fun = \"GSimp\", hi_q = 0.1,                        iters_each=40, iters_all=8) #> Iteration 1 start...end! #> Iteration 2 start...end! #> Iteration 3 start...end! #> Iteration 4 start...end! #> Iteration 5 start...end! #> Iteration 6 start...end! #> Iteration 7 start...end! #> Iteration 8 start...end!  ## Impute missing data using QRILC imp_pg_QRILC <- DEP2::impute(norm_pg_sample, fun = \"QRILC\") plot_detect(norm_pg_sample) NAs <- is.na(assay(norm_pg_sample))  ## the imputed values by different methods. imps <- list(\"GSimp\" = imp_pg_GSimp, \"QRILC\" = imp_pg_QRILC, \"MinProb\" = imp_pg_MinProb, \"RF\" = imp_pg_RF, \"knn\" = imp_pg_knn) %>%    lapply(function(se){     x = assay(se) %>% data.frame %>% gather(\"label\", \"value\") %>%        left_join(colData(se)[c(\"label\",\"condition\")],copy = T) %>%       magrittr::extract(as.vector(NAs),)   }) %>% data.table::rbindlist(idcol = \"method\")  ## the original normalized values without imputation nonimps <- assay(norm_pg_sample) %>% data.frame %>% gather(\"label\", \"value\") %>%   left_join(colData(norm_pg_sample)[c(\"label\",\"condition\")],copy = T) %>%    magrittr::extract(!as.vector(NAs),) %>% mutate(method = \"non_impute\") %>%   dplyr::select(method,everything())  library(ggridges) ggplot(rbind(imps, nonimps),aes(x = value,y = factor(method,level = unique(method)))) +    geom_density_ridges(fill = \"#027ad450\", scale = 1.2,                       jittered_points = TRUE,position = position_points_jitter(height = 0),                       point_shape = '|', point_size = 2, point_alpha = 1, alpha = 0.7) +   ylab(\"Impute method\")+ ylab(\"Log2 value\") + xlim(c(9,39))+   theme_DEP1() rm(list = c(\"norm_pg_sample\", \"imp_pg_knn\",\"imp_pg_MinProb\",\"imp_pg_RF\",\"imp_pg_GSimp\")) ## Impute missing data using q-th quantile for following analysis imp_pg <- impute(norm_pg, fun = \"MinDet\" ,q = 0.01) #> Imputing along margin 2 (samples/columns). ## Test every sample versus PBS control diff_pg <- test_diff(imp_pg, type = \"control\", control = \"PBS\", fdr.type = \"BH\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> BH ## Test on manual contrasts diff_pg2 <- test_diff(imp_pg, type = \"manual\", test  = c(\"W4_vs_PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W4_vs_PBS #> Storey's qvalue ## Add significant rejections for features, based on  dep_pg <- add_rejections(diff_pg, alpha = 0.01, lfc = 2)  ## get the significant subset dep_pg_sig <- get_signicant(dep_pg) nrow(dep_pg_sig) #> [1] 249 ### volcano plot on contrast \"W4_vs_PBS\" plot_volcano(dep_pg, contrast = \"W4_vs_PBS\", adjusted = F) ## plot the cutoff line plot_volcano(dep_pg, contrast = \"W4_vs_PBS\", adjusted = F,              add_threshold_line = \"intersect\", pCutoff  = 0.05, fcCutoff = 1) #> add intersect threshold line. fcCutoff = 1pCutoff = 0.05 ## thresholdmethod = \"curve\" dep_pg_curve <- add_rejections(diff_pg, thresholdmethod = \"curve\", curvature  = 2, x0_fold = 2)  ## the cutoff line on volcano plot_volcano(dep_pg_curve, contrast = \"W4_vs_PBS\", add_threshold_line = \"curve\", curvature = 2, x0_fold = 2) /   plot_volcano(dep_pg_curve, contrast = \"W6_vs_PBS\", add_threshold_line = \"curve\", curvature = 2, x0_fold = 2) #> add curve threshold line. Sigma = 0.416241386089189, x0 = 0.832482772178379, curvature = 2 #> add curve threshold line. Sigma = 0.478600344109222, x0 = 0.957200688218444, curvature = 2 ## Check the fitted Gaussian curve plot_diff_hist(dep_pg_curve, contrasts = c(\"W4_vs_PBS\", \"W6_vs_PBS\")) ## Get the fit result  plot_diff_hist(dep_pg_curve, plot = F) ## a table of gaussian args \\sigma and \\mu #>          contrast         mu    sigma2 #> 1 W10_vs_PBS_diff 0.01374325 0.2407074 #> 2  W2_vs_PBS_diff 0.02327110 0.2266282 #> 3  W4_vs_PBS_diff 0.02511490 0.1732569 #> 4  W6_vs_PBS_diff 0.02201209 0.2290583 #> 5  W9_vs_PBS_diff 0.02354730 0.2595546 plot_heatmap(dep_pg) ## Reorder columns by condition dep_pg = DEP2::Order_cols(dep_pg,order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\")) plot_heatmap(dep_pg, cluster_columns = F, kmeans = T, k = 5, seed = 1) # cluster features ## Only plot the clusters that are up-regulated in treatment groups. plot_heatmap(dep_pg, cluster_columns = F, kmeans = T, k = 5, seed = 1, col_limit = 4,              split_order = c(1,2,5)              ) ## plot on select contrast plot_heatmap(dep_pg, manual_contrast = \"W4_vs_PBS\")"},{"path":"/articles/03_DEP2_analysis.html","id":"protein-expressionenrichment-analysis-pipeline-with-peptide-protein-aggregation-","dir":"Articles","previous_headings":"Differentially expression analysis","what":"Protein Expression/Enrichment Analysis Pipeline with Peptide-protein Aggregation.","title":"DEP2 analysis workflow","text":"second pipeline involves aggregating protein abundance peptide quantity data. analysis workflow differs previous one terms data processing steps.  Loading Data Converting QFeatures Object make_pe/make_pe_parse functions can used convert QFeatures object. functions similar usage pattern make_se series functions. Filtering QFeatures objects can filtered using filter_pe. usage similar function filter_se can filter unexpected features based missing ratio identification information certain rowdata columns. Imputation Imputation performed normalization order reduce potential effect caused MVs. instance, “quantiles.robust” normalization work assay MVs. However, also acceptable normalize data replacing MVs, using “vsn” followed “knn” imputation.  Normalization normalize_pe function perform data normalization . Four normalization methods available: “diff.median,” “quantiles,” “quantiles.robust” ,“vsn”. Notice quantiles.robust handle data table MVs (ie NA), necessary impute advance.  Aggregation DEP2 offers aggregate_pe function based QFeatures::aggregateFeatures. summarisation approach aggrefun can “RobustSummary” (also called MSqRobSum) (Sticker et al. 2020), “medianPolish,” “totalMean.” Details can seen ?aggregateFeatures. proteingroups can summed “Unique + Razor” peptides “Unique” peptides. aggregate_pe require several minutes depending peptide assay scale. Differential Test following differential test proteingroups pipeline. Use test_diff add_rejections classify significant proteins. Data visualization functions also work results re-aggregation pipeline.","code":"data(\"Silicosis_peptide\") ## Here we only select two groups to save computational cost in these vignette (ecols <- grep(\"Intensity.PBS|Intensity.W4\", colnames(Silicosis_peptide), value = T))  #> [1] \"Intensity.PBS_1\" \"Intensity.PBS_2\" \"Intensity.PBS_3\" \"Intensity.PBS_4\" #> [5] \"Intensity.W4_2\"  \"Intensity.W4_3\"  \"Intensity.W4_4\"  \"Intensity.W4_5\"  pe <- make_pe_parse(Silicosis_peptide, columns = ecols, mode = \"delim\") pe #> An instance of class QFeatures containing 1 assays: #>  [1] peptideRaw: SummarizedExperiment with 143528 rows and 8 columns filt_pe <- filter_pe(pe,                       thr = 1,fraction = 0.4,  ## filter based on missing values                      filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) #> filter base on missing number is <= 1 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula ## Use QFeatures::addAssay() and DEP2::impute pe <- QFeatures::addAssay(filt_pe,                               DEP2::impute(filt_pe[[\"peptideRaw\"]], fun = \"QRILC\"),                                name = \"peptideImp\") plot_imputation(pe[[\"peptideRaw\"]], pe[[\"peptideImp\"]]) pe <- DEP2:::normalize_pe(pe,method = \"quantiles.robust\",                                i = \"peptideImp\",    ## nomalize on which assay                                name = \"peptideNorm\" ## output assay name                                )  plot_normalization(pe[[\"peptideRaw\"]],pe[[\"peptideImp\"]],pe[[\"peptideNorm\"]]) begin_time = Sys.time()  pe <- DEP2::aggregate_pe(pe,                          aggrefun = \"RobustSummary\",                          aggregate_Peptide_Type = \"Unique + Razor\",                          fcol = \"Proteins\",                  # the protein ID column in input table                          i = \"peptideNorm\", # the assay to aggregate                          reserve = \"Gene.names\"              # reserve the Gene.names in row data. ) #> [1] \"aggregate by Unique + Razor peptides\" #> [1] \"peptides distribution finished\" #> [1] \"begin assay aggregate\" #> [1] \"begin reducedataframe\" #> [1] \"reducedataframe finiched\" #> [1] \"assay aggregate finished\" #> [1] \"aggregation finished\"  print(Sys.time() - begin_time) # aggregate cost several minutes depent on the assay scale #> Time difference of 1.524174 mins  pe # protein result is in the protein assay #> An instance of class QFeatures containing 4 assays: #>  [1] peptideRaw: SummarizedExperiment with 98219 rows and 8 columns  #>  [2] peptideImp: SummarizedExperiment with 98219 rows and 8 columns  #>  [3] peptideNorm: SummarizedExperiment with 98219 rows and 8 columns  #>  [4] protein: SummarizedExperiment with 9768 rows and 8 columns se_pep <- pe2se(pe, names = \"Gene.names\", ids = \"smallestProteingroups\") ## Differential test diff_pep <- DEP2::test_diff(se_pep,type = \"control\", control = \"PBS\", fdr.type = \"BH\") #> Tested contrasts: W4_vs_PBS #> BH ## Add rejections dep_pep <- add_rejections(diff_pep,alpha = 0.01, lfc = 2) get_signicant(dep_pep) %>% nrow #> [1] 76 ## Volcano plot_volcano(dep_pep, contrast = \"W4_vs_PBS\", add_threshold_line = \"intersect\")  #> add intersect threshold line. fcCutoff = 1pCutoff = 0.05 ## Heatmap plot_heatmap(dep_pep, kmeans = T,k = 5,col_limit = 6)"},{"path":"/articles/03_DEP2_analysis.html","id":"pipeline-for-post-translational-modification-ptm-specific-proteomics-","dir":"Articles","previous_headings":"Differentially expression analysis","what":"Pipeline for Post-Translational Modification (PTM)-Specific Proteomics.","title":"DEP2 analysis workflow","text":"DEP2 designed new workflow post-modification proteomics data analysis starting modified peptides’ quantitative results. post-translation modification information necessary distinguish modified sites, including position, modified residue (amino acid), gene name, protein ID associated modification. make_unique_ptm creates (overwrites) PTM information columns, including name, ID, gene_name, protein_ID, modified_aa, modified_pos. name ID columns identifiers modified-peptide, following naming rule: ’(gene name/protein ID)_(modified amino acid)(position modification)’ (e.g., “TBCA_K51” “O75347_K51”). Loading Data example used phosphorylated peptide result, table Phospho (STY)Sites.txt, MaxQuant. name ID generated upon PTM information columns. Coverting SE Filtering following steps basically similar protomics analysis pipeline. filter_se universal filter function SE objects. additional threshold set ‘Localization.prob’ MaxQuant modification result. Normalization Imputation Differantail testing","code":"## phosphorylated peptides table of the silicosis mouse model. data(Silicosis_phos)   ## Format the modification information and generated modified-peptides identifier. ## aa and pos is the modified amino acids and modified site in protein. unique_pho <- make_unique_ptm(Silicosis_phos, gene_name = \"Gene.names\",                                protein_ID = \"Protein\", aa = \"Amino.acid\",                               pos = \"Position\") DT::datatable(unique_pho[1:7,c(\"name\",\"ID\",\"Gene.names\",\"Protein\",\"Amino.acid\",\"Position\")],               options = list(scrollX = T,pageLength = 7)) ## Take 'Intensity' columns. ecols <- grep(\"Intensity.\", colnames(unique_pho))  ## Construct a SE object mentioned before. se_ptm <- make_se_parse(unique_pho, columns = ecols,                          mode = \"delim\", sep = \"_\", remove_prefix = T, log2transform = T) ## Filter base on both missing occupancy and the localization probability for this site. filt_ptm <- filter_se(se_ptm,                        thr = 1, fraction = 0.3,                        filter_formula = ~ Reverse!=\"+\" &                          Potential.contaminant!=\"+\" &                          Localization.prob>0.7                       ) ## VSN normalization norm_ptm <- normalize_vsn(filt_ptm) ## KNN impute relatively larger values imp_ptm <- impute(filt_ptm, fun= \"knn\") #> Cluster size 11729 broken into 6954 4775  #> Cluster size 6954 broken into 2918 4036  #> Cluster size 2918 broken into 2328 590  #> Cluster size 2328 broken into 1841 487  #> Cluster size 1841 broken into 1661 180  #> Cluster size 1661 broken into 1404 257  #> Done cluster 1404  #> Done cluster 257  #> Done cluster 1661  #> Done cluster 180  #> Done cluster 1841  #> Done cluster 487  #> Done cluster 2328  #> Done cluster 590  #> Done cluster 2918  #> Cluster size 4036 broken into 56 3980  #> Done cluster 56  #> Cluster size 3980 broken into 2552 1428  #> Cluster size 2552 broken into 2523 29  #> Cluster size 2523 broken into 468 2055  #> Done cluster 468  #> Cluster size 2055 broken into 1044 1011  #> Done cluster 1044  #> Done cluster 1011  #> Done cluster 2055  #> Done cluster 2523  #> Done cluster 29  #> Done cluster 2552  #> Done cluster 1428  #> Done cluster 3980  #> Done cluster 4036  #> Done cluster 6954  #> Cluster size 4775 broken into 2517 2258  #> Cluster size 2517 broken into 1379 1138  #> Done cluster 1379  #> Done cluster 1138  #> Done cluster 2517  #> Cluster size 2258 broken into 861 1397  #> Done cluster 861  #> Done cluster 1397  #> Done cluster 2258  #> Done cluster 4775 diff_ptm <- test_diff(imp_ptm, type = \"manual\", test = \"PBS_vs_W6\" , fdr.type = \"BH\") #> Tested contrasts: PBS_vs_W6 #> BH  dep_ptm <- DEP2::add_rejections(diff_ptm, alpha = 0.05, lfc = 1) plot_volcano(dep_ptm,adjusted = T, add_threshold_line = \"intersect\") #> add intersect threshold line. fcCutoff = 1pCutoff = 0.05"},{"path":"/articles/03_DEP2_analysis.html","id":"additional-analysis-pipeline-for-rna-seq-counts","dir":"Articles","previous_headings":"Differentially expression analysis","what":"Additional Analysis Pipeline for RNA-seq Counts","title":"DEP2 analysis workflow","text":"Multi-omics studies already become widespread method research. particular, proteomics-transcriptomics combined studies provide insights regulatory mechanisms multiple perspectives. Therefore, DEP2 packages pipeline RNA-seq data DESeq2. Loading Data Constructing DESeqDataSet make_dds function can used convert DESeqDataSet object. usage similar function make_se. Filtering DESeqDataSet object inherits SummarizedExperiment. Filter_se can also used filter DESeqDataSet objects. rowsum_threshold parameter sets threshold row sum counts. Transforming ID case, gene identifier Ensembl ID. conveniently check genes, DEP2 can transform IDs gene symbols using OrgDb databases. ID_transform function performs ID conversion replaces rownames object. function requires species annotation database. can execute check_organismDB_depends function verify install necessary package already installed. needed, ID_transform can used proteinomics data, example: Differential Test differential test steps similar foregoing pipelines, test_diff replaced test_diff_deg call DESeq2.","code":"data(Silicosis_counts) DT::datatable(head(Silicosis_counts), options = list(scrollX = T,pageLength = 6)) dds <- make_dds_parse(Silicosis_counts,mode = \"delim\") dds #> class: DESeqDataSet  #> dim: 24936 18  #> metadata(1): version #> assays(1): counts #> rownames(24936): ENSMUSG00000000001 ENSMUSG00000000028 ... #>   ENSMUSG00000118633 ENSMUSG00000118636 #> rowData names(0): #> colnames(18): PBS_1 PBS_2 ... W10_2 W10_3 #> colData names(4): label ID condition replicate inherits(dds,\"SummarizedExperiment\") #> [1] TRUE dds <- filter_se(dds, fraction = 0.3, thr = 1, rowsum_threshold = 35) #> filter base on missing number is <= 1 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on counts sum >=35 ## Check if the annotation package has been already installed. Or install it if not yet. check_organismDB_depends(organism = \"Mouse\") #>  #> [1] TRUE  head(rownames(dds),4) #> [1] \"ENSMUSG00000000001\" \"ENSMUSG00000000028\" \"ENSMUSG00000000049\" #> [4] \"ENSMUSG00000000056\"  ## Transform ID dds <- DEP2::ID_transform(dds, species = \"Mouse\") #> org.Mm.eg.db #> Loading required package: org.Mm.eg.db #> Loading required package: AnnotationDbi #>  #> Attaching package: 'AnnotationDbi' #> The following object is masked from 'package:dplyr': #>  #>     select #> 'select()' returned 1:many mapping between keys and columns head(rownames(dds),4) #> [1] \"Gnai3\" \"Cdc45\" \"Apoh\"  \"Narf\" DEP2::ID_transform(dep_pg,                     species = \"Mouse\",                    from_columns = \"ID\",                    fromtype = \"UNIPROT\") diff <- test_diff_deg(dds, type = \"control\", control = \"PBS\") #> Performing DESeq analysis... #> estimating size factors #> estimating dispersions #> gene-wise dispersion estimates #> mean-dispersion relationship #> final dispersion estimates #> fitting model and testing #> Formatting analysis result... #> extracted results: W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W10_vs_PBS #> Calulate a rlog & log2 transform assay, stored in rlg or ntd slot...  deg <- add_rejections(diff, alpha = 0.01, lfc = 1)"},{"path":"/articles/03_DEP2_analysis.html","id":"export-result-table","dir":"Articles","previous_headings":"","what":"Export result table","title":"DEP2 analysis workflow","text":"function get_results can used obtain result table significant subset differential test results. function get_df_wide can exctract full table DEP result. Function get_signicant can get results significant candidates.","code":"## Get result table DT::datatable(head(get_results(dep_pg)), options = list(scrollX = T,pageLength = 5)) ## Get the significant subset sig_deg = get_results(deg) class(sig_deg) #> [1] \"data.frame\" ## Get full data set with row information. DT::datatable(head(get_df_wide(dep_pg)), options = list(scrollX = T,pageLength = 5)) ## Get full data set of significant features get_signicant(dep_pg,return_type = \"table\") %>% dplyr::select(ends_with(\"significant\")) %>%    summary #>  W10_vs_PBS_significant W2_vs_PBS_significant W4_vs_PBS_significant #>  Mode :logical          Mode :logical         Mode :logical         #>  FALSE:152              FALSE:140             FALSE:178             #>  TRUE :97               TRUE :109             TRUE :71              #>  W6_vs_PBS_significant W9_vs_PBS_significant significant    #>  Mode :logical         Mode :logical         Mode:logical   #>  FALSE:114             FALSE:141             TRUE:249       #>  TRUE :135             TRUE :108"},{"path":"/articles/03_DEP2_analysis.html","id":"result-comparation","dir":"Articles","previous_headings":"","what":"Result comparation","title":"DEP2 analysis workflow","text":"identifying significant candidates add_rejections, plot_multi_venn plot_multi_heatmap can directly compare significant result multiple omics experiments via name identifiers. Use plot_multi_venn compare differences two pipelines, analysis results MQ proteingroups peptides re-aggregation pipeline.   Check expression interested proteins/genes accorss omics via plot_multi_heatmap. take proteins may related IL-1 signaling, signaling pathway reported upregulated silicosis mouse model original paper.","code":"## Test on the contrast W4_vs_PBS. diff_pg <- test_diff(imp_pg, type = \"manual\", test  = c(\"W4_vs_PBS\"), fdr.type = \"Storey's qvalue\") dep_pg <- diff_pg %>% add_rejections(alpha = 0.05,lfc = 2) diff_pep <- DEP2::test_diff(se_pep,type = \"control\", control = \"PBS\", fdr.type = \"Storey's qvalue\") dep_pep <- add_rejections(diff_pep,alpha = 0.05, lfc =2)  ## Filter out pg quantified which only have one peptides. dep_pep = filter_se(dep_pep,filter_formula = ~.n  > 2) dep_pg = filter_se(dep_pg,filter_formula = ~Razor...unique.peptides  > 2)  ## Plot Venn to explore the difference between two ways. plot_multi_venn(omics_list = list(PG= dep_pg, pep=dep_pep)) ## If set the proteins remained in both result as background.  ## dep_pep only contain two conditions of the study. PBS and W4. See the pe_peptides above. overlap_protein = intersect(rownames(dep_pep), rownames(dep_pg)) plot_multi_venn(omics_list = list(PG= dep_pg, pep=dep_pep), background = overlap_protein) ## Take the proteins may response to interleukin-1 as an example. IL1_relative_genes <-c(\"Irg1\", \"Il1rn\", \"Saa3\", \"Zbp1\", \"Ccl6\",                         \"Serpine1\", \"Ccl21a\", \"Pycard\", \"Irak2\", \"Vrk2\",                         \"Fn1\", \"Il1r1\", \"Irf1\", \"Ccl9\", \"Mapk11\", \"Tank\",                         \"Mapk13\")  ## Order the samples by time. dep_pg <- Order_cols(dep_pg, order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\"))  ## Plot the heatmap upon two DEP results. plot_multi_heatmap(omics_list = list(PG= dep_pg, pep=dep_pep),                    choose_name = IL1_relative_genes,                    width = 4)"},{"path":"/articles/03_DEP2_analysis.html","id":"post-analysis","dir":"Articles","previous_headings":"","what":"Post analysis","title":"DEP2 analysis workflow","text":"reduce barriers format conversion deferential test downstream analysis, post analysis suites differential testing results available DEP2. post-analysis functionalities may fully completed upon default installation DEP2. Users option complete functionalities executing “check_” series functions. alternative approach (one recommend), users can also choose proactively specify installation dependent packages installing DEP2. Besides, functional analyses (functional enrichment PPI) require species annotation database packages R environment. Therefore, relevant packages must installed conducting functional analysis organism. can run function check_organismDB_depends console check install missing packages. example code:","code":"## Check required packages for enrichment analysis DEP2::check_enrichment_depends()  ## Check required packages for PPI DEP2::check_PPI_depends() ## Install all depend packages at once by setting 'dependencies = TRUE' devtools::install_github(\"mildpiggy/DEP2\", dependencies = TRUE) ## Check organism annotation package of a species ## Parameter organism could one of \"Chicken\", \"Human\", \"Mouse\", \"Rat\", etc. DEP2::check_organismDB_depends(organism = \"Human\")"},{"path":"/articles/03_DEP2_analysis.html","id":"biological-function-enrichment","dir":"Articles","previous_headings":"Post analysis","what":"Biological function enrichment","title":"DEP2 analysis workflow","text":"Biological functional enrichment functions enrichR, clusterProfiler ReactomePA integrated test_ORA test_GSEA functions DEP2. functions enable enrichment analysis differential testing results obtained test_diff add_rejection functions. objective gene/protein list extracted transformed using organism annotation data. Subsequently, genes mapped biological knowledge annotated gene sets. mentioned , DEP2 used orginsm annotation package transform protein/gene IDs, therefore test_ORA can perform enrichment analysis upon Gene ontology, KEGG REACTOME data. test_GSEA designed GSEA. output test_ORA test_GSEA object source functions, seamlessly compatible plot functions manipulate function provided enrichR result. visualization methods enrichplot package can easily draw output two output.   cnet plotted interested biological processes enriched GSEA.  usages details available Yu’s introduction biomedical knowledge mining book.","code":"## 1. Extract gene list diff_pg <- test_diff(imp_pg, type = \"manual\", test  = c(\"W4_vs_PBS\"), fdr.type = \"Storey's qvalue\") dep_pg <- diff_pg %>% add_rejections(alpha = 0.01,lfc = 2)  ## 2. Check install check_enrichment_depends() # check required packages #> [1] TRUE check_organismDB_depends(\"Mouse\") # organism annotation for mouse #> [1] TRUE  ## Over representation analysis # On one contrast res_ora <- DEP2::test_ORA(dep_pg, contrasts = \"W4_vs_PBS\", species = \"Mouse\",type = \"GO\") #> 86 gene(s) transfrom to ENTREZID from SYMBOL. 2 gene(s) transfrom to ENTREZID from UNIPROT. 4 gene(s) transfrom to ENTREZID from ALIAS.  #> Star enrich GO terms by 92 ENTREZIDs.  class(res_ora)  #> [1] \"enrichResult\" #> attr(,\"package\") #> [1] \"DOSE\"  # On each contrasts res_ora2 <- DEP2::test_ORA(dep_pg, by_contrast = T, species = \"Mouse\",type = \"GO\") #> 86 gene(s) transfrom to ENTREZID from SYMBOL. 2 gene(s) transfrom to ENTREZID from UNIPROT. 4 gene(s) transfrom to ENTREZID from ALIAS.  #> Star enrich GO terms by 92 ENTREZIDs.  class(res_ora2) #> [1] \"enrichResult\" #> attr(,\"package\") #> [1] \"DOSE\"  ## Gene set enrichment analysis res_gsea <- DEP2::test_GSEA(dep_pg, by_contrast = F, species = \"Mouse\",type = \"GO\") #> 8301 gene(s) transfrom to ENTREZID from SYMBOL. 110 gene(s) transfrom to ENTREZID from UNIPROT. 510 gene(s) transfrom to ENTREZID from ALIAS.  #> 61 gene(s) do not match in database.  class(res_gsea) #> [1] \"gseaResult\" #> attr(,\"package\") #> [1] \"DOSE\" ## Dotplot function from DOSE package library(enrichplot) enrichplot::dotplot(res_ora) ## GSEA plot on one category enrichplot::gseaplot(res_gsea,geneSetID = \"GO:0071347\") ## Cnetplot res_gsea2 <- res_gsea %>%    filter(ID %in% c(\"GO:0071347\",\"GO:0035329\",\"GO:0032660\",\"GO:0090263\",\"GO:0035456\",\"GO:0038061\")) cnetplot(res_gsea2,foldChange = res_gsea@geneList,node_label = \"category\",showCategory = 6) #> Scale for size is already present. #> Adding another scale for size, which will replace the existing scale."},{"path":"/articles/03_DEP2_analysis.html","id":"expression-pattern-cluster","dir":"Articles","previous_headings":"Post analysis","what":"Expression pattern cluster","title":"DEP2 analysis workflow","text":"time-course omics studies experiments complex group design, identifying key candidates across entire experiment numerous contrasts can challenging. DEP2 provides get_tc_cluster function perform time-course cluster omics data multiple groups. function clusters features using “cmeans” algorithm, return list contains heatmap plot cluster result. omics experiement multiple experimental groups, get_tc_cluster can classify genes/proteins according expression patterns.   output get_tc_cluster contains heatmap combined expression line chart, well cluster result table stored ‘res’ slot. cluster table data.frame records closest cluster, membership values, expression values.","code":"## Perform cluster on signicant protein in all contrast tc_pg <- get_tc_cluster(get_signicant(dep_pg),                group_order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\") # Set group order               ) #> aabb[1] \"start timeclust\" #> beging 'cm' cluster by dist = 'euclidean' #> [1] \"finish heatmap\" ## The time course heatmap tc_pg$ht ## Expression cluster on phospholated sites tc_ptm <- get_tc_cluster(get_signicant(dep_ptm),                          group_order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\"), # Set group order                          row_font_size = 0,                          k = 8,                          heatmap_height = 2 ) #> aabb[1] \"start timeclust\" #> beging 'cm' cluster by dist = 'euclidean' #> `use_raster` is automatically set to TRUE for a matrix with more than #> 2000 rows. You can control `use_raster` argument by explicitly setting #> TRUE/FALSE to it. #>  #> Set `ht_opt$message = FALSE` to turn off this message. #> [1] \"finish heatmap\" tc_ptm$ht ## The clustering result table DT::datatable(head(tc_pg$res), options = list(scrollX = T,pageLength = 6))"},{"path":"/articles/03_DEP2_analysis.html","id":"protein-protein-interaction","dir":"Articles","previous_headings":"Post analysis","what":"Protein-protein interaction","title":"DEP2 analysis workflow","text":"DEP2 provides function test_PPI construct protein-protein interaction network based STRING data. test_PPI performs PPI analysis locally. Notably, test_PPI use local STRING data. function load_PPIdata checks existence local database. local data absent, load_PPIdata test_PPI try download PPI data species website save system.file(\"PPIdata\", \"species_name\",package = \"DEP2\").","code":"# 1. Check required packages for network construction. check_PPI_depends() #> [1] TRUE  # 2. Load STRING data.  ## If local STRING is missing, load_PPIdata will download to system.file(\"PPIdata\", \"Mouse\",package = \"DEP2\") load_PPIdata(speciesname = \"Mouse\")  #> Input species is Mouse   The species ID is 10090 #> fristDownload #> fristDownload #> fristDownload #> load succeed #> [1] \"Loading finished!\"  # 3.Load STRING data and perform PPI analysis.  ## It also automatically download data if loacl files is missing.  PPI_res <- test_PPI(   dep_pg,   contrasts = \"W4_vs_PBS\",   species = \"Mouse\",   STRING.version = \"11.5\",   score_cutoff = 400 ) #> 86 gene(s) transfrom to ENTREZID from SYMBOL. 2 gene(s) transfrom to ENTREZID from UNIPROT. 4 gene(s) transfrom to ENTREZID from ALIAS.  # igraph network PPI_ig <- PPInetwork(PPI_res,returntype = \"igraph\") igraph::plot.igraph(PPI_ig) ## visNetwork network PPInetwork(PPI_res,returntype = \"visNetwork\")"},{"path":"/articles/03_DEP2_analysis.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"DEP2 analysis workflow","text":"","code":"#> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 18.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1  #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1 #>  #> locale: #>  [1] LC_CTYPE=zh_CN.UTF-8       LC_NUMERIC=C               #>  [3] LC_TIME=zh_CN.UTF-8        LC_COLLATE=zh_CN.UTF-8     #>  [5] LC_MONETARY=zh_CN.UTF-8    LC_MESSAGES=zh_CN.UTF-8    #>  [7] LC_PAPER=zh_CN.UTF-8       LC_NAME=C                  #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C             #> [11] LC_MEASUREMENT=zh_CN.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: Asia/Shanghai #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] grid      stats4    stats     graphics  grDevices utils     datasets  #> [8] methods   base      #>  #> other attached packages: #>  [1] enrichplot_1.20.0           org.Mm.eg.db_3.17.0         #>  [3] AnnotationDbi_1.62.2        doRNG_1.8.6                 #>  [5] rngtools_1.5.2              foreach_1.5.2               #>  [7] randomForest_4.7-1.1        ggridges_0.5.4              #>  [9] patchwork_1.1.2             missForest_1.5              #> [11] ggplot2_3.4.2               dplyr_1.1.2                 #> [13] tibble_3.2.1                DEP2_0.3.7.3                #> [15] R6_2.5.1                    limma_3.56.2                #> [17] MSnbase_2.26.0              ProtGenerics_1.32.0         #> [19] mzR_2.34.1                  Rcpp_1.0.11                 #> [21] MsCoreUtils_1.12.0          SummarizedExperiment_1.30.2 #> [23] Biobase_2.60.0              GenomicRanges_1.52.0        #> [25] GenomeInfoDb_1.36.1         IRanges_2.34.1              #> [27] S4Vectors_0.38.1            BiocGenerics_0.46.0         #> [29] MatrixGenerics_1.12.2       matrixStats_1.0.0           #> [31] tidyr_1.3.0                 BiocStyle_2.28.0            #>  #> loaded via a namespace (and not attached): #>   [1] fs_1.6.2                    bitops_1.0-7                #>   [3] sf_1.0-14                   HDO.db_0.99.1               #>   [5] httr_1.4.6                  RColorBrewer_1.1-3          #>   [7] doParallel_1.0.17           tools_4.3.1                 #>   [9] utf8_1.2.3                  DT_0.28                     #>  [11] lazyeval_0.2.2              GetoptLong_1.0.5            #>  [13] withr_2.5.0                 graphite_1.46.0             #>  [15] gridExtra_2.3               preprocessCore_1.62.1       #>  [17] fdrtool_1.2.17              cli_3.6.1                   #>  [19] textshaping_0.3.6           scatterpie_0.2.1            #>  [21] sandwich_3.0-2              labeling_0.4.2              #>  [23] sass_0.4.6                  mvtnorm_1.2-2               #>  [25] proxy_0.4-27                askpass_1.1                 #>  [27] pkgdown_2.0.7               yulab.utils_0.0.6           #>  [29] Rsamtools_2.16.0            systemfonts_1.0.4           #>  [31] gson_0.1.0                  R.utils_2.12.2              #>  [33] DOSE_3.26.1                 itertools_0.1-3             #>  [35] rstudioapi_0.15.0           impute_1.74.1               #>  [37] RSQLite_2.3.1               visNetwork_2.1.2            #>  [39] gridGraphics_0.5-1          generics_0.1.3              #>  [41] ggVennDiagram_1.2.2         shape_1.4.6                 #>  [43] crosstalk_1.2.0             GO.db_3.17.0                #>  [45] Matrix_1.5-4.1              MALDIquant_1.22.1           #>  [47] fansi_1.0.4                 imputeLCMD_2.1              #>  [49] abind_1.4-5                 R.methodsS3_1.8.2           #>  [51] lifecycle_1.0.3             yaml_2.3.7                  #>  [53] edgeR_3.42.4                qvalue_2.32.0               #>  [55] Rtsne_0.16                  blob_1.2.4                  #>  [57] crayon_1.5.2                lattice_0.21-8              #>  [59] msigdbr_7.5.1               cowplot_1.1.1               #>  [61] KEGGREST_1.40.0             magick_2.7.4                #>  [63] pillar_1.9.0                knitr_1.43                  #>  [65] ComplexHeatmap_2.16.0       fgsea_1.26.0                #>  [67] rjson_0.2.21                codetools_0.2-19            #>  [69] fastmatch_1.1-3             glue_1.6.2                  #>  [71] ggfun_0.1.1                 downloader_0.4              #>  [73] pcaMethods_1.92.0           data.table_1.14.8           #>  [75] MultiAssayExperiment_1.26.0 treeio_1.24.1               #>  [77] vctrs_0.6.3                 png_0.1-8                   #>  [79] gtable_0.3.3                assertthat_0.2.1            #>  [81] cachem_1.0.8                xfun_0.39                   #>  [83] S4Arrays_1.0.4              tidygraph_1.2.3             #>  [85] RVenn_1.1.0                 survival_3.5-5              #>  [87] ncdf4_1.21                  iterators_1.0.14            #>  [89] gmm_1.8                     units_0.8-2                 #>  [91] ellipsis_0.3.2              nlme_3.1-162                #>  [93] ggtree_3.8.0                bit64_4.0.5                 #>  [95] rprojroot_2.0.3             bslib_0.5.0                 #>  [97] affyio_1.70.0               tmvtnorm_1.5                #>  [99] KernSmooth_2.23-21          colorspace_2.1-0            #> [101] DBI_1.1.3                   DESeq2_1.40.2               #> [103] tidyselect_1.2.0            bit_4.0.5                   #> [105] compiler_4.3.1              graph_1.78.0                #> [107] glmnet_4.1-7                desc_1.4.2                  #> [109] DelayedArray_0.26.6         shadowtext_0.1.2            #> [111] bookdown_0.34               scales_1.2.1                #> [113] classInt_0.4-9              affy_1.78.1                 #> [115] rappdirs_0.3.3              stringr_1.5.0               #> [117] digest_0.6.33               rmarkdown_2.23              #> [119] XVector_0.40.0              TCseq_1.23.0                #> [121] htmltools_0.5.5             pkgconfig_2.0.3             #> [123] umap_0.2.10.0               dbplyr_2.3.3                #> [125] highr_0.10                  fastmap_1.1.1               #> [127] rlang_1.1.1                 GlobalOptions_0.1.2         #> [129] htmlwidgets_1.6.2           farver_2.1.1                #> [131] jquerylib_0.1.4             zoo_1.8-12                  #> [133] jsonlite_1.8.7              BiocParallel_1.34.2         #> [135] mzID_1.38.0                 R.oo_1.25.0                 #> [137] GOSemSim_2.26.1             RCurl_1.98-1.12             #> [139] magrittr_2.0.3              ggplotify_0.1.1             #> [141] GenomeInfoDbData_1.2.10     munsell_0.5.0               #> [143] ggnewscale_0.4.9            babelgene_22.9              #> [145] ape_5.7-1                   viridis_0.6.3               #> [147] reticulate_1.30             vsn_3.68.0                  #> [149] stringi_1.7.12              ggraph_2.1.0                #> [151] zlibbioc_1.46.0             MASS_7.3-60                 #> [153] org.Hs.eg.db_3.17.0         plyr_1.8.8                  #> [155] parallel_4.3.1              ggrepel_0.9.3               #> [157] Biostrings_2.68.1           graphlayouts_1.0.0          #> [159] splines_4.3.1               circlize_0.4.15             #> [161] locfit_1.5-9.8              igraph_1.5.0                #> [163] QFeatures_1.10.0            clusterProfiler.dplyr_0.0.2 #> [165] reshape2_1.4.4              XML_3.99-0.14               #> [167] evaluate_0.21               BiocManager_1.30.21         #> [169] tweenr_2.0.2                openssl_2.0.6               #> [171] purrr_1.0.1                 polyclip_1.10-4             #> [173] clue_0.3-64                 norm_1.0-11.1               #> [175] ReactomePA_1.44.0           BiocBaseUtils_1.2.0         #> [177] ggforce_0.4.1               reactome.db_1.84.0          #> [179] AnnotationFilter_1.24.0     tidytree_0.4.2              #> [181] e1071_1.7-13                RSpectra_0.16-1             #> [183] viridisLite_0.4.2           class_7.3-22                #> [185] ragg_1.2.5                  aplot_0.1.10                #> [187] clusterProfiler_4.8.1       memoise_2.0.1               #> [189] GenomicAlignments_1.36.0    cluster_2.1.4"},{"path":[]},{"path":"/articles/04_app_demo.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"DEP2 Application Guide","text":"DEP2 features user-friendly shiny application designed researchers without programming experience. application provides easy-used GUI conducting various analysss DEP2. section, briefly introduce app operation. Example tables can found repository.","code":""},{"path":"/articles/04_app_demo.html","id":"run-app","dir":"Articles","previous_headings":"","what":"Run App","title":"DEP2 Application Guide","text":"application can launched executing single commond.","code":"DEP2::run_app()"},{"path":"/articles/04_app_demo.html","id":"add-module","dir":"Articles","previous_headings":"","what":"Add Module","title":"DEP2 Application Guide","text":"DEP2, shiny application follows modular design, different analysis functionalities organized separate modules. modules can imported click “Add module” button.   app currently comprises following modules: Omics modules Quantitative proteome (based proteingroup quantification) module performs differential analysis protein-level quantitative data, intensity, LFQ.intensity quantity tables. Quantitative proteome (based peptide quantification) module analyzes differentially expressed proteins aggregating protein quantities peptide-level quantitative data. Modification-specific proteome(modified peptide quantification) module analyzes differentially enriched modification-specific peptides using peptide quantity modification-specific enrichment. Transcriptome (RNA counts) module utilizes DEseq2 perform differential analysis parallel transcriptome data. Post analysis modules -representation analysis module performs biological functional enrichment using function test_ora. GSEA module utilizes function test_gsea biological functional enrichment. Protein-protein interaction module constructs Protein-Protein Interaction (PPI) network using local STRING database function test_ppi. local data available, app automatically attempt download relevant data online database. Timecourse cluster module applies soft cluster assays comprised multiple groups. Integrated analysis module allows comparison results omics experiments (note PTM data yet supported).","code":""},{"path":"/articles/04_app_demo.html","id":"omics-analysis-module","dir":"Articles","previous_headings":"","what":"Omics Analysis Module","title":"DEP2 Application Guide","text":"Upload table Three type upload table: Uploading expression table, experiment design generated expression column names. column names must follow format: (condition)_(repetition), example, control_1, treat_1. Uploading expression table experiment design table. experiment design table contain three columns, “label,” “condition” “replicate.” (example file expdesign.txt also can found example repository) Uploading saved log file previous analysis recovering analysis options. application accepts tables .txt (tab separated), .csv (comma separated) .gz (compressed table) format. log file .logrds format can used future reference.   Set columns options Specify correct read-options, including identifiers, expression values, filter columns.  options removing suffix removing prefix can affect assay row names, thus effect ‘label’ columns ExperimentalDesign. example, case, remove prefix, resulting following labels: Additionally, result files quantification software can also imported using similar rules, important select correct identifier expression columns. filter rule can left blank long features already gone quality control upstream software.  Set analysis options Select desired test mode.  options can adjusted option panels.  peptide-protein aggregation pipeline Besides, peptide-protein aggregation pipeline contains two main calculate steps: aggregation differential testing. steps performed sequentially within module.   Transcriptome analysis usage Transcriptome analysis module similar proteome modules, still differences, options ID transformation. illustrated example provided .   Result export Save table  Save log file. log file stores test options intermediate results, can used recover analysis future sessions. Please note although file types log files exported four omics analysis modules , different data formats. Therefore, can imported using corresponding analysis module (specific instructions, please refer previous section).","code":""},{"path":"/articles/04_app_demo.html","id":"post-analysis","dir":"Articles","previous_headings":"","what":"Post analysis","title":"DEP2 Application Guide","text":"important note post analysis functionalities completed DEP2 installed default. Users can complete functionalities executing “check_” series functions. alternative approach (one recommend), users can also choose proactively specify installation dependent packages installing DEP2. Besides, functional analyses (functional enrichment PPI) require species annotation database packages R environment. Therefore, relevant packages must installed conducting functional analysis organism. can run function check_organismDB_depends console check install missing packages, can extend selectable species options app. example code: Note: command executed console running app.","code":"## Check required packages for enrichment analysis DEP2::check_enrichment_depends() ## [1] TRUE ## Check required packages for PPI DEP2::check_PPI_depends() ## [1] TRUE ## Install all depend packages at once by setting 'dependencies = TRUE' devtools::install_github(\"mildpiggy/DEP2\", dependencies = TRUE) ## Check organism annotation package of a species ## Parameter organism could one of \"Chicken\", \"Human\", \"Mouse\", \"Rat\", etc. DEP2::check_organismDB_depends(organism = \"Human\")"},{"path":"/articles/04_app_demo.html","id":"annotation-enrichment-ora-or-gsea","dir":"Articles","previous_headings":"Post analysis","what":"Annotation Enrichment (ORA or GSEA)","title":"DEP2 Application Guide","text":"can perform post-functional analyses directly existing omics analysis datasets. However, essential note app considers identifiers symbols. Therefore, selecting gene symbol column ‘name’ column options prerequisite post-analysis.","code":""},{"path":"/articles/04_app_demo.html","id":"protein-protein-interaction-network","dir":"Articles","previous_headings":"Post analysis","what":"Protein-protein Interaction network","title":"DEP2 Application Guide","text":"enable PPI modules installing DEP2 first time, need run check_PPI_depends function console running app.","code":"DEP2::check_PPI_depends()"},{"path":"/articles/04_app_demo.html","id":"integrated-analysis","dir":"Articles","previous_headings":"Post analysis","what":"Integrated analysis","title":"DEP2 Application Guide","text":"Integrated analysis module can generate venn plot heatmap multiple omics results. , showcase usage module parallel proteome transcriptome study silicosis mouse.  Note: order compare results different omics analyses, necessary standardize identifier types features. proteome modules, depends gene name option, transcriptome module, non-gene name identifiers transformed symbols using annotation database.","code":""},{"path":"/articles/04_app_demo.html","id":"reshape-table","dir":"Articles","previous_headings":"","what":"Reshape table","title":"DEP2 Application Guide","text":"proteome analysis modules accept wide quantitative table, row represents features (protein proteingroup), rows contain identification information quantification information samples. However, long-format tables also widely used many cases, quantity value represented separate row. Therefore, DEP2 offers reshape_long2wide function, APP also offers Reshape module converting long table wide-format. , demonstrate analyze DIA-NN result file, report.tsv, long-format.  import long-format tables, similar settings can referred process. module can also reshape data peptide level. details, refer documentation reshape_long2wide function Data import vignette.","code":""},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"A benchmark on spike-in data","text":", compare analysis result DEP2 Perseus using benchmark dataset. dataset contains two concentration groups Yeast E. coli proteome spiked human background. example tables available repository. ratios proteomes species follows:","code":"# Download OmicsExample and uncompress firstly # Change the path to Omics Example example_path = \"the/path/to/OmicsExample\" knitr::opts_knit$set(    root.dir = example_path  ) knitr::opts_chunk$set(    collapse = TRUE,    comment = \"#>\",    message = FALSE,    warning = FALSE )  library(DEP2) library(magrittr) library(dplyr) library(ggVennDiagram) library(patchwork) library(ggplot2)"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"analysis-workflows","dir":"Articles","previous_headings":"","what":"Analysis workflows","title":"A benchmark on spike-in data","text":"measured spike-data using Data-independent acquisition (DIA) Data-dependent acquisition (DDA) individually. DDA raw data searched quantified MaxQuant, DIA data searched Spectronaut library-free method. study, main focus comparing performance DEP2 workflows Perseus DDA results obtained MaxQuant. Additionally, also included DEP2 DIA pipeline comparison. ensure data credibility, considered proteingroups identified one fragment (peptide). details analysis pipeline can found following table code blocks:","code":""},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"dda-protein-dep2-workflow-","dir":"Articles","previous_headings":"Analysis workflows","what":"DDA-Protein-DEP2 workflow.","title":"A benchmark on spike-in data","text":"workflow represents classical pipeline DEP2 modified DEP package, specifically designed proteingroups results.","code":"mq_pgfile <- \"./A_spikeIn/MaxQuant_output/proteinGroups.txt.gz\" pg <- read.csv(mq_pgfile,sep = \"\\t\")  ## Generate unique names and ids unique_pg <- make_unique(pg,                           name = \"Gene.names\", #gene                           ids = \"Protein.IDs\"   #protein                          )  ## Convert se with expdesign table ecols <- grep(\"LFQ.intensity.\", colnames(unique_pg)) se <- make_se_parse(unique_pg, columns = ecols, mode = \"delim\")  ## Filter & normalize & Impute filt <- filter_se(se,thr = 0, fraction = 0.5,                    filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" & Peptides > 1) norm <- normalize_vsn(filt) set.seed(10000) imp <- DEP2::impute(norm,fun = \"RF\")  ## Differential test diff <- test_diff(imp,type = \"control\", control = \"A1\", fdr.type = \"BH\") dep <- add_rejections(diff, alpha = 0.05, lfc = 1)"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"dda-peptide-dep2-workflow-","dir":"Articles","previous_headings":"Analysis workflows","what":"DDA-Peptide-DEP2 workflow.","title":"A benchmark on spike-in data","text":"pipeline bypass MaxLFQ summarization instead performs re-aggregation protein intensity based peptide quantities.","code":"mq_pepfile <- \"./A_spikeIn/MaxQuant_output/peptides.txt.gz\" mq_pep <- read.csv(mq_pepfile,sep = \"\\t\")  ## Construct SummarizedExperiement ecols <- grep(\"Intensity.\", colnames(mq_pep), value = TRUE) pe = make_pe_parse(mq_pep, columns = ecols,   # columns is the 'Intensity' colunmns                    mode = \"delim\", sep = \"_\", remove_prefix = TRUE)  ##  Filter & Impute & Normalize pe = filter_pe(pe, thr = 0, fraction = 0.6,                 filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) pe <- normalize_pe(pe,method = \"vsn\", i = \"peptideRaw\") set.seed(10000) pe <- impute_pe(pe, fun = \"bpca\", name = \"peptideImp\", i = \"peptideNorm\")  ## Aggregation pe <- aggregate_pe(pe, aggrefun = \"RobustSummary\", fcol = \"Proteins\", reserve = \"Gene.names\", i = \"peptideImp\") se_pep <- pe2se(pe, names = \"Gene.names\", ids = \"smallestProteingroups\") filt_pep <- filter_se(se_pep,filter_formula = ~.n > 1)  norm_pep <- normalize_vsn(filt_pep)   ## Differential test diff_pep <- test_diff(norm_pep,type = \"control\", control = \"A1\", fdr.type = \"BH\") dep_pep <- add_rejections(diff_pep, alpha = 0.01)"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"dda-protein-perseus","dir":"Articles","previous_headings":"Analysis workflows","what":"DDA-Protein-Perseus","title":"A benchmark on spike-in data","text":"Process Perseus analysis output subsequent comparison.","code":"## The differetial test result of Perseus Perseus_resfile <- \"./A_spikeIn/MaxQuant_output/Perseus_test_res.txt.gz\" con <- file(Perseus_resfile, \"r\") Perseus_resfile = readLines(con) close(con)  ## Remove the lines recording variable types. Perseus_resfile = Perseus_resfile[-(2:3)]  ## Read data Perseus_res <- read.csv(text = Perseus_resfile,sep = \"\\t\")  ## Clean data Perseus_res$p.value = 10^-(Perseus_res$X.Log.Student.s.T.test.p.value.B1_A1) Perseus_res$q.value = Perseus_res$Student.s.T.test.q.value.B1_A1 Perseus_res$L2FC = Perseus_res$Student.s.T.test.Difference.B1_A1 Perseus_res$t.statistic = Perseus_res$Student.s.T.test.Test.statistic.B1_A1 Perseus_res <- make_unique(Perseus_res, \"Gene.names\", \"Protein.IDs\", delim = \";\") Perseus_res <- dplyr::filter(Perseus_res,Peptides > 1)  ## Convert a SE object for subsequent comparison ecols <- 1:6 Perseus_res2 = Perseus_res Perseus_res2[ecols] <- 2^Perseus_res2[ecols] dep_Perseus = make_se_parse(Perseus_res2,columns = 1:6,mode = \"delim\")"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"dia-protein-dep2","dir":"Articles","previous_headings":"Analysis workflows","what":"DIA-Protein-DEP2","title":"A benchmark on spike-in data","text":"workflow similar first one, applied DIA data Spectonaut instead DDA results.","code":"Spe_repfile <- \"./A_spikeIn/Spectronaut_output/DIA4_MSStates_Report_new_noimpu.xls\" Spe_rep <- read.csv(Spe_repfile,sep = \"\\t\")   ## Reshape long table  Spe_rep_wided <- reshape_long2wide(Spe_rep,                                   sample_col = \"R.FileName\",      # the column labeling sample names                                   feature_col = \"PG.ProteinGroups\", # PG IDs                                   expression_col = \"PG.Quantity\",   # PG quantity.                                   shrink_ident_cols  = c(\"PG.Genes\",\"PG.Qvalue\",\"PG.RunEvidenceCount\"),  # Gene names                                   remove_sample_prefix = TRUE,    # remove prefix in sample_col                                   remove_sample_suffix = FALSE                                     )  ## Unique names unique_spe_pg <- make_unique(Spe_rep_wided,                               name = \"PG.Genes\",  #gene                               ids = \"PG.ProteinGroups\"   #protein                              )  ## Convert SE with expdesign table ecols <- 2:7 # Expression col in the Spectronaut output se_dia <- make_se_parse(unique_spe_pg,                      columns = ecols,                      mode = \"delim\",                     remove_prefix = TRUE,   ## remove the file prefix                      remove_suffix = FALSE   ## no suffix in this case                     )  ## Filter. Keep the protein which have at least two Evidence in one sample Keep_proteins <- Spe_rep_wided$PG.RunEvidenceCount %>%    sapply(function(x){     max(strsplit(x,split = \";\")[[1]]) >1   })  filt_dia <- se_dia[Keep_proteins,]  ## Normalize & impute norm_dia <- normalize_vsn(filt_dia) imp_dia <- DEP2::impute(filt_dia, \"bpca\")  ## Differential test diff_dia <- test_diff(imp_dia, type = \"control\", control = \"A5\", fdr.type = \"Storey's qvalue\") dep_dia <- add_rejections(diff_dia, alpha = 0.05, lfc = 1)"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"result-comparation","dir":"Articles","previous_headings":"","what":"Result Comparation","title":"A benchmark on spike-in data","text":"Missing values(MVs) ubiquitous label-free proteomics data, particularly DDA methods. comparison DDA method, DIA identity proteins also contains fewer MVs.   Missing values can decrease power statistical tests, potentially leading false positives. mitigate issue, DEP2 filter low-quanlity features many missing values function filter_pe/filter_se. Perseus Protein-DEP2 pipelines consider equal number proteins due employing filter cutoff. Peptide-Aggregation workflow also retains closed number features. expected, DIA outperforms DDA terms data coverage retains highest number features.","code":"(plot_coverage(se) + ggplot2::labs(title = \"DDA\")) + (plot_coverage(se_dia)  + ggplot2::labs(title = \"DIA\")) +   (plot_coverage(filt) + ggplot2::labs(title = \"DDA-filtered\")) + (plot_coverage(filt_dia)  + ggplot2::labs(title = \"DIA-filtered\")) features_pg = rowData(dep)$ID features_pep = rowData(dep_pep)$ID features_perseus = Perseus_res$ID features_dia = rowData(dep_dia)$ID  ggVennDiagram(list(\"DDA-Protein-DEP2\" = features_pg,                    \"DDA-Protein-Perseus\" = features_perseus,                    \"DDA-Peptide-DEP2\" = features_pep,                    \"DIA-Protein-DEP2\" = features_dia                    ),               set_size = 2.5,               label_size = 3)"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"imputation-accuracy","dir":"Articles","previous_headings":"Result Comparation","what":"Imputation accuracy","title":"A benchmark on spike-in data","text":"proteomics experiments, random systematic errors, well missing values, significant impact accuracy protein quantification. Therefore, crucial efficient data processing pipeline minimizes effects systematic errors missing values results.Despite filtering features excessive missing values, range missing values still remains assay. remaining missing values, DEP2 offers variety imputation strategies (DEP2::impute). contrast, Perseus software offers one method imputation. Additionally, Perseus can also call impute functions imputeLCMD package. However, process counter-intuitive requires R executable program system. spike-sample experiment, protein concentrations three species precisely controlled. E. coli proteome exhibit fold change (group B vs ) 3, YEAST proteome fold change 1/2, human background remains unchanged. comparing actual differences theoretical fold change, can evaluate ability four pipelines restore missing values minimize errors. Among four pipelines, DDA-Protein-DEP2 achieves highest accuracy fold change, global fold changes closely aligning theoretical line. Furthermore, fold changes species consistent, resulting reduced number outliers compared Perseus pipeline. highlights effectiveness MissForest imputation method. contrast, Perseus yields fold changes markedly lower theoretical line. results Peptide-aggregation pipeline similar DDA-Protein-DEP2. DIA-Protein-DEP2 exhibits slightly amplified fold changes also smaller interquartile ranges.  focus intersections results four methods, conclusions consistent. DEP2 demonstrates greater accuracy eliminating quantitative errors, evidenced lower overall fold change error compared Perseus.  four pipelines, fold changes low-abundance proteins exhibit greater variability relative inaccuracy. result anticipated since low-abundance proteins susceptible impact random errors missing values. Perseus imputation exhibits lower stability compared MissForest (imputation method used DDA-Protein-DEP2). DIA data contains several low-expressed proteins (13), challenging quantify accurately. peptide-aggregation method show deviation global fold change, FCs low- medium-abundance proteins comparatively unstable Protein-DEP2 method. attributed presence low-intensity peptides low- medium-abundance proteins, possess higher aggregation weights MaxLFQ data processing. optimization aggregation method required reduce effect.  coefficients variations (CVs) reflect consistency replicates directly affect result statistical tests. DIA data higher inter-replicate stability compared DDA data. Furthermore, utilization MissForest imputation DDA-Protein-DEP2 results lower CVs compared three pipelines, providing additional evidence effectiveness mitigating adverse effects missing values.","code":"protein_info = read.csv(\"./A_spikeIn/protein_info.csv\") protein_info2 = protein_info %>% dplyr::select(ID,spe,ox)  PG_df <- get_df_wide(dep) %>% as.data.frame %>%     mutate( meanQuant = rowMeans(dplyr::select(., matches(\"^(A1|B1)_(1|2|3)$\"))) ) %>%    dplyr::select(name, ID, L2FC = B1_vs_A1_diff, pval = B1_vs_A1_p.val, qval = B1_vs_A1_p.adj, t.statistic = B1_vs_A1_t.stastic, meanQuant) %>%    left_join(protein_info2) %>%    cbind(assay(dep))  PEP_df <- get_df_wide(dep_pep) %>% as.data.frame %>%     mutate( meanQuant = rowMeans(dplyr::select(., matches(\"^(A1|B1)_(1|2|3)$\"))) ) %>%    dplyr::select(name, ID,                  L2FC = B1_vs_A1_diff, pval = B1_vs_A1_p.val, qval = B1_vs_A1_p.adj, t.statistic = B1_vs_A1_t.stastic, meanQuant) %>%    left_join(protein_info2) %>%    cbind(assay(dep_pep))  perseus_df <- Perseus_res %>%     mutate( meanQuant = rowMeans(dplyr::select(., matches(\"^(LFQ.).*_(1|2|3)$\"))) ) %>%    dplyr::select(name, ID, L2FC, pval = p.value, qval = q.value, t.statistic, meanQuant) %>%   left_join(protein_info2) %>%    cbind(dplyr::select(Perseus_res,starts_with(\"LFQ.\")) )  DIA_df <- get_df_wide(dep_dia) %>% as.data.frame  %>%    mutate( meanQuant = rowMeans(dplyr::select(., matches(\"^(A5|B5)_(1|2|3)$\"))) ) %>%    dplyr::select(name, ID, L2FC = B5_vs_A5_diff, pval = B5_vs_A5_p.val, qval = B5_vs_A5_p.adj, t.statistic = B5_vs_A5_t.stastic, meanQuant) %>%    left_join(protein_info2) %>%    cbind(assay(dep_dia))   df_list <- list(\"DDA-Protein-DEP2\" = PG_df,                  \"DDA-Peptide-DEP2\" = PEP_df,                  \"DDA-Protein-Perseus\" = perseus_df,                  \"DIA-DEP2\" = DIA_df)  cols = c(\"ID\", \"spe\", \"L2FC\", \"meanQuant\",\"pval\", \"qval\") res_table = df_list %>%    lapply(., function(x){     dplyr::select(x,!!!syms(cols)) %>% distinct(., ID, .keep_all = T)   }) %>%    Map(function(x, method){     x$method <- method     x   },., names(.)) %>%    do.call(rbind, .)   intersect_id = df_list %>% lapply(function(x) x$ID) %>% Reduce(intersect, .)   ## Plot L2FC boxplot. Dash line is the actual fold change p_lfc <- ggplot(res_table, aes( y= L2FC, x = spe, fill = method)) +   geom_boxplot(     color = \"black\", size = 0.5,      outlier.color = \"black\", outlier.alpha = 0.3, outlier.size = 0.5, outlier.shape = \".\"     ) +   ylab(\"Log2 fold change\") +   geom_segment(y= log2(3),yend= log2(3), x = 0.5, xend= 1.5,                 color = \"darkred\", linetype = \"dashed\", lwd = 0.8, alpha = 0.6) +   geom_segment(y= -log2(2),yend= -log2(2), x = 2.5, xend= 3.5,                 color = \"darkred\", linetype = \"dashed\", lwd = 0.8, alpha = 0.6) +   geom_segment(y= 0,yend= 0, x = 1.5,xend= 2.5,                 color = \"darkred\", linetype = \"dashed\", lwd = 0.8, alpha = 0.6) +   scale_y_continuous(limits = c(-3, 4)) +    theme(panel.grid = element_blank(),         panel.border = element_blank(),         axis.line = element_line(size = 0.4),         axis.ticks = element_blank(),         # axis.ticks.length = unit(0, \"pt\"),         panel.background = element_rect(fill = \"white\"),         legend.background = element_rect(fill = \"white\")         ) p_lfc res_table2 = dplyr::filter(res_table, ID %in% intersect_id) res_table2$L2FC = ifelse(res_table2$spe == \"HUMAN\",                            res_table2$L2FC ,                           ifelse(res_table2$spe == \"YEAST\",                                   res_table2$L2FC + log2(2),                                   res_table2$L2FC - log2(3)))  p_lfcerr <- ggplot(res_table2, aes( y= L2FC, x = method, fill = spe)) +   geom_boxplot(     color = \"black\", size = 0.5,      outlier.color = \"black\", outlier.alpha = 0.3, outlier.size = 0.5, outlier.shape = \".\"     ) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey\") +   scale_fill_manual(values = c(HUMAN = \"#41b349\", YEAST = \"#2775b6\", ECOLI = \"#a6522c\")) +    scale_y_continuous(name = \"Fold change error(log2)\", limits = c(-1.5, 1.5)) +    theme(panel.grid = element_blank(),         panel.border = element_blank(),         axis.line = element_line(size = 0.4),         axis.ticks = element_blank(),         # axis.ticks.length = unit(0, \"pt\"),         panel.background = element_rect(fill = \"white\"),         legend.background = element_rect(fill = \"white\")         ) p_lfcerr res_table3 = dplyr::filter(res_table, ID %in% intersect_id) res_table3$L2FC[res_table3$L2FC < -3.5] = -3.5 res_table3$L2FC[res_table3$L2FC > 3.5] = 3.5  p_lfctrend <- ggplot(res_table3, aes(x = meanQuant, y = L2FC, color = spe)) +    geom_point(shape = 20, alpha = 0.2, size = 0.8) +   geom_line(stat=\"smooth\",method = \"loess\", formula = y ~x, span=0.3, size = 0.7, alpha = 0.5) +   scale_color_manual(values = c(HUMAN = \"#41b349\", YEAST = \"#2775b6\", ECOLI = \"#a6522c\")) +   scale_y_continuous(limits = c(-3.5,3.5), name = \"Log2 fold change\") +   xlab(\"Mean abundance\") +   facet_wrap(~method,scales = 'free') +   theme_bw() +   theme(strip.background = element_rect(fill = \"white\", colour = NA)) p_lfctrend dep_list = list(DDA_Protein_DEP2 = dep,                 DDA_Peptide_DEP2 = dep_pep,                 DDA_Protein_Perseus = dep_Perseus,                 DIA_DPE2 = dep_dia)  CV_df = dep_list %>%    lapply(function(x){     assa = 2^assay(x) %>% as.data.frame()     cd = colData(x)          coef_variation <- function(x) {       coef = sd(x)/mean(x)     }          CVs = assa %>% tibble::rownames_to_column() %>%        cbind(., id = rowData(x)$ID) %>%       tidyr::gather(\"label\", \"Intensity\", -c(rowname,id)) %>%       dplyr::left_join(., data.frame(cd), by = \"label\") %>%       dplyr::group_by(id, condition) %>% dplyr::summarise(cvs = coef_variation(Intensity)) %>%       dplyr::group_by(condition) %>% dplyr::mutate(condition_median = median(cvs)) %>%       dplyr::ungroup()        }) %>%   Map(function(x, method){     x$method <- method     x   },., names(.))  %>%   do.call(rbind,.)  CV_df2 = dplyr::filter(CV_df, id %in% intersect_id) %>%    arrange(id) %>%   mutate(condition = gsub(\"[0-9]\",\"\",condition))   P_A <- wilcox.test(   dplyr::filter(CV_df2, method == \"DDA_Protein_DEP2\", condition == \"A\") %>% .$cvs,    dplyr::filter(CV_df2, method == \"DDA_Protein_Perseus\", condition == \"A\") %>% .$cvs,   paired = T)  P_B <- wilcox.test(   dplyr::filter(CV_df2, method == \"DDA_Protein_DEP2\", condition == \"B\") %>% .$cvs,    dplyr::filter(CV_df2, method == \"DDA_Protein_Perseus\", condition == \"B\") %>% .$cvs,   paired = T)  library(ggsignif) p_cvs <- ggplot(CV_df2, aes(x = condition, y = cvs, fill = method)) +     geom_boxplot(color = \"black\",                   outlier.size = 0.2,outlier.alpha = 0.2, position = \"dodge2\") +     geom_signif(annotation = ifelse(P_A$p.value < 0.001, \"p<0.001\", P_A$p.value),                 y_position = 1.6, xmin = 0.91, xmax = 1.09,                  tip_length = c(0.3, 0.03)     ) +     geom_signif(annotation = ifelse(P_B$p.value < 0.001, \"p<0.001\", P_B$p.value),                 y_position = 1.65, xmin = 1.91, xmax = 2.09,                  tip_length = c(0.45, 0.02)     ) +     theme(panel.grid = element_blank(),           panel.border = element_blank(),           axis.line = element_line(linewidth = 0.4),           axis.ticks = element_blank(),           # axis.ticks.length = unit(0, \"pt\"),           panel.background = element_rect(fill = \"white\"),           legend.background = element_rect(fill = \"white\")     )  p_cvs"},{"path":[]},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"receiver-operator-characteristic-curve","dir":"Articles","previous_headings":"Result Comparation > Statistical test","what":"Receiver operator characteristic curve","title":"A benchmark on spike-in data","text":"Receiver operator characteristic (ROC) curve can assess statistical power pipeline. DIA data exhibits great advantage compare DDA data. Perseus result higher AUC (area curve) DEP2 pipelines.  four pipelines high AUCs close 1, indicating ability efficiently distinguish regulated proteins unchanged background. DDA-Protein-DEP2 0.984, DDA-Peptide-DEP2 0.988, DDA-Protein-Perseus 0.99, DIA-DEP2 0.998.","code":"library(pROC) cols = c(\"ID\", \"spe\", \"L2FC\", \"pval\", \"qval\", \"t.statistic\") df_list %>%    lapply(function(x){     dplyr::select(x,!!!syms(cols)) %>%        distinct(., ID, .keep_all = T) %>%        dplyr::filter(ID %in% intersect_id)   }) %>% lapply(function(x){     pROC::roc(ifelse(x$spe == \"HUMAN\", F, T), abs(x$qval))   }) -> roc_res  roc_res %>% lapply(function(x){   df <- data.frame(specificities = x$specificities, sensitivities = x$sensitivities, qval = x$thresholds) }) %>%   Map(function(x, method){     x$method <- method     x   },., names(.)) %>%    do.call(rbind,.) -> roc_df  roc_res %>% sapply(function(x){   as.numeric(x$auc) }) -> aucs  aucs <- paste(names(aucs),round(aucs,3),sep = \"  \", collapse = \", \")  ggplot(roc_df) +   geom_line( aes(x=1 - specificities, y=sensitivities, color=method)) +    coord_equal() +   xlab(\"\") + ylab(\"\") +   scale_x_continuous(limits = c(0, 0.2), n.breaks = 3, labels = function(x) sprintf(\"%.2f\", x)) +   scale_y_continuous(limits = c(0.8, 1), n.breaks = 3, labels = function(x) sprintf(\"%.2f\", x)) +   theme_bw() +   theme(panel.grid = element_blank(),         legend.position = \"none\") -> p_zoom  ggplot(roc_df) +   geom_line( aes(x=1 - specificities, y=sensitivities, color=method)) +    xlim(c(0, 1)) + ylim(c(0, 1)) +   coord_equal() +   xlab(\"1 - Specificity\") + ylab(\"Sensitivity\") +   ggtitle(\"ROC Curves for Colon Cancer Markers\") +   annotate(\"rect\", xmin = 0, xmax = 0.2, ymin = 0.8, ymax = 1, fill = \"transparent\", color = \"grey\",alpha = 0.2) +   annotation_custom(ggplotGrob(p_zoom), xmin = 0.25, xmax = 0.9, ymin = -0.2, ymax = 0.9) +   theme_bw() +   theme(panel.grid = element_blank()) ggplot(roc_df) +   geom_point( aes(x=qval, y=1-specificities, color=method), size = 0.5) +   xlim(c(0, 0.05)) + ylim(c(0, 0.05)) +   geom_abline(intercept = 0, linetype = \"dashed\") +   coord_equal() +   theme_bw() +   theme(panel.grid = element_blank())"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"intersect-cutoff","dir":"Articles","previous_headings":"Result Comparation > Statistical test","what":"Intersect cutoff","title":"A benchmark on spike-in data","text":"practice, p-value sufficient condition determining significance. Researchers often take fold change p-value consideration, extract candidate lists based criteria. Intersection thresholds, thresholds simultaneously satisfy p-value fold change, commonly used cutoffs identifying significant candidates. compare significant proteins obtained four methods applying intersect cutoff. method also one threshold methods used add_rejections. case, set threshold L2FC>1.2 p<0.01 upregulated E. coli proteins, downregulated yeast proteins, choose threshold L2FC<-0.6 p<0.05, considering smaller inter-group difference. DIA pipeline demonstrates superior performance, obtaining highest number true positive results well controlling false positive rate. Among DDA pipelines, Protein-DEP2 effectively controls false positives, Perseus detects downregulated yeast proteins also includes false positives. DDA-Peptide-DEP2 pipeline performs previous two pipelines.","code":"res_table$trend = apply(res_table, 1,        function(x){         if( as.numeric(x[\"qval\"]) > 0.05)           return(\"Not sig\")         if( as.numeric(x[\"qval\"]) <= 0.001 & as.numeric(x[\"L2FC\"]) > 1.2)           return(\"Up\")         if( as.numeric(x[\"qval\"]) <= 0.05 & as.numeric(x[\"L2FC\"]) < -0.6)           return(\"Down\")                  return(\"Not sig\")       },simplify = F) %>% unlist  res_table$trend = factor(res_table$trend,c(\"Not sig\",\"Up\",\"Down\")) res_table$spe = factor(res_table$spe,c(\"ECOLI\", \"YEAST\", \"HUMAN\"))  ggplot(res_table) + geom_bar(aes(x = trend, fill = spe,y=1),stat=\"identity\") +   scale_fill_manual(values = c(HUMAN = \"#41b349\", YEAST = \"#2775b6\", ECOLI = \"#a6522c\")) +   facet_grid(~method,scales = 'free') +    ylab(\"Proteingroups\") +    xlab(\"Significant\") +    theme(panel.grid = element_blank(),         panel.border = element_blank(),         axis.line = element_line(size = 0.4),         axis.ticks = element_blank(),         panel.background = element_rect(fill = \"white\"),         legend.background = element_rect(fill = \"white\"),         strip.background = element_rect(fill = \"white\", colour = NA)   ) ggplot(res_table) + geom_bar(aes(x = trend, fill = spe,y=1), stat=\"identity\", position = \"fill\" ) +   scale_y_continuous(labels = scales::percent) +   scale_fill_manual(values = c(HUMAN = \"#41b349\", YEAST = \"#2775b6\", ECOLI = \"#a6522c\")) +   facet_grid(~method,scales = 'free') +    ylab(\"Proteingroups\") +    xlab(\"Significant\") +    theme(panel.grid = element_blank(),         panel.border = element_blank(),         axis.line = element_line(size = 0.4),         axis.ticks = element_blank(),         # axis.ticks.length = unit(0, \"pt\"),         panel.background = element_rect(fill = \"white\"),         legend.background = element_rect(fill = \"white\"),         strip.background = element_rect(fill = \"white\", colour = NA)   )"},{"path":"/articles/05_Benchmark_on_spike_in_data.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"A benchmark on spike-in data","text":"compare DEP2 pipelines Perseus analyses using benchmark dataset. dataset, DEP2’s new imputation algorithm can appropriately estimate missing values, outperforming left-shift methods Perseus. statistical testing part, DIA-DEP2 pipeline demonstrates best performance, highlighting necessity availability DEP2 compatibility various data. Perseus performs better DDA-DEP2 pipelines terms sensitivity lower specificity. However, ’s noteworthy set S0 parameter Perseus 0.5, incorporates FC consideration FDR control. S0 remains default value 0, Perseus employs conventional t-test yield noticeably worse q values. newly introduced peptide-aggregation method performs similarly traditional proteingroups based method, obvious FC shrink outliers among low-abundance proteins, indicating still space improvement. analysis based benchmark data demonstrates feasibility DEP2 protein data analysis workflow. However, actual research, characteristics proteomic data may differ. example, scale specific extent changes regulatory proteins AP-MS can vary significantly. DEP2 offers flexible imputation functions incorporates multiple FDR correction methods. choice methods depend experimental design, objectives, specific data characteristics.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Zhenhuan Feng. Maintainer, author. Xiaofei Zhang. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Feng Z, Zhang X (2023). DEP2: analysis toolkits mass spectrometry based proteomics data.. R package version 0.3.7.3.","code":"@Manual{,   title = {DEP2: An analysis toolkits for mass spectrometry based proteomics data.},   author = {Zhenhuan Feng and Xiaofei Zhang},   year = {2023},   note = {R package version 0.3.7.3}, }"},{"path":"/index.html","id":"dep2","dir":"","previous_headings":"","what":"An analysis toolkits for mass spectrometry based proteomics data.","title":"An analysis toolkits for mass spectrometry based proteomics data.","text":"DEP2 comprehensive analysis toolkit developed previous package DEP mass spectrometry based proteomics data. offers differential expression/enrichment analysis pipelines various types data, protein-level quantity (e.g. proteingroup), peptide-level quantity data, modification-specific proteomics (quantities modified peptides). DEP2 encompasses functions data processing, hypothesis testing (via limma), visualization also incorporates pipeline aggregating peptides proteins. reduce barrier omics analysis, downstream functional explorations packaged suites, including functional enrichment, timecourse cluster protein-protein interaction network. DEP2 also contains easy--use shiny application designed modularization.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An analysis toolkits for mass spectrometry based proteomics data.","text":"can install DEP2 GitHub using following command: Please note DEP2 requires R version higher 4.1.0. recommend installing latest R version scratch avoid compatibility issues dependent packages. Additionally, Apple Mac, please make sure Fortran compiler installed necessary dependencies.","code":"# install.packages(\"devtools\") devtools::install_github(\"mildpiggy/DEP2\")"},{"path":"/index.html","id":"check-the-suggested-packages-required-in-analysis","dir":"","previous_headings":"","what":"Check the suggested packages required in analysis","title":"An analysis toolkits for mass spectrometry based proteomics data.","text":"default, DEP2 installed essential dependent packages. However, certain analysis modules may require additional suggested packages. Users can run following commands complete functionality DEP2: Alternatively, can install DEP2 suggested packages using following command:","code":"library(DEP2)  # Check and install required packages for enrichment analysis. DEP2::check_enrichment_depends(install = TRUE)  # Check and install the appropriate Anotation OrgDb for Human. DEP2::check_organismDB_depends(organism = \"Human\",install = TRUE) # The 'organism' parameter can also be specified with other species names, like Mouse, Rat.   # Check and install required packages for PPI analysis. DEP2::check_PPI_depends(install = TRUE)  # Check and install required packages for RNA-seq analysis. DEP2::check_RNAseq_depends(install = TRUE) devtools::install_github(\"mildpiggy/DEP2\", dependencies = TRUE)"},{"path":"/index.html","id":"run-shiny-application","dir":"","previous_headings":"","what":"Run shiny application","title":"An analysis toolkits for mass spectrometry based proteomics data.","text":"run built-shiny application, use run_app function:","code":"library(DEP2) DEP2::run_app()"},{"path":"/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"An analysis toolkits for mass spectrometry based proteomics data.","text":"information details functionalities DEP2, can visit online website refer built-vignette installation.","code":""},{"path":"/reference/DEGdata-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Class \"DEGdata\" class store test result DESeq2","code":""},{"path":"/reference/DEGdata-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":"geneinfo data.frame. Store gene IDs SYMBOL information. ntf matrix. Log2 transform assay rlg matrix. rlog transform assay test_result DataFrame. Test result DESeq2","code":""},{"path":"/reference/DEP2_add_rejections.html","id":null,"dir":"Reference","previous_headings":"","what":"Mark significant proteins — add_rejections","title":"Mark significant proteins — add_rejections","text":"add_rejections marks significant proteins based defined cutoffs.","code":""},{"path":"/reference/DEP2_add_rejections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mark significant proteins — add_rejections","text":"","code":"# S4 method for SummarizedExperiment add_rejections(diff, alpha, lfc, thresholdmethod, curvature, x0_fold)  # S4 method for DEGdata add_rejections(diff, alpha, lfc, thresholdmethod, curvature, x0_fold)"},{"path":"/reference/DEP2_add_rejections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mark significant proteins — add_rejections","text":"alpha Numeric(1), Sets threshold adjusted P value. lfc Numeric(1), Sets threshold log2 fold change. thresholdmethod Character(1), thresholdmethod decide significant.one \"intersect\" ,\"curve\". thresholdmethod = \"curve\", cutoff lines curves function y = c/(x-x0). c curvature, x0 minimum fold change relatived standard deviations L2FC distribution curvature Numeric(1), Sets curvature curve cutoff lines x0_fold Numeric(1), decide x0 ratio standard deviations L2FC. x0 usually set 1(medium confidence) 2(high confidence) standard deviations.","code":""},{"path":"/reference/DEP2_add_rejections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mark significant proteins — add_rejections","text":"SummarizedExperiment object annotated logical columns indicating significant proteins.","code":""},{"path":[]},{"path":"/reference/GS_imp_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"pre_processing_GS_wrapper — GS_imp_wrapper","title":"pre_processing_GS_wrapper — GS_imp_wrapper","text":"import GSimp github.com/WandeRum/GSimp","code":""},{"path":"/reference/GS_imp_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"pre_processing_GS_wrapper — GS_imp_wrapper","text":"","code":"GS_imp_wrapper(   data,   log = F,   iters_each = 50,   iters_all = 10,   lo = -Inf,   hi = NULL,   hi_q = 0.15,   n_cores = 1 )"},{"path":"/reference/GS_imp_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"pre_processing_GS_wrapper — GS_imp_wrapper","text":"data assay","code":""},{"path":"/reference/ID_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"ID transform SE or DEGdata — ID_transform","title":"ID transform SE or DEGdata — ID_transform","text":"Transform ID SummarizedExperiment DEGdata according origin ID. annotation package certain species must installed. Using annoSpecies_df check species names required packages.","code":""},{"path":"/reference/ID_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ID transform SE or DEGdata — ID_transform","text":"","code":"ID_transform(   x,   from_columns = \"rownames\",   fromtype = \"ENSEMBL\",   species = \"Human\",   replace_rowname = \"SYMBOL\" )"},{"path":"/reference/ID_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ID transform SE or DEGdata — ID_transform","text":"x SummarizedExperiment object make_se()) make_pe()), DEGdata object test_diff_deg()). from_columns Character(), origin ID one \"rownames\" column rowData(x) fromtype Character(1), type origin ID, e.g. \"ENSEMBEL\", \"SYMBOL\", \"UNIPROT\", \"ENTREZID\". species Character(1), species name. replace_rowname NULL character. one NULL, \"SYMBOL\", \"ENTREZID\", \"UNIPROT\", \"ENSEMBL\". NULL, replace rownames(x) selected kind ID.","code":""},{"path":"/reference/ID_transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ID transform SE or DEGdata — ID_transform","text":"SummarizedExperiment DEGdata rowData includes gene information like \"ENSEMBEL\", \"SYMBOL\", \"UNIPROT\" \"ENTREZID\" transformed giving ID. x DEGdata, gene information table also store geneinfo slot. Rownames object replaced according replace_rowname.","code":""},{"path":"/reference/ID_transform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ID transform SE or DEGdata — ID_transform","text":"","code":"if (FALSE) { data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\")  ## transform uniport ID check_organismDB_depends(organism = \"Mouse\") # check annotation package of Mouse head(rowData(se)$ID) se2 <- ID_transform(se,from_columns = \"ID\",fromtype = \"UNIPROT\",species = \"Mouse\") head(rowData(se2)$SYMBOL) head(rownames(se2)) }"},{"path":"/reference/NAiszero.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform NA to 0 in assay of a SummarizedExperiment — NAiszero","title":"Transform NA to 0 in assay of a SummarizedExperiment — NAiszero","text":"Transform NA 0 assay SummarizedExperiment","code":""},{"path":"/reference/NAiszero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform NA to 0 in assay of a SummarizedExperiment — NAiszero","text":"","code":"NAiszero(se)"},{"path":"/reference/NAiszero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform NA to 0 in assay of a SummarizedExperiment — NAiszero","text":"se SummarizedExperiment object contain NAs assay.","code":""},{"path":"/reference/NAiszero.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform NA to 0 in assay of a SummarizedExperiment — NAiszero","text":"SummarizedExperiment object","code":""},{"path":"/reference/Order_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Set order of experiment design for SummarizedExperiment — Order_cols","title":"Set order of experiment design for SummarizedExperiment — Order_cols","text":"Order_cols can re-set order SummarizedExperiment object according  colData()","code":""},{"path":"/reference/Order_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set order of experiment design for SummarizedExperiment — Order_cols","text":"","code":"Order_cols(object, order, order_column = \"condition\")"},{"path":"/reference/Order_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set order of experiment design for SummarizedExperiment — Order_cols","text":"object SummarizedExperiment object order Character vector, order set. order_column Set order column experiment design, e.g. \"condition\", \"label\"","code":""},{"path":"/reference/Order_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set order of experiment design for SummarizedExperiment — Order_cols","text":"object sorted giving order","code":""},{"path":"/reference/Order_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set order of experiment design for SummarizedExperiment — Order_cols","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\") colnames(se) #>  [1] \"PBS_1\" \"PBS_2\" \"PBS_3\" \"PBS_4\" \"W10_2\" \"W10_4\" \"W2_1\"  \"W2_3\"  \"W2_4\"  #> [10] \"W2_5\"  \"W4_2\"  \"W4_3\"  \"W4_4\"  \"W4_5\"  \"W6_2\"  \"W6_3\"  \"W6_4\"  \"W6_6\"  #> [19] \"W9_2\"  \"W9_4\"  se <- Order_cols(se,c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\")) colnames(se) #>  [1] \"PBS_1\" \"PBS_2\" \"PBS_3\" \"PBS_4\" \"W2_1\"  \"W2_3\"  \"W2_4\"  \"W2_5\"  \"W4_2\"  #> [10] \"W4_3\"  \"W4_4\"  \"W4_5\"  \"W6_2\"  \"W6_3\"  \"W6_4\"  \"W6_6\"  \"W9_2\"  \"W9_4\"  #> [19] \"W10_2\" \"W10_4\""},{"path":"/reference/PPInetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw a network on PPI result — PPInetwork","title":"Draw a network on PPI result — PPInetwork","text":"Draw network PPI result output test_PPI","code":""},{"path":"/reference/PPInetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw a network on PPI result — PPInetwork","text":"","code":"PPInetwork(   PPIlinks,   layoutway = \"layout_components\",   nodecolor = \"#2EA9DF\",   nodeshape = c(\"circle\", \"square\"),   linecolor = \"#ADD8E6\",   nodesize = 20,   changesize = FALSE,   fontsize = 25,   changewidth = FALSE,   linewidth = 5,   smoothline = FALSE,   smoothtype = \"continous\",   highlightkey = TRUE,   returntype = c(\"visNetwork\", \"igraph\") )"},{"path":"/reference/PPInetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw a network on PPI result — PPInetwork","text":"PPIlinks PPI result test_ppi layoutway Character(1), name layout function igraph package,\"layout_as_star\", \"layout_as_tree\", \"layout_in_circle\". See layout. nodecolor Character(1), color node. nodeshape Character(1), shape node. One \"circle\", \"square\", \"raster\", vertex.shapes igraph. linecolor Character(1), color edge line. nodesize Numeric(1), size node. changesize Logical(1), whether change node size link number. fontsize Numeric(1), font size label. changewidth Logical(1), whether change edge width interaction score. linewidth Numeric(1), width edge. smoothline Logical(1), whether smooth edge. Works visNetwork smoothtype Character(1), one 'dynamic', 'continuous', 'discrete', 'diagonalCross', 'straightCross', 'horizontal', 'vertical', 'curvedCW', 'curvedCCW', 'cubicBezier' highlightkey logical(1), whether label central nodes red least 6 interactions. returntype Character(1), \"visNetwork\" \"igraph\".","code":""},{"path":"/reference/PPInetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw a network on PPI result — PPInetwork","text":"visNetwork plot igraph obejct according returntype.","code":""},{"path":"/reference/PPInetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw a network on PPI result — PPInetwork","text":"","code":"if (FALSE) { # Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") norm <- normalize_vsn(filt) imputed <- impute(norm, fun = \"MinProb\", q = 0.05) diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # PPI construct if(check_PPI_depends()){    # Load STRING data. If local STRING is missing, PPI_res will download to system.file(\"PPIdata\", \"Mouse\",package = \"DEP2\")   load_PPIdata(speciesname = \"Mouse\")    PPI_res <- test_PPI(dep, contrasts = \"W4_vs_PBS\", species = \"Mouse\",                       STRING.version = \"11.5\",score_cutoff = 400)    ## igraph network   PPI_ig <- PPInetwork(PPI_res, returntype = \"igraph\")   igraph::plot.igraph(PPI_ig)    ## visNetwork network   PPInetwork(PPI_res, returntype = \"visNetwork\")   } }"},{"path":"/reference/Silicosis_ExpDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Silicosis_ExpDesign - experiment design of silicosis mouse proteome — Silicosis_ExpDesign","title":"Silicosis_ExpDesign - experiment design of silicosis mouse proteome — Silicosis_ExpDesign","text":"ExpDesign table Silicosis_pg annotating samples information.","code":""},{"path":"/reference/Silicosis_ExpDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Silicosis_ExpDesign - experiment design of silicosis mouse proteome — Silicosis_ExpDesign","text":"","code":"Silicosis_ExpDesign"},{"path":"/reference/Silicosis_ExpDesign.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Silicosis_ExpDesign - experiment design of silicosis mouse proteome — Silicosis_ExpDesign","text":"data.frame 20 rows 4 variables: label/ID label experiment groups condition experiment condition replicate Replicate number","code":""},{"path":"/reference/Silicosis_peptide.html","id":null,"dir":"Reference","previous_headings":"","what":"Silicosis_peptide - peptide quantity data of a silicosis mouse model — Silicosis_peptide","title":"Silicosis_peptide - peptide quantity data of a silicosis mouse model — Silicosis_peptide","text":"Silicosis_peptide peptide quantity proteomics study silica-exposed mouse model reported Wang, Zhang, Liu, et al.","code":""},{"path":"/reference/Silicosis_peptide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Silicosis_peptide - peptide quantity data of a silicosis mouse model — Silicosis_peptide","text":"","code":"Silicosis_peptide"},{"path":"/reference/Silicosis_peptide.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Silicosis_peptide - peptide quantity data of a silicosis mouse model — Silicosis_peptide","text":"data.frame 143528 rows 29 variables: Sequence Peptide Sequence Missed.cleavages Missed cleavages number peptide Proteins uniprot ID proteins peptide affiliated Leading.razor.protein leading razor protein uniprot ID peptide affiliated Gene.names Gene name proteins peptide affiliated PEP Posterior error probability identification Score Andromeda score Maxquant Intensity columns Raw intensity peptides Reverse peptide identified decoy database marked ('+') Potential.contaminant peptide known contaminant protein marked ('+')","code":""},{"path":"/reference/Silicosis_peptide.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Silicosis_peptide - peptide quantity data of a silicosis mouse model — Silicosis_peptide","text":"Wang M, Zhang Z, Liu J, et al. Gefitinib fostamatinib target EGFR SYK attenuate silicosis: multi-omics study drug exploration. Signal Transduct Target Ther. 2022;7(1):157. doi: 10.1038/s41392-022-00959-3.","code":""},{"path":"/reference/Silicosis_pg.html","id":null,"dir":"Reference","previous_headings":"","what":"Silicosis_pg - proteinGroups data of a silicosis mouse model — Silicosis_pg","title":"Silicosis_pg - proteinGroups data of a silicosis mouse model — Silicosis_pg","text":"Silicosis_pg proteinGroups result proteomics study silica-exposed mouse model reported Wang, Zhang, Liu, et al.","code":""},{"path":"/reference/Silicosis_pg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Silicosis_pg - proteinGroups data of a silicosis mouse model — Silicosis_pg","text":"","code":"Silicosis_pg"},{"path":"/reference/Silicosis_pg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Silicosis_pg - proteinGroups data of a silicosis mouse model — Silicosis_pg","text":"data.frame 10718 rows 55 variables: Protein.IDs Uniprot IDs Majority.protein.IDs Uniprot IDs major protein(s) protein group Peptide.counts... Total peptides counts protein Peptide.counts..razor.unique. Razor unique peptides counts protein Peptide.counts..unique. Unique peptides counts protein Protein.names Full protein names Gene.names Gene name Fasta.headers Header present Uniprot fasta file Peptides Number peptides identified protein group Razor...unique.peptides Number peptides used quantification protein group Unique.peptides Number peptides identified unique protein group iBAQ columns intensity-based absolute-protein-quantification LFQ.intensity columns LFQ normalized mass spectrometry intensity, .U. .identified..site protein identified modification site marked ('+') Reverse protein identified decoy database marked ('+') Potential.contaminant protein known contaminant marked ('+')","code":""},{"path":"/reference/Silicosis_pg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Silicosis_pg - proteinGroups data of a silicosis mouse model — Silicosis_pg","text":"Wang M, Zhang Z, Liu J, et al. Gefitinib fostamatinib target EGFR SYK attenuate silicosis: multi-omics study drug exploration. Signal Transduct Target Ther. 2022;7(1):157. doi: 10.1038/s41392-022-00959-3.","code":""},{"path":"/reference/Silicosis_phos.html","id":null,"dir":"Reference","previous_headings":"","what":"Silicosis_phos - phosphoproteome result of a silicosis mouse model — Silicosis_phos","title":"Silicosis_phos - phosphoproteome result of a silicosis mouse model — Silicosis_phos","text":"enriched phosphopeptide quantity data silica-exposed mouse model reported Wang, Zhang, Liu, et al.","code":""},{"path":"/reference/Silicosis_phos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Silicosis_phos - phosphoproteome result of a silicosis mouse model — Silicosis_phos","text":"","code":"Silicosis_phos"},{"path":"/reference/Silicosis_phos.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Silicosis_phos - phosphoproteome result of a silicosis mouse model — Silicosis_phos","text":"data.frame 21249 rows 40 variables: Proteins proteins uniprot IDs phosphopeptide affiliated Protein first protein uniprot ID Gene.names Gene names proteins phosphopeptide affiliated Localization.prob localization probability phosphorylated site PEP Posterior error probability identification Score Andromeda score peptide identification Score..localization Andromeda score MS/MS spectrum used calculating localization score site Amino.acid phosphorylated Amino acid Intensity columns Raw intensity phosphopeptide Reverse peptide identified decoy database marked ('+') Potential.contaminant peptide known contaminant protein marked ('+') Positions possible phosphorylation positions peptides Position possible position phosphorylation","code":""},{"path":"/reference/Silicosis_phos.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Silicosis_phos - phosphoproteome result of a silicosis mouse model — Silicosis_phos","text":"Wang M, Zhang Z, Liu J, et al. Gefitinib fostamatinib target EGFR SYK attenuate silicosis: multi-omics study drug exploration. Signal Transduct Target Ther. 2022;7(1):157. doi: 10.1038/s41392-022-00959-3.","code":""},{"path":"/reference/aggregate_pe.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize peptide quantity to protein quantity — aggregate_pe","title":"Summarize peptide quantity to protein quantity — aggregate_pe","text":"Aggregation peptide protein vis 'aggrefun'.","code":""},{"path":"/reference/aggregate_pe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize peptide quantity to protein quantity — aggregate_pe","text":"","code":"aggregate_pe(   pe,   aggrefun = c(\"RobustSummary\", \"medianPolish\", \"totalMean\"),   aggregate_Peptide_Type = c(\"Unique + Razor\", \"Unique\"),   fcol,   i = \"peptideNorm\",   reserve = \"Gene.names\" )"},{"path":"/reference/aggregate_pe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize peptide quantity to protein quantity — aggregate_pe","text":"pe QFeatures object, contains normalized peptide assay aggrefun function used quantitative feature aggregation. can character \"RobustSummary\",\"medianPolish\",\"totalMean\" function. Details see aggregateFeatures aggregate_Peptide_Type Character \"Unique + Razor\" \"Unique\". Use kind peptides summarise proteins. choose \"Unique\", return output just save unique peptides smallest proteingroups. fcol Character(1), defining summarise features. Exist rowData(pe). Character(1), name assay aggregated. reserve Character, column(s) reserve aggregate, columns store protein information can.","code":""},{"path":"/reference/aggregate_pe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize peptide quantity to protein quantity — aggregate_pe","text":"QFeatures object new protein aggregation assay.","code":""},{"path":"/reference/aggregate_pe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize peptide quantity to protein quantity — aggregate_pe","text":"","code":"if (FALSE) { # Load example peptide data data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)  # construct QFeatures object pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols, remove_prefix = TRUE, log2transform = TRUE,mode = \"delim\")  # Filter, imputation pe <- filter_pe(pe_peptides, thr = 1,fraction = 0.4, filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) pe <- impute_pe(pe, fun = \"QRILC\", name = \"peptideImp\")  # Normalization pe <- normalize_pe(pe,method = \"quantiles\", i = \"peptideImp\", name = \"peptideNorm\")  # Summarize peptide value to protein quantity protein_pe <- DEP2::aggregate_pe(pe, fcol = \"Proteins\", i = \"peptideNorm\") class(protein_pe)  }"},{"path":"/reference/annoSpecies_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Species information table — annoSpecies_df","title":"Species information table — annoSpecies_df","text":"Record species names IDs org database package.","code":""},{"path":"/reference/annoSpecies_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Species information table — annoSpecies_df","text":"","code":"annoSpecies_df()"},{"path":"/reference/annoSpecies_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Species information table — annoSpecies_df","text":"data.frame","code":""},{"path":"/reference/check_PPI_depends.html","id":null,"dir":"Reference","previous_headings":"","what":"Check required packages for PPI analysis. — check_PPI_depends","title":"Check required packages for PPI analysis. — check_PPI_depends","text":"Check depend packages PPI analysis.","code":""},{"path":"/reference/check_PPI_depends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check required packages for PPI analysis. — check_PPI_depends","text":"","code":"check_PPI_depends(install = T)"},{"path":"/reference/check_PPI_depends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check required packages for PPI analysis. — check_PPI_depends","text":"install logic(1). Whether install missing packages.","code":""},{"path":"/reference/check_RNAseq_depends.html","id":null,"dir":"Reference","previous_headings":"","what":"Check required packages for DESeq2. — check_RNAseq_depends","title":"Check required packages for DESeq2. — check_RNAseq_depends","text":"Check depend packages RNA-Seq analysis workflow based DESeq2","code":""},{"path":"/reference/check_RNAseq_depends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check required packages for DESeq2. — check_RNAseq_depends","text":"","code":"check_RNAseq_depends(install = T)"},{"path":"/reference/check_RNAseq_depends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check required packages for DESeq2. — check_RNAseq_depends","text":"install logic(1). Whether install missing packages.","code":""},{"path":"/reference/check_enrichment_depends.html","id":null,"dir":"Reference","previous_headings":"","what":"Check required packages for enrichment analysis. — check_enrichment_depends","title":"Check required packages for enrichment analysis. — check_enrichment_depends","text":"Check depend packages functional enrichment. Including clusterProfiler, ReactomePA msigdbr","code":""},{"path":"/reference/check_enrichment_depends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check required packages for enrichment analysis. — check_enrichment_depends","text":"","code":"check_enrichment_depends(install = T)"},{"path":"/reference/check_enrichment_depends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check required packages for enrichment analysis. — check_enrichment_depends","text":"install logic(1). Whether install missing packages.","code":""},{"path":"/reference/check_organismDB_depends.html","id":null,"dir":"Reference","previous_headings":"","what":"Check organism annotation package — check_organismDB_depends","title":"Check organism annotation package — check_organismDB_depends","text":"Check install organism annotation package(OrgDb Bioconductor).","code":""},{"path":"/reference/check_organismDB_depends.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check organism annotation package — check_organismDB_depends","text":"","code":"check_organismDB_depends(organism, install = T)"},{"path":"/reference/check_organismDB_depends.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check organism annotation package — check_organismDB_depends","text":"organism Character(1), organism name, one c( \"Chicken\", \"Human\", \"Mouse\", \"Fly\", \"Rat\", \"Yeast\"). species OrgDb also optional. information can see annoSpecies_df install logic(1). Whether install organism annotation db package missed.","code":""},{"path":"/reference/clean_character.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean characters in expression columns — clean_character","title":"Clean characters in expression columns — clean_character","text":"class expression contain characters(e.g. 'NA.', 'filtered'), run Clean characters replace character NA, transfor expression value numeric","code":""},{"path":"/reference/clean_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean characters in expression columns — clean_character","text":"","code":"clean_character(express_assay)"},{"path":"/reference/clean_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean characters in expression columns — clean_character","text":"express_assay data.frame matrix, expression assay.","code":""},{"path":"/reference/clean_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean characters in expression columns — clean_character","text":"numeric matrix","code":""},{"path":"/reference/clean_character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clean characters in expression columns — clean_character","text":"","code":"expression_assay = data.frame(A = c(\"1165799.5\",\"51419028\",\"1.9e6\",\"2213111.25\"),                               B = c(\"1455111\",\"Filtered\",\"2021020.375\",\"NA\"),                               c = c(261344, 49840292, 2388750, 1753475.625)) str(expression_assay) #> 'data.frame':\t4 obs. of  3 variables: #>  $ A: chr  \"1165799.5\" \"51419028\" \"1.9e6\" \"2213111.25\" #>  $ B: chr  \"1455111\" \"Filtered\" \"2021020.375\" \"NA\" #>  $ c: num  261344 49840292 2388750 1753476 (clean_character(expression_assay)) #>          A       B        c #> 1  1165800 1455111   261344 #> 2 51419028      NA 49840292 #> 3  1900000 2021020  2388750 #> 4  2213111      NA  1753476"},{"path":"/reference/correct_PTM_by_Protein.html","id":null,"dir":"Reference","previous_headings":"","what":"correct_PTM_by_Protein — correct_PTM_by_Protein","title":"correct_PTM_by_Protein — correct_PTM_by_Protein","text":"Adjust modified-enrich peptide quantities (PTM relative proteomics) relative global proteomics data via matching correct_key correct_level","code":""},{"path":"/reference/correct_PTM_by_Protein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"correct_PTM_by_Protein — correct_PTM_by_Protein","text":"","code":"correct_PTM_by_Protein(   enriched_peptide,   relative_protein,   correct_key = c(\"name\", \"ID\"),   correct_level = c(\"condition\", \"replicate\"),   unidentified_treatment = c(\"retain\", \"remove\") )"},{"path":"/reference/correct_PTM_by_Protein.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"correct_PTM_by_Protein — correct_PTM_by_Protein","text":"enriched_peptide SummarizedExperiment object modified-relative proteomics. relative_protein SummarizedExperiment object relative global proteomics correct_key key identifier column match PTM peptides proteins, one \"name\", \"ID\" correct_level Character(1), match experiment design, one \"condition\" \"replicate\" unidentified_treatment Character(1), one \"retain\", \"remove\", treat PTM peptides whose proteins unidentified relative global proteomics","code":""},{"path":"/reference/correct_PTM_by_Protein.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"correct_PTM_by_Protein — correct_PTM_by_Protein","text":"modified-relative proteomics SummarizedExperiment object adjusted quantities","code":""},{"path":"/reference/downloadAbsentFile.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — downloadAbsentFile","title":"Title — downloadAbsentFile","text":"Title","code":""},{"path":"/reference/downloadAbsentFile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — downloadAbsentFile","text":"","code":"downloadAbsentFile(urlStr, oD = tempdir())"},{"path":"/reference/downloadAbsentFile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — downloadAbsentFile","text":"oD","code":""},{"path":"/reference/filter_pe.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Qfeatures object on missing values or formula — filter_pe","title":"Filter Qfeatures object on missing values or formula — filter_pe","text":"filter_pe filters Qfeatures object based missing values assay provides formula. dataset filtered proteins maximum 'thr' missing values least one condition; maximum 'missnum' samples; filter_formula","code":""},{"path":"/reference/filter_pe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Qfeatures object on missing values or formula — filter_pe","text":"","code":"filter_pe(   pe,   thr = NULL,   missnum = NULL,   fraction = NULL,   filter_formula = NULL,   assay_name = \"peptideRaw\",   return_keeprows = F )"},{"path":"/reference/filter_pe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Qfeatures object on missing values or formula — filter_pe","text":"pe Qfeatures, Proteomics data (output make_pe() make_pe_parse()). thr Integer(1), Sets threshold allowed max number missing values least one condition. least one condition, missing values number < = 'thr'. missnum Integer(1), Sets threshold allowed max number among samples, missing values number < = 'missnum' row. fraction numeric 0 1, threshold missing occupancy row filter_formula Formula character(1). filter expression, written formula. assay_name Character(1), name assay perform filter. return_keeprows Logical(1), default FALSE, return trimmed object. TURE return rows number pass filter.","code":""},{"path":"/reference/filter_pe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Qfeatures object on missing values or formula — filter_pe","text":"filtered Qfeatures object, vector keep rows return_keeprows TRUE","code":""},{"path":"/reference/filter_pe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter Qfeatures object on missing values or formula — filter_pe","text":"","code":"# Load example peptide data data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)  # Construct a QFeatures object, with a 'peptideRaw' assay pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols, remove_prefix = TRUE, log2transform = TRUE,mode = \"delim\") filt_pe <- filter_pe(pe_peptides, thr = 1,fraction = 0.4, filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) #> filter base on missing number is <= 1 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula"},{"path":"/reference/filter_se.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter SummarizedExperiment on missing values or formula — filter_se","title":"Filter SummarizedExperiment on missing values or formula — filter_se","text":"filter_se filters SummarizedExperiment object based missing values assay provides formula. dataset filtered proteins maximum 'thr' missing values least one condition; maximum 'missnum' samples; filter_formula","code":""},{"path":"/reference/filter_se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter SummarizedExperiment on missing values or formula — filter_se","text":"","code":"filter_se(   se,   thr = NULL,   missnum = NULL,   fraction = NULL,   filter_formula = NULL,   rowsum_threshold = NULL,   return_keeprows = FALSE )"},{"path":"/reference/filter_se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter SummarizedExperiment on missing values or formula — filter_se","text":"se SummarizedExperiment, Proteomics data (output make_se() make_se_parse()). thr Integer(1), Sets threshold allowed max number missing values least one condition. least one condition, missing values number < = 'thr'. missnum Integer(1), Sets threshold allowed max number among samples, missing values number < = 'missnum' row. fraction numeric 0 1, threshold missing occupancy row filter_formula Formula character(1). filter expression, written formula. rowsum_threshold numeric, row sum intensity(abundance) must larger . return_keeprows Logical(1), default FALSE, return trimmed object. TURE return rows number pass filter.","code":""},{"path":"/reference/filter_se.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter SummarizedExperiment on missing values or formula — filter_se","text":"filtered SummarizedExperiment object, vector keep rows return_keeprows TRUE","code":""},{"path":"/reference/filter_se.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter SummarizedExperiment on missing values or formula — filter_se","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Filter stringent_filter <- filter_se(se, thr = 0, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on giving formula  less_stringent_filter <- filter_se(se, thr = 1, missnum = 2, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number <= 2 #> filter base on missing number is <= 1 in at least one condition. #> filter base on giving formula  keep_rows <- filter_se(se, thr = 0, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\", return_keeprows = TRUE) #> filter base on missing number is <= 0 in at least one condition. #> filter base on giving formula"},{"path":"/reference/get_ORA_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract significant enrichment terms base on giving threshold — get_ORA_result","title":"Extract significant enrichment terms base on giving threshold — get_ORA_result","text":"get_ORA_result filter enrichment result test_ORA though certain threshold.","code":""},{"path":"/reference/get_ORA_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract significant enrichment terms base on giving threshold — get_ORA_result","text":"","code":"get_ORA_result(   ORA_enrichment,   ont = NULL,   pvalueCutoff = 0.05,   qvalueCutoff = 0.2,   simplify = FALSE,   simplify.cutoff = 0.7,   simplify.measure = c(\"Wang\", \"Resnik\", \"Lin\", \"Rel\", \"Jiang\"),   simplify.semData = NULL,   return_table = F )"},{"path":"/reference/get_ORA_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract significant enrichment terms base on giving threshold — get_ORA_result","text":"ont One \"\", \"BP\", \"MF\", \"CC\" pvalueCutoff Numeric(1), p.value cutoff enrichment result qvalueCutoff Numeric(1), qvalue cutoff enrichment tests simplify Logical(1), simplify GO terms simplify simplify.cutoff Numeric(1), cutoff value transmitted  simplify return_table Logical(1), true return enrichResult result table reat output test_ORA","code":""},{"path":"/reference/get_ORA_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract significant enrichment terms base on giving threshold — get_ORA_result","text":"enrichResult/compareClusterResult significant enrichment, result table significant enrichment return_table TRUE.","code":""},{"path":"/reference/get_ORA_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract significant enrichment terms base on giving threshold — get_ORA_result","text":"","code":"if (FALSE) { # Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") norm <- normalize_vsn(filt) imputed <- impute(norm, fun = \"MinProb\", q = 0.05) diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\")  res_ora <- test_ORA(dep, contrasts = \"W4_vs_PBS\", species = \"Mouse\",type = \"GO\") res_ora2 <- get_ORA_result(res_ora) }"},{"path":"/reference/get_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","title":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","text":"Get contrast(s) SummarizedExperiment DEGdata","code":""},{"path":"/reference/get_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","text":"","code":"get_contrast(object)"},{"path":"/reference/get_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","text":"object SummarizedExperiment DEGdata object output test_diff()","code":""},{"path":"/reference/get_contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","text":"Character, existing contrast(s) object, introduced test_diff step.","code":""},{"path":"/reference/get_contrast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get contrast(s) from SummarizedExperiment or DEGdata — get_contrast","text":"","code":"data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  filt <- filter_se(se, thr = 0, fraction = 0.3, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8832 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) get_contrast(diff) #> [1] \"W10_vs_PBS\" \"W2_vs_PBS\"  \"W4_vs_PBS\"  \"W6_vs_PBS\"  \"W9_vs_PBS\"  diff <- test_diff(imputed,type = \"manual\", test = c(\"W9_vs_PBS\",\"W6_vs_PBS\")) #> Tested contrasts: W9_vs_PBS, W6_vs_PBS #> Strimmer's qvalue(t) get_contrast(diff) #> [1] \"W6_vs_PBS\" \"W9_vs_PBS\""},{"path":"/reference/get_df_long.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a long data.frame from a SummarizedExperiment — get_df_long","title":"Generate a long data.frame from a SummarizedExperiment — get_df_long","text":"get_df_long generate wide data.frame SummarizedExperiment.","code":""},{"path":"/reference/get_df_long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a long data.frame from a SummarizedExperiment — get_df_long","text":"","code":"get_df_long(se)"},{"path":"/reference/get_df_long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a long data.frame from a SummarizedExperiment — get_df_long","text":"se SummarizedExperiment, Proteomics data (output make_se() make_se_parse()).","code":""},{"path":"/reference/get_df_long.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a long data.frame from a SummarizedExperiment — get_df_long","text":"data.frame object containing data wide format, row represents single measurement.","code":""},{"path":"/reference/get_df_long.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a long data.frame from a SummarizedExperiment — get_df_long","text":"","code":"# Load example data(Silicosis_pg) data_unique <- make_unique(Silicosis_pg, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\") # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff)  long <- get_df_long(dep) colnames(long) #>  [1] \"label\"                         \"condition\"                     #>  [3] \"replicate\"                     \"name\"                          #>  [5] \"intensity\"                     \"Protein.IDs\"                   #>  [7] \"Majority.protein.IDs\"          \"Peptide.counts..all.\"          #>  [9] \"Peptide.counts..razor.unique.\" \"Peptide.counts..unique.\"       #> [11] \"Protein.names\"                 \"Gene.names\"                    #> [13] \"Fasta.headers\"                 \"Number.of.proteins\"            #> [15] \"Peptides\"                      \"Razor...unique.peptides\"       #> [17] \"Unique.peptides\"               \"iBAQ.PBS_1\"                    #> [19] \"iBAQ.PBS_2\"                    \"iBAQ.PBS_3\"                    #> [21] \"iBAQ.PBS_4\"                    \"iBAQ.W10_2\"                    #> [23] \"iBAQ.W10_4\"                    \"iBAQ.W2_1\"                     #> [25] \"iBAQ.W2_3\"                     \"iBAQ.W2_4\"                     #> [27] \"iBAQ.W2_5\"                     \"iBAQ.W4_2\"                     #> [29] \"iBAQ.W4_3\"                     \"iBAQ.W4_4\"                     #> [31] \"iBAQ.W4_5\"                     \"iBAQ.W6_2\"                     #> [33] \"iBAQ.W6_3\"                     \"iBAQ.W6_4\"                     #> [35] \"iBAQ.W6_6\"                     \"iBAQ.W9_2\"                     #> [37] \"iBAQ.W9_4\"                     \"Only.identified.by.site\"       #> [39] \"Reverse\"                       \"Potential.contaminant\"         #> [41] \"ID\"                            \"imputed\"                       #> [43] \"num_NAs\"                       \"W10_vs_PBS_CI.L\"               #> [45] \"W10_vs_PBS_CI.R\"               \"W10_vs_PBS_diff\"               #> [47] \"W10_vs_PBS_p.adj\"              \"W10_vs_PBS_p.val\"              #> [49] \"W10_vs_PBS_t.stastic\"          \"W2_vs_PBS_CI.L\"                #> [51] \"W2_vs_PBS_CI.R\"                \"W2_vs_PBS_diff\"                #> [53] \"W2_vs_PBS_p.adj\"               \"W2_vs_PBS_p.val\"               #> [55] \"W2_vs_PBS_t.stastic\"           \"W4_vs_PBS_CI.L\"                #> [57] \"W4_vs_PBS_CI.R\"                \"W4_vs_PBS_diff\"                #> [59] \"W4_vs_PBS_p.adj\"               \"W4_vs_PBS_p.val\"               #> [61] \"W4_vs_PBS_t.stastic\"           \"W6_vs_PBS_CI.L\"                #> [63] \"W6_vs_PBS_CI.R\"                \"W6_vs_PBS_diff\"                #> [65] \"W6_vs_PBS_p.adj\"               \"W6_vs_PBS_p.val\"               #> [67] \"W6_vs_PBS_t.stastic\"           \"W9_vs_PBS_CI.L\"                #> [69] \"W9_vs_PBS_CI.R\"                \"W9_vs_PBS_diff\"                #> [71] \"W9_vs_PBS_p.adj\"               \"W9_vs_PBS_p.val\"               #> [73] \"W9_vs_PBS_t.stastic\"           \"W10_vs_PBS_significant\"        #> [75] \"W2_vs_PBS_significant\"         \"W4_vs_PBS_significant\"         #> [77] \"W6_vs_PBS_significant\"         \"W9_vs_PBS_significant\"         #> [79] \"significant\""},{"path":"/reference/get_df_wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","title":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","text":"get_df_wide generate wide data.frame SummarizedExperiment.","code":""},{"path":"/reference/get_df_wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","text":"","code":"get_df_wide(se)"},{"path":"/reference/get_df_wide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","text":"se SummarizedExperiment DEGdata object.","code":""},{"path":"/reference/get_df_wide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","text":"data.frame object containing data wide format(combine assay rowData), row represents protein/gene.","code":""},{"path":"/reference/get_df_wide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a wide data.frame from a SummarizedExperiment — get_df_wide","text":"","code":"# Load example data(Silicosis_pg) data_unique <- make_unique(Silicosis_pg, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\") # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff) get_df_wide(dep) #>             name    PBS_1    PBS_2    PBS_3    PBS_4    W10_2    W10_4     W2_1 #> 1  4931429I11Rik 28.70045 24.93761 29.75342 29.95957 24.89231 28.23119 30.34856 #> 2  4932418E24Rik 27.78676 27.95045 28.11689 28.63062 27.92583 28.32200 27.91089 #> 3  9230110C19Rik 28.15309 27.59883 27.18844 27.67702 27.80568 28.01911 27.81927 #> 4     A0A0B4J1G0 25.01261 24.93761 25.11992 24.96369 27.32584 26.73893 23.79471 #> 5         A2AG58 28.34999 27.51432 25.00725 28.70948 28.01023 27.44449 28.63363 #> 6            A2m 34.57332 34.72135 35.78446 35.04418 33.46302 33.85551 33.14775 #> 7         A3KGF9 29.64549 29.22066 29.24076 29.72597 28.89847 29.03256 28.89834 #> 8         A6H630 28.51091 29.00241 29.09496 28.86264 29.21694 29.19137 29.02402 #> 9           Aaas 28.44612 28.44058 28.85120 28.68186 28.96055 28.89964 28.91826 #> 10          Aacs 30.43128 30.47401 30.28250 30.60539 30.79143 31.06079 30.76782 #>        W2_3     W2_4     W2_5     W4_2     W4_3     W4_4     W4_5     W6_2 #> 1  29.50451 29.03613 29.55282 28.68068 29.31367 29.16450 29.10021 28.38552 #> 2  27.05942 27.28252 27.08586 28.32345 28.56645 28.04732 28.61185 28.12572 #> 3  27.37634 27.44095 27.58823 27.83905 28.19786 28.05611 27.53541 28.11495 #> 4  27.14472 26.21215 26.60410 26.01617 24.74135 26.51245 26.05723 25.89587 #> 5  28.43678 28.81267 28.30759 27.82674 28.02356 27.61256 24.86456 27.98525 #> 6  34.31248 33.46066 33.24186 33.19310 32.74648 33.58896 33.32027 33.71811 #> 7  28.71770 28.71744 28.71441 28.63737 28.89839 28.22483 29.30059 28.87607 #> 8  28.96318 29.14451 29.06034 29.00653 29.05851 29.29631 29.39051 29.24155 #> 9  29.05142 28.83850 28.55392 29.07915 28.76030 29.06208 28.90197 29.14340 #> 10 30.96020 30.70033 30.81449 30.80066 30.49656 30.68210 30.43653 30.63227 #>        W6_3     W6_4     W6_6     W9_2     W9_4 Protein.IDs #> 1  24.85031 24.74397 24.78682 27.19517 24.84699      E9Q793 #> 2  27.52801 27.60662 27.82703 28.25101 27.56389      Q8C5V8 #> 3  27.49192 27.90190 28.09850 28.01374 27.10166      Q8CC70 #> 4  26.76816 26.72821 26.84339 26.52089 27.00605  A0A0B4J1G0 #> 5  27.78401 27.89912 27.62169 28.38426 24.84699      A2AG58 #> 6  33.75012 34.04199 33.46282 34.35617 33.56346      Q61838 #> 7  28.26034 28.59259 28.58033 28.58008 28.71798      A3KGF9 #> 8  29.30918 29.17283 29.50891 29.01680 29.29224      A6H630 #> 9  29.10231 28.91989 28.32318 28.88143 29.08772      P58742 #> 10 30.77801 30.88343 30.89412 29.71736 30.40523      Q9D2R0 #>    Majority.protein.IDs Peptide.counts..all. Peptide.counts..razor.unique. #> 1                E9Q793                    7                             7 #> 2                Q8C5V8                   15                            15 #> 3                Q8CC70                   14                            14 #> 4            A0A0B4J1G0                    3                             3 #> 5                A2AG58                   10                            10 #> 6                Q61838                   58                            58 #> 7                A3KGF9                   14                            14 #> 8                A6H630                   15                            15 #> 9                P58742                   12                            12 #> 10               Q9D2R0                   20                            20 #>    Peptide.counts..unique. #> 1                        7 #> 2                       15 #> 3                       14 #> 4                        3 #> 5                       10 #> 6                       56 #> 7                       14 #> 8                       15 #> 9                       12 #> 10                      20 #>                                                                                       Protein.names #> 1                                                                                                   #> 2                                                                                                   #> 3                                                                                                   #> 4                                                                                                   #> 5                                                           Uncharacterized protein CXorf23 homolog #> 6  Alpha-2-macroglobulin;Alpha-2-macroglobulin 165 kDa subunit;Alpha-2-macroglobulin 35 kDa subunit #> 7                                                          Uncharacterized protein C15orf52 homolog #> 8                                                                  UPF0364 protein C6orf211 homolog #> 9                                                                                            Aladin #> 10                                                                       Acetoacetyl-CoA synthetase #>       Gene.names #> 1  4931429I11Rik #> 2  4932418E24Rik #> 3  9230110C19Rik #> 4                #> 5                #> 6            A2m #> 7                #> 8                #> 9           Aaas #> 10          Aacs #>                                                                                                      Fasta.headers #> 1                                                    >E9Q793 Jhy protein OS=Mus musculus OX=10090 GN=Jhy PE=1 SV=1 #> 2                  >Q8C5V8 Coiled-coil domain-containing protein 187 OS=Mus musculus OX=10090 GN=Ccdc187 PE=2 SV=1 #> 3                 >Q8CC70 Cilia- and flagella-associated protein 300 OS=Mus musculus OX=10090 GN=Cfap300 PE=2 SV=1 #> 4  >A0A0B4J1G0 Low affinity immunoglobulin gamma Fc region receptor IV OS=Mus musculus OX=10090 GN=Fcgr4 PE=1 SV=1 #> 5                           >A2AG58 BCLAF1 and THRAP3 family member 3 OS=Mus musculus OX=10090 GN=Bclaf3 PE=1 SV=1 #> 6                                         >Q61838 Pregnancy zone protein OS=Mus musculus OX=10090 GN=Pzp PE=1 SV=3 #> 7                    >A3KGF9 Coiled-coil domain-containing protein 9B OS=Mus musculus OX=10090 GN=Ccdc9b PE=1 SV=1 #> 8                             >A6H630 Damage-control phosphatase ARMT1 OS=Mus musculus OX=10090 GN=Armt1 PE=1 SV=1 #> 9                                                        >P58742 Aladin OS=Mus musculus OX=10090 GN=Aaas PE=1 SV=1 #> 10                                   >Q9D2R0 Acetoacetyl-CoA synthetase OS=Mus musculus OX=10090 GN=Aacs PE=1 SV=1 #>    Number.of.proteins Peptides Razor...unique.peptides Unique.peptides #> 1                   1        7                       7               7 #> 2                   1       15                      15              15 #> 3                   1       14                      14              14 #> 4                   1        3                       3               3 #> 5                   1       10                      10              10 #> 6                   1       58                      58              56 #> 7                   1       14                      14              14 #> 8                   1       15                      15              15 #> 9                   1       12                      12              12 #> 10                  1       20                      20              20 #>    iBAQ.PBS_1 iBAQ.PBS_2 iBAQ.PBS_3 iBAQ.PBS_4 iBAQ.W10_2 iBAQ.W10_4 iBAQ.W2_1 #> 1      770730      31396     600530   73060000     830230   44453000 101360000 #> 2     4431600    5686400    7911100    7356500   10941000   10549000  11432000 #> 3    14583000   14419000   13432000   10295000   18398000   21712000  27832000 #> 4     1371700          0    2541900     214960   15586000    7950500   1476700 #> 5      986190    2576800     925390    1450600   70833000   35955000   1985800 #> 6   499830000  737940000 1818300000  670060000  295580000  368630000 296600000 #> 7    52617000   40555000   54628000   51936000   29640000   30177000  60573000 #> 8    21935000   23175000   25195000   21827000   41439000   36086000  50951000 #> 9    17838000   21573000   27395000   17450000   38805000   28214000  51485000 #> 10   50426000   93386000   68973000   37103000   65184000   87003000 114290000 #>    iBAQ.W2_3 iBAQ.W2_4 iBAQ.W2_5 iBAQ.W4_2 iBAQ.W4_3 iBAQ.W4_4 iBAQ.W4_5 #> 1   64003000  52267000  48484000   1762100    924580   1383500   2082500 #> 2    5231400   6075000   4720600  19217000  19552000  14223000  16121000 #> 3   16129000  16620000  22499000  36050000  29538000  17628000  18354000 #> 4   14318000   8884100   9379500  11780000   3277000  11987000   7910500 #> 5    4812900   2590500   3013700   1383500   1824300   1132000    870670 #> 6  761380000 374630000 249670000 340750000 225400000 500280000 216580000 #> 7   31654000  61950000  53766000  58985000  77566000  36290000  45419000 #> 8   46976000  54470000  49546000  53063000  64049000  72514000  54845000 #> 9   47803000  43782000  39204000  71399000  41772000  44288000  34274000 #> 10 125590000 122650000 118750000 151120000 127440000 141570000  83758000 #>    iBAQ.W6_2 iBAQ.W6_3 iBAQ.W6_4 iBAQ.W6_6 iBAQ.W9_2 iBAQ.W9_4 #> 1    1271700    380510    391260    741790    907870    222640 #> 2   13346000   5071000   4442200   6194200  13517000   8740800 #> 3   19766000  18147000  19754000  27357000  30529000  23216000 #> 4    9806000  11549000  56719000  13334000   9592600  17502000 #> 5    1906800   3721400   1907400   1398100  73530000  37570000 #> 6  356200000 397190000 429730000 393690000 529520000 528520000 #> 7   65303000  27033000  31609000  35756000  27126000  25407000 #> 8   36438000  38266000  30553000  40028000  39247000  67352000 #> 9   40420000  27954000  34855000  32843000  33375000  48230000 #> 10  84367000  89265000  84252000 104790000  43751000 102510000 #>    Only.identified.by.site Reverse Potential.contaminant         ID imputed #> 1                                                            E9Q793    TRUE #> 2                                                            Q8C5V8   FALSE #> 3                                                            Q8CC70   FALSE #> 4                                                        A0A0B4J1G0    TRUE #> 5                                                            A2AG58    TRUE #> 6                                                            Q61838   FALSE #> 7                                                            A3KGF9   FALSE #> 8                                                            A6H630   FALSE #> 9                                                            P58742   FALSE #> 10                                                           Q9D2R0   FALSE #>    num_NAs W10_vs_PBS_CI.L W10_vs_PBS_CI.R W10_vs_PBS_diff W10_vs_PBS_p.adj #> 1        6    -4.483048131     0.931022178    -1.776012976        0.9893567 #> 2        0    -0.592377635     0.597846171     0.002734268        0.9943193 #> 3        0    -0.323212323     0.839310659     0.258049168        0.9915779 #> 4        3     0.637957874     3.409900613     2.023929244        0.9659200 #> 5        3    -1.784762674     2.448961842     0.332099584        0.9935751 #> 6        0    -2.126200751    -0.616927987    -1.371564369        0.9345667 #> 7        0    -0.983815632    -0.001594425    -0.492705029        0.9833366 #> 8        0     0.005283889     0.667559841     0.336421865        0.9830344 #> 9        0    -0.102208905     0.752516398     0.325153747        0.9879197 #> 10       0     0.124693499     0.830942120     0.477817809        0.9715452 #>    W10_vs_PBS_p.val W10_vs_PBS_t.stastic W2_vs_PBS_CI.L W2_vs_PBS_CI.R #> 1       0.183605084         -1.388686131    -0.93754041      3.4830295 #> 2       0.992358596          0.009725103    -1.27241072     -0.3005971 #> 3       0.361090316          0.939686032    -0.57274463      0.3764514 #> 4       0.006888739          3.090956733    -0.20117708      2.0621047 #> 5       0.744067529          0.332068432    -0.57600225      2.8808193 #> 6       0.001380892         -3.847071999    -2.10630022     -0.8739842 #> 7       0.049343170         -2.123535584    -1.09723720     -0.2952569 #> 8       0.046847156          2.150438780    -0.09009276      0.4506533 #> 9       0.126486871          1.610438174    -0.11335291      0.5845274 #> 10      0.011087299          2.864089431     0.07408847      0.6507381 #>    W2_vs_PBS_diff W2_vs_PBS_p.adj W2_vs_PBS_p.val W2_vs_PBS_t.stastic #> 1      1.27274454       0.9746468    2.402457e-01           1.2188348 #> 2     -0.78650389       0.9149317    3.385014e-03          -3.4260975 #> 3     -0.09814661       0.9813451    6.673280e-01          -0.4377249 #> 4      0.93046380       0.9677531    1.006268e-01           1.7403745 #> 5      1.15240855       0.9723870    1.769581e-01           1.4112741 #> 6     -1.49014219       0.7265995    9.714713e-05          -5.1190275 #> 7     -0.69624707       0.8996252    1.991209e-03          -3.6752049 #> 8      0.18028026       0.9723860    1.769342e-01           1.4113563 #> 9      0.23558723       0.9721627    1.718612e-01           1.4290673 #> 10     0.36241326       0.9471235    1.689648e-02           2.6605655 #>    W4_vs_PBS_CI.L W4_vs_PBS_CI.R W4_vs_PBS_diff W4_vs_PBS_p.adj W4_vs_PBS_p.val #> 1    -1.483282456      2.9372874      0.7270025       0.9862680    4.961023e-01 #> 2    -0.219818561      0.7519951      0.2660883       0.9829668    2.631035e-01 #> 3    -0.221831081      0.7273650      0.2527669       0.9832323    2.759232e-01 #> 4    -0.308296912      1.9549849      0.8233440       0.9792178    1.427358e-01 #> 5    -2.041812442      1.4150091     -0.3134016       0.9879364    7.060839e-01 #> 6    -2.434783663     -1.2024676     -1.8186256       0.4209380    1.068546e-05 #> 7    -1.093917709     -0.2919375     -0.6929276       0.9106033    2.066958e-03 #> 8     0.049862647      0.5906087      0.3202357       0.9623430    2.311004e-02 #> 9    -0.003004205      0.6948761      0.3459359       0.9711607    5.178081e-02 #> 10   -0.132655769      0.4439938      0.1556690       0.9831038    2.696210e-01 #>    W4_vs_PBS_t.stastic W6_vs_PBS_CI.L W6_vs_PBS_CI.R W6_vs_PBS_diff #> 1            0.6962088    -4.85639066     -0.4358208     -2.6461057 #> 2            1.1591098    -0.83524036      0.1365733     -0.3493335 #> 3            1.1273174    -0.22712111      0.7220749      0.2474769 #> 4            1.5400135     0.41881151      2.6820933      1.5504524 #> 5           -0.3838011    -1.30115300      2.1556686      0.4272578 #> 6           -6.2474539    -1.90372843     -0.6714124     -1.2875704 #> 7           -3.6576827    -1.28187668     -0.4798964     -0.8808866 #> 8            2.5070224     0.17001235      0.7107584      0.4403854 #> 9            2.0984402    -0.08168201      0.6161983      0.2672581 #> 10           1.1428048     0.06033873      0.6369883      0.3486635 #>    W6_vs_PBS_p.adj W6_vs_PBS_p.val W6_vs_PBS_t.stastic W9_vs_PBS_CI.L #> 1        0.9752893    0.0218790438          -2.5340243    -5.02371683 #> 2        0.9852016    0.1472291829          -1.5217353    -0.80884175 #> 3        0.9876437    0.2857340175           1.1037243    -0.67790203 #> 4        0.9694513    0.0102861922           2.9000245     0.36904631 #> 5        0.9900946    0.6078496489           0.5232327    -2.89649630 #> 6        0.9149359    0.0004084331          -4.4231405    -1.82565103 #> 7        0.8993172    0.0002544939          -4.6498416    -1.30030071 #> 8        0.9569433    0.0032333508           3.4476358    -0.04434635 #> 9        0.9845116    0.1241516312           1.6211823    -0.04772833 #> 10       0.9749315    0.0207696861           2.5596252    -0.74012367 #>    W9_vs_PBS_CI.R W9_vs_PBS_diff W9_vs_PBS_p.adj W9_vs_PBS_p.val #> 1      0.39035348    -2.31668167       0.9209222     0.088530728 #> 2      0.38138205    -0.21372985       0.9536745     0.457995552 #> 3      0.48462095    -0.09664054       0.9609172     0.729407318 #> 4      3.14098905     1.75501768       0.8644724     0.016225666 #> 5      1.33722821    -0.77963405       0.9532747     0.446816408 #> 6     -0.31637826    -1.07101465       0.8315420     0.008271400 #> 7     -0.31807950    -0.80919010       0.7879762     0.002969802 #> 8      0.61792960     0.28679163       0.9199272     0.085092831 #> 9      0.80699697     0.37963432       0.9177157     0.078055722 #> 10    -0.03387504    -0.38699936       0.8926160     0.033632498 #>    W9_vs_PBS_t.stastic W10_vs_PBS_significant W2_vs_PBS_significant #> 1           -1.8114416                  FALSE                 FALSE #> 2           -0.7601834                  FALSE                 FALSE #> 3           -0.3519165                  FALSE                 FALSE #> 4            2.6802734                  FALSE                 FALSE #> 5           -0.7795609                  FALSE                 FALSE #> 6           -3.0040664                  FALSE                 FALSE #> 7           -3.4875714                  FALSE                 FALSE #> 8            1.8331978                  FALSE                 FALSE #> 9            1.8802723                  FALSE                 FALSE #> 10          -2.3197142                  FALSE                 FALSE #>    W4_vs_PBS_significant W6_vs_PBS_significant W9_vs_PBS_significant #> 1                  FALSE                 FALSE                 FALSE #> 2                  FALSE                 FALSE                 FALSE #> 3                  FALSE                 FALSE                 FALSE #> 4                  FALSE                 FALSE                 FALSE #> 5                  FALSE                 FALSE                 FALSE #> 6                  FALSE                 FALSE                 FALSE #> 7                  FALSE                 FALSE                 FALSE #> 8                  FALSE                 FALSE                 FALSE #> 9                  FALSE                 FALSE                 FALSE #> 10                 FALSE                 FALSE                 FALSE #>    significant #> 1        FALSE #> 2        FALSE #> 3        FALSE #> 4        FALSE #> 5        FALSE #> 6        FALSE #> 7        FALSE #> 8        FALSE #> 9        FALSE #> 10       FALSE #>  [ reached 'max' / getOption(\"max.print\") -- omitted 8752 rows ]"},{"path":"/reference/get_exdesign_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct experiment design basic on colnames parse — get_exdesign_parse","title":"Construct experiment design basic on colnames parse — get_exdesign_parse","text":"Construct experiment design basic colnames parse","code":""},{"path":"/reference/get_exdesign_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct experiment design basic on colnames parse — get_exdesign_parse","text":"","code":"get_exdesign_parse(   label,   mode = c(\"delim\", \"char\"),   chars = 1,   sep = \"_\",   remove_prefix = TRUE,   remove_suffix = FALSE )"},{"path":"/reference/get_exdesign_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct experiment design basic on colnames parse — get_exdesign_parse","text":"label Characters, label names(column names) assay mode one \"delim\", \"char\" chars Integer(1). mode \"char\", many chars end label 'replicate' sep Character(1). mode \"sep\", many chars end label 'replicate'","code":""},{"path":"/reference/get_exdesign_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct experiment design basic on colnames parse — get_exdesign_parse","text":"data.frame contain four columns: label,ID,condition,replicate","code":""},{"path":"/reference/get_exdesign_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct experiment design basic on colnames parse — get_exdesign_parse","text":"","code":"## Parse on delim samples = c(\"Quantity.A_1\",\"Quantity.A_2\",\"Quantity.A_3\",\"Quantity.B_1\",\"Quantity.B_2\",\"Quantity.B_3\",             \"Quantity.C_1\",\"Quantity.C_2\") get_exdesign_parse(samples, mode = \"delim\", sep = \"_\") #>   label  ID condition replicate #> 1   A_1 A_1         A         1 #> 2   A_2 A_2         A         2 #> 3   A_3 A_3         A         3 #> 4   B_1 B_1         B         1 #> 5   B_2 B_2         B         2 #> 6   B_3 B_3         B         3 #> 7   C_1 C_1         C         1 #> 8   C_2 C_2         C         2  ## Parse on certain character samples = c(\"Quantity.A1\",\"Quantity.A2\",\"Quantity.A3\",\"Quantity.B1\",\"Quantity.B2\",\"Quantity.B3\",             \"Quantity.C1\",\"Quantity.C2\") get_exdesign_parse(samples, mode = \"char\", chars = 1) #>   label ID condition replicate #> 1    A1 A1         A         1 #> 2    A2 A2         A         2 #> 3    A3 A3         A         3 #> 4    B1 B1         B         1 #> 5    B2 B2         B         2 #> 6    B3 B3         B         3 #> 7    C1 C1         C         1 #> 8    C2 C2         C         2 # Reserve prefix get_exdesign_parse(samples, mode = \"char\", chars = 1, remove_prefix = FALSE) #>         label          ID  condition replicate #> 1 Quantity.A1 Quantity.A1 Quantity.A         1 #> 2 Quantity.A2 Quantity.A2 Quantity.A         2 #> 3 Quantity.A3 Quantity.A3 Quantity.A         3 #> 4 Quantity.B1 Quantity.B1 Quantity.B         1 #> 5 Quantity.B2 Quantity.B2 Quantity.B         2 #> 6 Quantity.B3 Quantity.B3 Quantity.B         3 #> 7 Quantity.C1 Quantity.C1 Quantity.C         1 #> 8 Quantity.C2 Quantity.C2 Quantity.C         2"},{"path":"/reference/get_prefix.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the longest common prefix — get_prefix","title":"Obtain the longest common prefix — get_prefix","text":"get_prefix returns longest common prefix supplied words.","code":""},{"path":"/reference/get_prefix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the longest common prefix — get_prefix","text":"","code":"get_prefix(words)"},{"path":"/reference/get_prefix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the longest common prefix — get_prefix","text":"words Character vector, list words.","code":""},{"path":"/reference/get_prefix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the longest common prefix — get_prefix","text":"character vector containing prefix.","code":""},{"path":"/reference/get_prefix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain the longest common prefix — get_prefix","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg names <- grep(\"LFQ.\", colnames(data), value = TRUE)  # Get prefix get_prefix(names) #> [1] \"LFQ.intensity.\""},{"path":"/reference/get_results.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a results table — get_results","title":"Generate a results table — get_results","text":"get_results generates results table proteomics RNA-seq dataset differential analysis performed.","code":""},{"path":"/reference/get_results.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a results table — get_results","text":"","code":"get_results(object)"},{"path":"/reference/get_results.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a results table — get_results","text":"object SummarizedExperiment DEGdata, (output test_diff() add_rejections()).","code":""},{"path":"/reference/get_results.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a results table — get_results","text":"data.frame object containing results variables performed analysis.","code":""},{"path":"/reference/get_results.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a results table — get_results","text":"","code":"#Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Loading required namespace: imputeLCMD #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Storey's qvalue dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # Get results results <- get_results(dep) colnames(results) #>  [1] \"name\"                   \"ID\"                     \"W10_vs_PBS_p.val\"       #>  [4] \"W2_vs_PBS_p.val\"        \"W4_vs_PBS_p.val\"        \"W6_vs_PBS_p.val\"        #>  [7] \"W9_vs_PBS_p.val\"        \"W10_vs_PBS_p.adj\"       \"W2_vs_PBS_p.adj\"        #> [10] \"W4_vs_PBS_p.adj\"        \"W6_vs_PBS_p.adj\"        \"W9_vs_PBS_p.adj\"        #> [13] \"W10_vs_PBS_significant\" \"W2_vs_PBS_significant\"  \"W4_vs_PBS_significant\"  #> [16] \"W6_vs_PBS_significant\"  \"W9_vs_PBS_significant\"  \"significant\"            #> [19] \"W10_vs_PBS_ratio\"       \"W2_vs_PBS_ratio\"        \"W4_vs_PBS_ratio\"        #> [22] \"W6_vs_PBS_ratio\"        \"W9_vs_PBS_ratio\"        \"PBS_centered\"           #> [25] \"W10_centered\"           \"W2_centered\"            \"W4_centered\"            #> [28] \"W6_centered\"            \"W9_centered\"             significant_proteins <- results[results$significant,] head(significant_proteins) #>      name     ID W10_vs_PBS_p.val W2_vs_PBS_p.val W4_vs_PBS_p.val #> 1    Acp5 Q05117     1.413893e-05    5.916082e-04    4.781613e-03 #> 2 Adamts8 P57110     1.264208e-01    1.630952e-02    5.435045e-03 #> 3    Add2 Q9QYB8     5.684352e-04    6.423988e-03    5.974924e-04 #> 4    Aif1 O70200     4.834777e-06    6.703915e-08    1.397456e-07 #> 5  Alox12 P39655     3.540750e-03    3.934187e-03    4.800876e-03 #> 6    Ank1 Q02357     2.103406e-04    4.831900e-04    1.667553e-05 #>   W6_vs_PBS_p.val W9_vs_PBS_p.val W10_vs_PBS_p.adj W2_vs_PBS_p.adj #> 1    2.102090e-04    3.199034e-04         0.000688        2.49e-03 #> 2    2.474531e-04    3.640314e-03         0.130000        2.38e-02 #> 3    1.345145e-03    1.086495e-02         0.005150        1.24e-02 #> 4    4.065564e-06    2.651799e-04         0.000404        1.04e-05 #> 5    1.478697e-04    5.413181e-03         0.013600        8.80e-03 #> 6    7.321580e-05    7.962502e-05         0.002970        2.16e-03 #>   W4_vs_PBS_p.adj W6_vs_PBS_p.adj W9_vs_PBS_p.adj W10_vs_PBS_significant #> 1        1.27e-02        0.001180         0.00292                   TRUE #> 2        1.37e-02        0.001300         0.01200                  FALSE #> 3        3.63e-03        0.003830         0.02420                   TRUE #> 4        3.05e-05        0.000118         0.00261                   TRUE #> 5        1.27e-02        0.000930         0.01530                  FALSE #> 6        4.65e-04        0.000609         0.00137                   TRUE #>   W2_vs_PBS_significant W4_vs_PBS_significant W6_vs_PBS_significant #> 1                 FALSE                 FALSE                 FALSE #> 2                 FALSE                 FALSE                  TRUE #> 3                 FALSE                  TRUE                 FALSE #> 4                  TRUE                  TRUE                  TRUE #> 5                 FALSE                 FALSE                  TRUE #> 6                 FALSE                  TRUE                  TRUE #>   W9_vs_PBS_significant significant W10_vs_PBS_ratio W2_vs_PBS_ratio #> 1                 FALSE        TRUE             2.26            1.29 #> 2                 FALSE        TRUE             1.49            2.01 #> 3                 FALSE        TRUE            -2.56           -1.53 #> 4                 FALSE        TRUE             2.85            3.21 #> 5                 FALSE        TRUE            -1.80           -1.45 #> 6                  TRUE        TRUE            -2.35           -1.76 #>   W4_vs_PBS_ratio W6_vs_PBS_ratio W9_vs_PBS_ratio PBS_centered W10_centered #> 1           0.994            1.44            1.69        -1.14        1.120 #> 2           2.410            3.50            3.12        -2.04       -0.559 #> 3          -2.080           -1.89           -1.73         1.53       -1.030 #> 4           3.050            2.36            1.98        -2.21        0.640 #> 5          -1.410           -2.12           -1.70         1.35       -0.457 #> 6          -2.420           -2.12           -2.58         1.75       -0.593 #>   W2_centered W4_centered W6_centered W9_centered #> 1     0.15100     -0.1470       0.300       0.549 #> 2    -0.03040      0.3630       1.450       1.080 #> 3    -0.00365     -0.5480      -0.362      -0.198 #> 4     1.01000      0.8410       0.151      -0.226 #> 5    -0.10500     -0.0643      -0.773      -0.351 #> 6    -0.00249     -0.6710      -0.370      -0.826"},{"path":"/reference/get_signicant.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","title":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","text":"Extract significant candidates SummarizedExperiment DEGdata","code":""},{"path":"/reference/get_signicant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","text":"","code":"get_signicant(   object,   contrasts = NULL,   thresholdmethod = NULL,   diff = diff,   alpha = alpha,   curvature = 1,   x0_fold = 2,   return_type = c(\"subset\", \"table\", \"names\") )"},{"path":"/reference/get_signicant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","text":"object SummarizedExperiment DEGdata object. contrasts NULL contrasts object. thresholdmethod NULL 'intersect' 'curve'. thresholdmethod decide significant. NULL, used existing rejections. Otherwise filter new rejections via add_rejections(). alpha Numeric(1), Sets threshold adjusted P value. curvature Numeric(1), Sets curvature curve cutoff lines x0_fold Numeric(1), decide x0 ratio standard deviations L2FC. x0 usually set 1(medium confidence) 2(high confidence) standard deviations. return_type One \"subset\", \"table\", \"names\". \"subset\" return subset object, \"table\" return result data.frame, names return name vector object.","code":""},{"path":"/reference/get_signicant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","text":"object class input data.frame names vector, designed return_type.","code":""},{"path":"/reference/get_signicant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract significant candidates from SummarizedExperiment or DEGdata — get_signicant","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Storey's qvalue dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # Signicant subset (sig <- get_signicant(dep)) #> class: SummarizedExperiment  #> dim: 243 20  #> metadata(0): #> assays(1): '' #> rownames(243): Acp5 Adamts8 ... Ywhab Zbp1 #> rowData names(75): name Protein.IDs ... W9_vs_PBS_significant #>   significant #> colnames(20): PBS_1 PBS_2 ... W9_2 W9_4 #> colData names(4): label ID condition replicate  # Given threshold (sig <- get_signicant(dep, contrast = \"W4_vs_PBS\", alpha = 0.001, diff = 2)) #> class: SummarizedExperiment  #> dim: 70 20  #> metadata(0): #> assays(1): '' #> rownames(70): Add2 Aif1 ... Treml1 Zbp1 #> rowData names(75): name Protein.IDs ... W9_vs_PBS_significant #>   significant #> colnames(20): PBS_1 PBS_2 ... W9_2 W9_4 #> colData names(4): label ID condition replicate  # In table format sig_df <- get_signicant(dep, return_type = \"table\") head(sig_df) #>      name     ID W10_vs_PBS_p.val W2_vs_PBS_p.val W4_vs_PBS_p.val #> 1    Acp5 Q05117     1.409433e-05    5.904610e-04    4.775371e-03 #> 2 Adamts8 P57110     1.054905e-01    1.381397e-02    5.099421e-03 #> 3    Add2 Q9QYB8     7.289665e-04    8.558660e-03    1.777857e-04 #> 4    Aif1 O70200     1.943500e-05    2.674632e-07    5.954789e-07 #> 5  Alox12 P39655     3.535050e-03    3.927989e-03    4.793624e-03 #> 6    Ank1 Q02357     2.098108e-04    4.821090e-04    1.661891e-05 #>   W6_vs_PBS_p.val W9_vs_PBS_p.val W10_vs_PBS_p.adj W2_vs_PBS_p.adj #> 1    2.097325e-04    3.192211e-04         0.000693        2.42e-03 #> 2    1.774090e-04    3.190231e-03         0.113000        2.06e-02 #> 3    1.016901e-03    1.561274e-02         0.005730        1.48e-02 #> 4    2.348426e-05    1.360582e-03         0.000809        2.03e-05 #> 5    1.474733e-04    5.405215e-03         0.013400        8.53e-03 #> 6    7.300489e-05    7.939796e-05         0.002920        2.10e-03 #>   W4_vs_PBS_p.adj W6_vs_PBS_p.adj W9_vs_PBS_p.adj W10_vs_PBS_significant #> 1        1.30e-02        0.001110         0.00282                   TRUE #> 2        1.36e-02        0.000993         0.01070                  FALSE #> 3        1.76e-03        0.002940         0.02950                   TRUE #> 4        5.89e-05        0.000290         0.00642                   TRUE #> 5        1.30e-02        0.000881         0.01480                  FALSE #> 6        4.76e-04        0.000576         0.00130                   TRUE #>   W2_vs_PBS_significant W4_vs_PBS_significant W6_vs_PBS_significant #> 1                 FALSE                 FALSE                 FALSE #> 2                 FALSE                 FALSE                  TRUE #> 3                 FALSE                  TRUE                 FALSE #> 4                  TRUE                  TRUE                 FALSE #> 5                 FALSE                 FALSE                  TRUE #> 6                 FALSE                  TRUE                  TRUE #>   W9_vs_PBS_significant significant W10_vs_PBS_ratio W2_vs_PBS_ratio #> 1                 FALSE        TRUE             2.26            1.29 #> 2                 FALSE        TRUE             1.35            1.78 #> 3                 FALSE        TRUE            -2.40           -1.41 #> 4                 FALSE        TRUE             2.49            2.85 #> 5                 FALSE        TRUE            -1.80           -1.45 #> 6                  TRUE        TRUE            -2.35           -1.76 #>   W4_vs_PBS_ratio W6_vs_PBS_ratio W9_vs_PBS_ratio PBS_centered W10_centered #> 1           0.994            1.44            1.69        -1.14        1.120 #> 2           2.080            3.10            2.72        -1.80       -0.445 #> 3          -2.270           -1.88           -1.56         1.51       -0.888 #> 4           2.690            2.00            1.62        -1.92        0.568 #> 5          -1.410           -2.12           -1.70         1.35       -0.457 #> 6          -2.420           -2.12           -2.58         1.75       -0.593 #>   W2_centered W4_centered W6_centered W9_centered #> 1     0.15100     -0.1470      0.3000      0.5490 #> 2    -0.02210      0.2830      1.3000      0.9240 #> 3     0.09770     -0.7640     -0.3740     -0.0532 #> 4     0.93400      0.7690      0.0787     -0.2980 #> 5    -0.10500     -0.0643     -0.7730     -0.3510 #> 6    -0.00249     -0.6710     -0.3700     -0.8260"},{"path":"/reference/get_suffix.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain the longest common suffix — get_suffix","title":"Obtain the longest common suffix — get_suffix","text":"get_suffix returns longest common suffix supplied words.","code":""},{"path":"/reference/get_suffix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain the longest common suffix — get_suffix","text":"","code":"get_suffix(words)"},{"path":"/reference/get_suffix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain the longest common suffix — get_suffix","text":"words Character vector, list words.","code":""},{"path":"/reference/get_suffix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain the longest common suffix — get_suffix","text":"character vector containing suffix","code":""},{"path":"/reference/get_suffix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain the longest common suffix — get_suffix","text":"","code":"# Get suffix names <- c(\"xyz_rep\", \"abc_rep\") get_suffix(names) #> [1] \"_rep\""},{"path":"/reference/get_tc_cluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-course clustering — get_tc_cluster","title":"Time-course clustering — get_tc_cluster","text":"Expression pattern clustering timecourse multi-group experiment via timeclust()","code":""},{"path":"/reference/get_tc_cluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-course clustering — get_tc_cluster","text":"","code":"get_tc_cluster(   x,   ht_mat,   exp_design,   groupby = \"condition\",   group_order = NULL,   k = 6,   dist = \"euclidean\",   color = c(\"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\",     \"Spectral\"),   col_limit = 4,   row_font_size = 5,   col_font_size = 5,   heatmap_width = 3,   heatmap_height = 5,   seed = NULL )"},{"path":"/reference/get_tc_cluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-course clustering — get_tc_cluster","text":"x SummarizedExperiment DEGdata object. ht_mat Data.frame matrix, expresiong assay. x provided, reset assay(x). exp_design Data.frame, experiment design. x provided, reset colData(x) groupby Character(1), group column experiment design. group_order Character vector factor, order groups groupby column. k Integer(1), number clusters. color Character(1), sets color panel (RColorBrewer). can palette name \"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\", \"Spectral\". col_limit Numeric(1), sets outer limits color scale. row_font_size Integer(1), font size row name col_font_size Integer(1), font size columns label. heatmap_width Numeric(1) heatmap_height Numeric(1) seed Integer(1) NULL, random seed.","code":""},{"path":"/reference/get_tc_cluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-course clustering — get_tc_cluster","text":"list contains: cluster heatmap(Heatmap object ComplexHeatmap), cluster result heatmap(data.frame), output timeclust seed.","code":""},{"path":"/reference/get_tc_cluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-course clustering — get_tc_cluster","text":"","code":"# Load sample data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  filt <- filter_se(se, thr = 0, fraction = 0.3, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8832 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026538 diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff)  # Expression pattern cluster TC <- get_tc_cluster(get_signicant(dep),                      group_order = c(\"PBS\",\"W2\",\"W4\",\"W6\",\"W9\",\"W10\"), # set the group order                      heatmap_width = 2.5, heatmap_height = 5 ) #> aabb[1] \"start timeclust\" #> beging 'cm' cluster by dist = 'euclidean' #> [1] \"finish heatmap\" TC$ht # Heatmap  head(TC$res) #>          name Timecourse_cluster         mebership              PBS_1 #> Ca2       Ca2                  1 0.329063383475686   1.69065263119242 #> Cldn18 Cldn18                  4 0.553121137926746   1.23958646631143 #> Creb1   Creb1                  1 0.326312557758223  0.136487390098118 #> Dhx58   Dhx58                  2  0.81902259749771  -2.06544095513807 #> Dnmt3a Dnmt3a                  5 0.597688777916992 -0.904896251325489 #> Efemp2 Efemp2                  2 0.462700530759487 -0.930272399356138 #>                     PBS_2               PBS_3              PBS_4 #> Ca2      1.41759313041917    1.21867872572312  0.871398543111233 #> Cldn18   1.14834276230686    1.17683392038859  0.649627636229976 #> Creb1  0.0467783130732933 -0.0684995222221971  0.263004266377287 #> Dhx58   -1.96084347617414   -2.93920556318203   -3.1943284449183 #> Dnmt3a -0.939565872453979   -1.17776444420126 -0.906231190648125 #> Efemp2 -0.605958902335448   -1.08561736048544 -0.812065013310434 #>                      W2_1               W2_3                W2_4 #> Ca2     0.098613225762044 0.0159171430763649 -0.0158498148229711 #> Cldn18 -0.360596970057859  -0.47187623920922    -0.4255120562602 #> Creb1   0.539337458007282  0.701506484535862   0.901503283103786 #> Dhx58   0.746457200193323   1.24456979871951   0.821772070624508 #> Dnmt3a  0.783357254120432   1.08808001389562   0.868693353844201 #> Efemp2  -0.15358956170402  0.174213060034393   0.249851981034421 #>                      W2_5                W4_2               W4_3 #> Ca2     0.100742763687713   -0.37424848888098 -0.119820470177196 #> Cldn18 -0.288477991839169   0.330153178862002  0.239899871574369 #> Creb1   0.557541990037336   0.365962761537745  0.125169868503782 #> Dhx58    1.03333640641943    1.13127573675511  0.192532251407595 #> Dnmt3a  0.749978466197163   0.583297318826038 -0.395325255498001 #> Efemp2  0.214905350869383 0.00808615857910056 -0.244696885643624 #>                      W4_4                W4_5                W6_2 #> Ca2    -0.181299577487948 -0.0116517269610839  -0.460001709658762 #> Cldn18  0.199424707360595   0.567415080217049  -0.619790712033538 #> Creb1   0.502401723735161   0.433261249125621   -0.25721959379948 #> Dhx58   0.716047237780469 0.00185594051893645   0.123212926214716 #> Dnmt3a  0.277692440227106  -0.312137949657195 -0.0517147839181824 #> Efemp2 0.0411470168599486  -0.173965660789197   0.363980847906301 #>                       W6_3                W6_4               W6_6 #> Ca2     -0.530563532665759  -0.776238614295806 -0.539418285530573 #> Cldn18  -0.783321687943666  -0.794706626067534 -0.405821220765933 #> Creb1  -0.0459444624686149 -0.0892369439907519  0.281828507675655 #> Dhx58    0.734945929150886   0.642967460601366  0.555262089321882 #> Dnmt3a   0.477148540207022   0.228572037733063  0.393591813383914 #> Efemp2  0.0413562665920004    0.50074823953592  0.342584869825163 #>                      W9_2                W9_4               W10_2 #> Ca2    -0.163821633610759  -0.476498689126373  -0.713390780262202 #> Cldn18 -0.129757499196334 -0.0287980472910228  -0.414560565381205 #> Creb1   -3.05293888550846   -1.61561760717282   0.323729726334115 #> Dhx58   0.393764307310281   0.481596331711717   0.840155068871187 #> Dnmt3a -0.439023661513279   -0.22878860702064 -0.0366646751473709 #> Efemp2  0.925971985604367   0.835542242088724   0.115609350582677 #>                      W10_4 #> Ca2      -1.05079283949163 #> Cldn18  -0.828064007205182 #> Creb1  -0.0490560069827133 #> Dhx58    0.500067683811611 #> Dnmt3a -0.0582985470510273 #> Efemp2   0.192168414111929"},{"path":"/reference/impute.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute missing values — impute","title":"Impute missing values — impute","text":"impute imputes missing values proteomics dataset.","code":""},{"path":"/reference/impute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute missing values — impute","text":"","code":"impute(   se,   fun = c(\"QRILC\", \"bpca\", \"knn\", \"MLE\", \"MinDet\", \"MinProb\", \"man\", \"min\", \"zero\",     \"mixed\", \"nbavg\", \"RF\", \"GSimp\"),   ... )"},{"path":"/reference/impute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute missing values — impute","text":"se SummarizedExperiment, Proteomics data (output make_se() make_se_parse()). adviced first remove proteins many missing values using filter_se() normalize data using normalize_vsn(). fun \"bpca\", \"knn\", \"QRILC\", \"MLE\", \"MinDet\", \"MinProb\", \"man\", \"min\", \"zero\", \"mixed\", \"nbavg\", \"GSimp\" \"RF\", Function used data imputation based manual_impute(\"man\") , impute,MSnSet-method missForest(\"RF\"). ... Additional arguments imputation functions depicted manual_impute, missForest impute_matrix.","code":""},{"path":"/reference/impute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute missing values — impute","text":"imputed SummarizedExperiment object.","code":""},{"path":"/reference/impute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute missing values — impute","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit.  # Impute missing values using different functions imputed_MinProb <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 imputed_manual <- impute(norm, fun = \"man\", shift = 1.8, scale = 0.3)  imputed_QRILC <- impute(norm, fun = \"QRILC\") #> Imputing along margin 2 (samples/columns). imputed_knn <- impute(norm, fun = \"knn\", k = 10, rowmax = 0.9) #> Imputing along margin 1 (features/rows). #> Cluster size 8762 broken into 7012 1750  #> Cluster size 7012 broken into 2751 4261  #> Cluster size 2751 broken into 1861 890  #> Cluster size 1861 broken into 825 1036  #> Done cluster 825  #> Done cluster 1036  #> Done cluster 1861  #> Done cluster 890  #> Done cluster 2751  #> Cluster size 4261 broken into 1832 2429  #> Cluster size 1832 broken into 757 1075  #> Done cluster 757  #> Done cluster 1075  #> Done cluster 1832  #> Cluster size 2429 broken into 1236 1193  #> Done cluster 1236  #> Done cluster 1193  #> Done cluster 2429  #> Done cluster 4261  #> Done cluster 7012  #> Cluster size 1750 broken into 1139 611  #> Done cluster 1139  #> Done cluster 611  #> Done cluster 1750   if (FALSE) { imputed_MLE <- impute(norm, fun = \"MLE\")  imputed_RF <- impute(norm, fun = \"RF\") # may take several minutes. }"},{"path":"/reference/impute_pe.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute a QFeatures object — impute_pe","title":"Impute a QFeatures object — impute_pe","text":"Impute assay QFeatures object though impute function. normalized assay saved name assay.","code":""},{"path":"/reference/impute_pe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute a QFeatures object — impute_pe","text":"","code":"impute_pe(   pe,   fun = c(\"QRILC\", \"bpca\", \"knn\", \"MLE\", \"MinDet\", \"MinProb\", \"man\", \"min\", \"zero\",     \"mixed\", \"nbavg\", \"RF\", \"GSimp\"),   i = \"peptideRaw\",   name = \"peptideImp\",   ... )"},{"path":"/reference/impute_pe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute a QFeatures object — impute_pe","text":"pe QFeature object fun Character(1), imputation strategy, see impute. numeric character giving index name, respectively, assay(s) processed. name Character(1), naming new normalized assay. defaule \"peptideImp\". ... parameters passed impute function.","code":""},{"path":"/reference/impute_pe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute a QFeatures object — impute_pe","text":"QFeatures imputed assay giving name.","code":""},{"path":"/reference/impute_pe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impute a QFeatures object — impute_pe","text":"","code":"if (FALSE) { # Load example peptide data data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)  # Construct QFeature object pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols, remove_prefix = TRUE, log2transform = TRUE,mode = \"delim\")  # Filter, imputation pe <- filter_pe(pe_peptides, thr = 1,fraction = 0.4, filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) pe <- impute_pe(pe, fun = \"QRILC\") }"},{"path":"/reference/load_PPIdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and load a local STRING data. If local file do not exist, will try to download from STRING. — load_PPIdata","title":"Check and load a local STRING data. If local file do not exist, will try to download from STRING. — load_PPIdata","text":"Check load local STRING data. local file exist, try download STRING.","code":""},{"path":"/reference/load_PPIdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and load a local STRING data. If local file do not exist, will try to download from STRING. — load_PPIdata","text":"","code":"load_PPIdata(speciesname, STRING.version = \"11.5\", STRINGdata_path = NULL)"},{"path":"/reference/load_PPIdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and load a local STRING data. If local file do not exist, will try to download from STRING. — load_PPIdata","text":"speciesname Species name. STRING.version character(1), STRING dataset version, default \"11.5\". STRINGdata_path NULL selected path. Recommend NULL.","code":""},{"path":"/reference/load_PPIdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and load a local STRING data. If local file do not exist, will try to download from STRING. — load_PPIdata","text":"","code":"if (FALSE) { # Load STRING data. If local STRING is missing, PPI_res will download to system.file(\"PPIdata\", \"Mouse\",package = \"DEP2\") load_PPIdata(speciesname = \"Mouse\") }"},{"path":"/reference/make_dds.html","id":null,"dir":"Reference","previous_headings":"","what":"Count matrix to DESeqDataSet conversion using an experimental design — make_dds","title":"Count matrix to DESeqDataSet conversion using an experimental design — make_dds","text":"make_dds creates DESeqDataSet object gene counts matrix experimental design table. gene identifiers first column countData.","code":""},{"path":"/reference/make_dds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count matrix to DESeqDataSet conversion using an experimental design — make_dds","text":"","code":"make_dds(countData, expdesign, design = as.formula(~condition))"},{"path":"/reference/make_dds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count matrix to DESeqDataSet conversion using an experimental design — make_dds","text":"countData Gene counts matrix data.frame contain counts data. expdesign Data.frame, Experimental design 'label', 'condition' 'replicate' information. design design formula transmitted DESeqDataSet","code":""},{"path":"/reference/make_dds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count matrix to DESeqDataSet conversion using an experimental design — make_dds","text":"DESeqDataSet object.","code":""},{"path":[]},{"path":"/reference/make_dds_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"make_dds_parse creates DESeqDataSet object gene counts matrix. gene identifiers first column countData.","code":""},{"path":"/reference/make_dds_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"","code":"make_dds_parse(   countData,   mode = c(\"char\", \"delim\"),   chars = 1,   sep = \"_\",   remove_prefix = F,   design = as.formula(~condition) )"},{"path":"/reference/make_dds_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"countData Gene counts matrix data.frame contain counts data. mode \"char\" \"delim\", mode parsing column headers. \"char\" parse last number characters replicate number requires 'chars' parameter. \"delim\" parse separator requires 'sep' parameter. chars Numeric(1), number characters take end column headers replicate number (mode = \"char\"). sep Character(1), separator used parse column header (mode = \"delim\"). remove_prefix remove prefix sample labels. design design formula transmitted DESeqDataSet","code":""},{"path":"/reference/make_dds_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"DESeqDataSet object.","code":""},{"path":"/reference/make_dds_parse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"Column name splitted delim tail character(mode = \"char\"). Detail rule can check get_exdesign_parse)","code":""},{"path":"/reference/make_dds_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count matrix to DESeqDataSet conversion by parsing from column names — make_dds_parse","text":"","code":"if (FALSE) { data(Silicosis_count) colnames(Silicosis_count)  dds = make_dds_parse(Silicosis_count, mode = \"delim\", sep = \"_\") colData(dds) }"},{"path":"/reference/make_pe.html","id":null,"dir":"Reference","previous_headings":"","what":"Data.frame to QFeatures object conversion using an experimental design — make_pe","title":"Data.frame to QFeatures object conversion using an experimental design — make_pe","text":"make_pe creates QFeatures object based two data.frames: peptide table experimental design.","code":""},{"path":"/reference/make_pe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data.frame to QFeatures object conversion using an experimental design — make_pe","text":"","code":"make_pe(   Peptide,   columns,   expdesign,   fnames,   assay_name = \"peptideRaw\",   log2transform = T )"},{"path":"/reference/make_pe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data.frame to QFeatures object conversion using an experimental design — make_pe","text":"Peptide Data.frame, Peptide table belonging proteingroup. columns numeric indicating indices columns used expression values. Can also character indicating names columns. expdesign data.frame. Experimental design 'label', 'condition' 'replicate' information. fnames optional character(1) numeric(1) indicating column identifier. assay_name character(1) name assay QFeatures object. log2transform Logical(1), whether log2 transform assay, default TRUE.","code":""},{"path":"/reference/make_pe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data.frame to QFeatures object conversion using an experimental design — make_pe","text":"QFeatures object peptide assay.","code":""},{"path":"/reference/make_pe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data.frame to QFeatures object conversion using an experimental design — make_pe","text":"","code":"# Load a peptides data(Silicosis_peptide) # Exctract Intensity columns (ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)) #>  [1] \"Intensity.PBS_1\" \"Intensity.PBS_2\" \"Intensity.PBS_3\" \"Intensity.PBS_4\" #>  [5] \"Intensity.W10_2\" \"Intensity.W10_4\" \"Intensity.W2_1\"  \"Intensity.W2_3\"  #>  [9] \"Intensity.W2_4\"  \"Intensity.W2_5\"  \"Intensity.W4_2\"  \"Intensity.W4_3\"  #> [13] \"Intensity.W4_4\"  \"Intensity.W4_5\"  \"Intensity.W6_2\"  \"Intensity.W6_3\"  #> [17] \"Intensity.W6_4\"  \"Intensity.W6_6\"  \"Intensity.W9_2\"  \"Intensity.W9_4\"    # Load experiement design data(Silicosis_ExpDesign) (expDesign = Silicosis_ExpDesign) #>       label    ID condition replicate #> PBS_1 PBS_1 PBS_1       PBS         1 #> PBS_2 PBS_2 PBS_2       PBS         2 #> PBS_3 PBS_3 PBS_3       PBS         3 #> PBS_4 PBS_4 PBS_4       PBS         4 #> W10_2 W10_2 W10_2       W10         2 #> W10_4 W10_4 W10_4       W10         4 #> W2_1   W2_1  W2_1        W2         1 #> W2_3   W2_3  W2_3        W2         3 #> W2_4   W2_4  W2_4        W2         4 #> W2_5   W2_5  W2_5        W2         5 #> W4_2   W4_2  W4_2        W4         2 #> W4_3   W4_3  W4_3        W4         3 #> W4_4   W4_4  W4_4        W4         4 #> W4_5   W4_5  W4_5        W4         5 #> W6_2   W6_2  W6_2        W6         2 #> W6_3   W6_3  W6_3        W6         3 #> W6_4   W6_4  W6_4        W6         4 #> W6_6   W6_6  W6_6        W6         6 #> W9_2   W9_2  W9_2        W9         2 #> W9_4   W9_4  W9_4        W9         4  # Construct a QFeatures object, with a 'peptideRaw' assay pe_peptides <- make_pe(Silicosis_peptide, columns = ecols,   # columns is the abundance columns                        expdesign = expDesign) # log2transform pe_peptides # a QFeatures object, with a peptideRaw assay #> An instance of class QFeatures containing 1 assays: #>  [1] peptideRaw: SummarizedExperiment with 143528 rows and 20 columns"},{"path":"/reference/make_pe_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","title":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","text":"make_pe_parse creates QFeatures object based single data.frame. experiment design constructed colnames expression assay.","code":""},{"path":"/reference/make_pe_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","text":"","code":"make_pe_parse(   Peptide,   columns,   fnames,   mode = c(\"char\", \"delim\"),   chars = 1,   sep = \"_\",   remove_prefix = T,   remove_suffix = F,   assay_name = \"peptideRaw\",   log2transform = T )"},{"path":"/reference/make_pe_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","text":"Peptide Data.frame, Peptide table belonging proteingroup. columns numeric indicating indices columns used expression values. Can also character indicating names columns. fnames optional character(1) numeric(1) indicating column identifier. mode \"char\" \"delim\", mode parsing column headers. \"char\" parse last number characters replicate number requires 'chars' parameter. \"delim\" parse separator requires 'sep' parameter. chars Numeric(1), number characters take end column headers replicate number (mode = \"char\"). sep Character(1), separator used parse column header (mode = \"delim\"). remove_prefix Logical(1), whether remove prefix expression columns. remove_suffix Logical(1), whether remove suffix expression columns. assay_name character(1) name assay QFeatures object. log2transform Logical(1), whether log2 transform assay, default TRUE.","code":""},{"path":"/reference/make_pe_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","text":"character(1) name assay QFeatures object.","code":""},{"path":"/reference/make_pe_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data.frame to QFeatures object conversion by parsing column names — make_pe_parse","text":"","code":"# Load a peptides data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE) # Construct a QFeatures object, with a 'peptideRaw' assay pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols,   # columns is the abundance columns                              mode = \"delim\", sep = \"_\",                              remove_prefix = TRUE, log2transform = TRUE) pe_peptides #> An instance of class QFeatures containing 1 assays: #>  [1] peptideRaw: SummarizedExperiment with 143528 rows and 20 columns"},{"path":"/reference/make_se.html","id":null,"dir":"Reference","previous_headings":"","what":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","title":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","text":"make_se creates SummarizedExperiment object based two data.frames: protein table experimental design.","code":""},{"path":"/reference/make_se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","text":"","code":"make_se(proteins_unique, columns, expdesign, log2transform = TRUE)"},{"path":"/reference/make_se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","text":"proteins_unique Data.frame, Protein table unique names annotated 'name' column (output make_unique()). columns Integer vector, Column numbers indicating columns containing assay data. expdesign Data.frame, Experimental design 'label', 'condition' 'replicate' information. log2transform Logical(1), whether log2 transform assay, default TRUE.","code":""},{"path":"/reference/make_se.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","text":"SummarizedExperiment object log2-transformed values.","code":""},{"path":"/reference/make_se.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data.frame to SummarizedExperiment object\nconversion using an experimental design — make_se","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique))  ## Load experiement design data(Silicosis_ExpDesign) exp_design <- Silicosis_ExpDesign se <- make_se(data_unique, columns, exp_design)"},{"path":"/reference/make_se_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","title":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","text":"make_se_parse creates SummarizedExperiment object based single data.frame.","code":""},{"path":"/reference/make_se_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","text":"","code":"make_se_parse(   proteins_unique,   columns,   mode = c(\"char\", \"delim\"),   chars = 1,   sep = \"_\",   remove_prefix = T,   remove_suffix = F,   log2transform = T )"},{"path":"/reference/make_se_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","text":"proteins_unique Data.frame, Protein table unique names annotated 'name' column (output make_unique()). columns Integer vector, Column numbers indicating columns containing assay data. mode \"char\" \"delim\", mode parsing column headers. \"char\" parse last number characters replicate number requires 'chars' parameter. \"delim\" parse separator requires 'sep' parameter. chars Numeric(1), number characters take end column headers replicate number (mode = \"char\"). sep Character(1), separator used parse column header (mode = \"delim\"). remove_prefix Logical(1), whether remove prefix expression columns. remove_suffix Logical(1), whether remove suffix expression columns. log2transform Logical(1), whether log2 transform assay, default TRUE.","code":""},{"path":"/reference/make_se_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","text":"SummarizedExperiment object log2-transformed values.","code":""},{"path":"/reference/make_se_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data.frame to SummarizedExperiment object\nconversion using parsing from column names — make_se_parse","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, columns, mode = \"char\", chars = 1, remove_prefix = TRUE) colnames(se) #>  [1] \"PBS_1\" \"PBS_2\" \"PBS_3\" \"PBS_4\" \"W10_2\" \"W10_4\" \"W2_1\"  \"W2_3\"  \"W2_4\"  #> [10] \"W2_5\"  \"W4_2\"  \"W4_3\"  \"W4_4\"  \"W4_5\"  \"W6_2\"  \"W6_3\"  \"W6_4\"  \"W6_6\"  #> [19] \"W9_2\"  \"W9_4\"  se <- make_se_parse(data_unique, columns, mode = \"delim\", remove_prefix = FALSE) colnames(se) #>  [1] \"LFQ.intensity.PBS_1\" \"LFQ.intensity.PBS_2\" \"LFQ.intensity.PBS_3\" #>  [4] \"LFQ.intensity.PBS_4\" \"LFQ.intensity.W10_2\" \"LFQ.intensity.W10_4\" #>  [7] \"LFQ.intensity.W2_1\"  \"LFQ.intensity.W2_3\"  \"LFQ.intensity.W2_4\"  #> [10] \"LFQ.intensity.W2_5\"  \"LFQ.intensity.W4_2\"  \"LFQ.intensity.W4_3\"  #> [13] \"LFQ.intensity.W4_4\"  \"LFQ.intensity.W4_5\"  \"LFQ.intensity.W6_2\"  #> [16] \"LFQ.intensity.W6_3\"  \"LFQ.intensity.W6_4\"  \"LFQ.intensity.W6_6\"  #> [19] \"LFQ.intensity.W9_2\"  \"LFQ.intensity.W9_4\""},{"path":"/reference/make_unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Make unique names — make_unique","title":"Make unique names — make_unique","text":"make_unique generates unique identifiers proteomics dataset based \"name\" \"id\" columns.","code":""},{"path":"/reference/make_unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make unique names — make_unique","text":"","code":"make_unique(proteins, names, ids, delim = \";\")"},{"path":"/reference/make_unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make unique names — make_unique","text":"proteins Data.frame, Protein table unique names created. names Character(1), Name column containing feature names. ids Character(1), Name column containing feature IDs. delim Character(1), Sets delimiter separating feature names within one protein group.","code":""},{"path":"/reference/make_unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make unique names — make_unique","text":"data.frame additional variables \"name\" \"ID\" containing unique names identifiers, respectively.","code":""},{"path":"/reference/make_unique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make unique names — make_unique","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg  # Check colnames and pick the appropriate columns colnames(data) #>  [1] \"Protein.IDs\"                   \"Majority.protein.IDs\"          #>  [3] \"Peptide.counts..all.\"          \"Peptide.counts..razor.unique.\" #>  [5] \"Peptide.counts..unique.\"       \"Protein.names\"                 #>  [7] \"Gene.names\"                    \"Fasta.headers\"                 #>  [9] \"Number.of.proteins\"            \"Peptides\"                      #> [11] \"Razor...unique.peptides\"       \"Unique.peptides\"               #> [13] \"iBAQ.PBS_1\"                    \"iBAQ.PBS_2\"                    #> [15] \"iBAQ.PBS_3\"                    \"iBAQ.PBS_4\"                    #> [17] \"iBAQ.W10_2\"                    \"iBAQ.W10_4\"                    #> [19] \"iBAQ.W2_1\"                     \"iBAQ.W2_3\"                     #> [21] \"iBAQ.W2_4\"                     \"iBAQ.W2_5\"                     #> [23] \"iBAQ.W4_2\"                     \"iBAQ.W4_3\"                     #> [25] \"iBAQ.W4_4\"                     \"iBAQ.W4_5\"                     #> [27] \"iBAQ.W6_2\"                     \"iBAQ.W6_3\"                     #> [29] \"iBAQ.W6_4\"                     \"iBAQ.W6_6\"                     #> [31] \"iBAQ.W9_2\"                     \"iBAQ.W9_4\"                     #> [33] \"LFQ.intensity.PBS_1\"           \"LFQ.intensity.PBS_2\"           #> [35] \"LFQ.intensity.PBS_3\"           \"LFQ.intensity.PBS_4\"           #> [37] \"LFQ.intensity.W10_2\"           \"LFQ.intensity.W10_4\"           #> [39] \"LFQ.intensity.W2_1\"            \"LFQ.intensity.W2_3\"            #> [41] \"LFQ.intensity.W2_4\"            \"LFQ.intensity.W2_5\"            #> [43] \"LFQ.intensity.W4_2\"            \"LFQ.intensity.W4_3\"            #> [45] \"LFQ.intensity.W4_4\"            \"LFQ.intensity.W4_5\"            #> [47] \"LFQ.intensity.W6_2\"            \"LFQ.intensity.W6_3\"            #> [49] \"LFQ.intensity.W6_4\"            \"LFQ.intensity.W6_6\"            #> [51] \"LFQ.intensity.W9_2\"            \"LFQ.intensity.W9_4\"            #> [53] \"Only.identified.by.site\"       \"Reverse\"                       #> [55] \"Potential.contaminant\"         data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")"},{"path":"/reference/make_unique_ptm.html","id":null,"dir":"Reference","previous_headings":"","what":"Make unique names for a modication-enriched peptide table — make_unique_ptm","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"make_unique_ptm generates unique identifiers proteomics dataset based \"modified_name\" columns. \"modified_name\" absent, creat modified name based \"gene_name\"/\"Protein\", \"aa\" \"pos\".","code":""},{"path":"/reference/make_unique_ptm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"","code":"make_unique_ptm(   PTMdata,   gene_name = \"Gene.names\",   protein_ID = \"Protein\",   aa = \"Amino.acid\",   pos = \"Position\",   modified_name = NULL,   delim = \";\" )"},{"path":"/reference/make_unique_ptm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"PTMdata Data.frame, modified peptide table unique names ID modified peptide created. gene_name Character(1), Name column containing gene symbol protein name. protein_ID Character(1), Name column containing protein ID gene ID. aa Character(1), Name column containing abbreviation modified amino acid, e.g. \"K\", \"S\", \"T\". unnecessary modified_name provided. pos Character(1), Name column containing position modification proteins. unnecessary modified_name provided. modified_name Character(1), Name column containing names modified peptide format (gene name)_(modified amino acid)(position modification), e.g. \"TBCA_K51\". delim Character(1), Sets delimiter separating multiple feature names within one protein group(gene_name protein_ID).","code":""},{"path":"/reference/make_unique_ptm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"data.frame 6 additional variables \"name\" \"ID\" containing unique names identifiers modified peptide respectively, e.g. \"TBCA_K51\" \"O75347_K51\". \"gene_name\", protein_ID\" save protein information modified peptide, e.g. \"TBCA\" \"O75347\". \"modified_aa\" \"modified_pos\" modified amino acid position, e.g. \"K\" \"51\".","code":""},{"path":"/reference/make_unique_ptm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"modified_name provide, gene_name, protein_ID, aa pos unnessary. Additional variables generated parsing modified_name. else gene_name protein_ID, aa pos nessary.","code":""},{"path":"/reference/make_unique_ptm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make unique names for a modication-enriched peptide table — make_unique_ptm","text":"","code":"## phosphorylated peptides table of the silicosis mouse model. data(Silicosis_phos) ## Format the modification information and generated modified-peptides identifier. unique_pho <- make_unique_ptm(Silicosis_phos, gene_name = \"Gene.names\",                               protein_ID = \"Protein\", aa = \"Amino.acid\",                               pos = \"Position\") head(unique_pho[, c(\"name\",\"ID\")], 10) #>            name          ID #> 1    P0DPB4_S60  P0DPB4_S60 #> 2    P0DPB4_S61  P0DPB4_S61 #> 3    P0DPB4_S62  P0DPB4_S62 #> 4    P0DPB4_S63  P0DPB4_S63 #> 5    P0DPB4_S67  P0DPB4_S67 #> 6  Ccdc173_S151 A0JLY1_S151 #> 7  Tbc1d25_S560 A1A5B6_S560 #> 8  Tbc1d25_S211 A1A5B6_S211 #> 9      Fscb_S32  A1EGX6_S32 #> 10   Fam65c_S24  A1L3T7_S24"},{"path":"/reference/manual_impute.html","id":null,"dir":"Reference","previous_headings":"","what":"Imputation by random draws from a manually defined distribution — manual_impute","title":"Imputation by random draws from a manually defined distribution — manual_impute","text":"manual_impute imputes missing values proteomics dataset random draws manually defined distribution.","code":""},{"path":"/reference/manual_impute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imputation by random draws from a manually defined distribution — manual_impute","text":"","code":"manual_impute(se, scale = 0.3, shift = 1.8)"},{"path":"/reference/manual_impute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imputation by random draws from a manually defined distribution — manual_impute","text":"se SummarizedExperiment, Proteomics data (output make_se() make_se_parse()). adviced first remove proteins many missing values using filter_se() normalize data using normalize_vsn(). scale Numeric(1), Sets width distribution relative standard deviation original distribution. shift Numeric(1), Sets left-shift distribution (standard deviations) median original distribution.","code":""},{"path":"/reference/manual_impute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Imputation by random draws from a manually defined distribution — manual_impute","text":"imputed SummarizedExperiment object.","code":""},{"path":"/reference/meanSdPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot row standard deviations versus row means — meanSdPlot","title":"Plot row standard deviations versus row means — meanSdPlot","text":"meanSdPlot generates hexagonal heatmap row standard deviations versus row means SummarizedExperiment objects. See meanSdPlot.","code":""},{"path":"/reference/meanSdPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot row standard deviations versus row means — meanSdPlot","text":"","code":"meanSdPlot(   x,   ranks = TRUE,   xlab = ifelse(ranks, \"rank(mean)\", \"mean\"),   ylab = \"sd\",   pch,   plot = TRUE,   bins = 50,   ... )"},{"path":"/reference/meanSdPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot row standard deviations versus row means — meanSdPlot","text":"x SummarizedExperiment, Data object. ranks Logical, Whether plot row means rank scale. xlab Character, x-axis label. ylab Character, y-axis label. pch Ignored - exists backward compatibility. plot Logical, Whether produce plot. bins Numeric vector, Data object normalization. ... arguments, Passed stat_binhex.","code":""},{"path":"/reference/meanSdPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot row standard deviations versus row means — meanSdPlot","text":"scatter plot row standard deviations versus row means(generated stat_binhex)","code":""},{"path":"/reference/meanSdPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot row standard deviations versus row means — meanSdPlot","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit.  # Plot meanSdPlot meanSdPlot(norm) #> Warning: Computation failed in `stat_binhex()` #> Caused by error in `compute_group()`: #> ! The package \"hexbin\" is required for `stat_binhex()`"},{"path":"/reference/normalize_pe.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize a QFeatures object — normalize_pe","title":"Normalize a QFeatures object — normalize_pe","text":"Normalize assay QFeatures object though QFeatures::normalize function. normalized assay saved name assay.","code":""},{"path":"/reference/normalize_pe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize a QFeatures object — normalize_pe","text":"","code":"normalize_pe(   pe,   method = c(\"diff.median\", \"quantiles\", \"quantiles.robust\", \"vsn\"),   i = \"peptideImp\",   name = \"peptideNorm\" )"},{"path":"/reference/normalize_pe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize a QFeatures object — normalize_pe","text":"pe QFeature object method Character(1), normalisation method, one \"diff.median\", \"quantiles\", \"quantiles.robust\" \"vsn\". See normalize. numeric character giving index name, respectively, assay(s) processed. name Character(1) naming new normalized assay.","code":""},{"path":"/reference/normalize_pe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize a QFeatures object — normalize_pe","text":"","code":"if (FALSE) { # Load example peptide data data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)  # Construct QFeature object pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols, remove_prefix = TRUE, log2transform = TRUE,mode = \"delim\")  # Filter, imputation pe <- filter_pe(pe_peptides, thr = 1,fraction = 0.4, filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) pe <- impute_pe(pe, fun = \"QRILC\", name = \"peptideImp\")  # Normalization pe <- normalize_pe(pe,method = \"quantiles\", i = \"peptideImp\", name = \"peptideNorm\") }"},{"path":"/reference/normalize_vsn.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalization using vsn — normalize_vsn","title":"Normalization using vsn — normalize_vsn","text":"normalize_vsn performs variance stabilizing transformation using vsn-package.","code":""},{"path":"/reference/normalize_vsn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalization using vsn — normalize_vsn","text":"","code":"normalize_vsn(se)"},{"path":"/reference/normalize_vsn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalization using vsn — normalize_vsn","text":"se SummarizedExperiment, Proteomics data (output make_se() make_se_parse()). adviced first remove proteins many missing values using filter_se().","code":""},{"path":"/reference/normalize_vsn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalization using vsn — normalize_vsn","text":"normalized SummarizedExperiment object.","code":""},{"path":"/reference/normalize_vsn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalization using vsn — normalize_vsn","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique))  # Load experiement design data(Silicosis_ExpDesign) exp_design <- Silicosis_ExpDesign se <- make_se(data_unique, ecols, exp_design) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit."},{"path":"/reference/ntf_deg.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign normalized assay for DEGdata object — ntf_deg","title":"Assign normalized assay for DEGdata object — ntf_deg","text":"ntf_deg transform log2(default) transformed normalized assay based normTransform()","code":""},{"path":"/reference/ntf_deg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign normalized assay for DEGdata object — ntf_deg","text":"","code":"ntf_deg(DEGdata, f = log2, pc = 1)"},{"path":"/reference/ntf_deg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign normalized assay for DEGdata object — ntf_deg","text":"DEGdata DEGdata object get_res f function apply normalized counts pc pseudocount add normalized counts","code":""},{"path":"/reference/ntf_deg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign normalized assay for DEGdata object — ntf_deg","text":"DEGdata normalized assay ntf slot","code":""},{"path":"/reference/pe2se.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","title":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","text":"function accept result aggregate_pe(), tidy features identifiers return SE object following analyze","code":""},{"path":"/reference/pe2se.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","text":"","code":"pe2se(   pe_aggregated,   names = \"Gene.names\",   ids = \"smallestProteingroups\",   delim = \";\" )"},{"path":"/reference/pe2se.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","text":"pe_aggregated QFeatures object output aggregate_pe(), contain \"protein\" quantative assay. names column gene names, serve feature identifier transmitted make_unique ids column protein ID, transmitted make_unique. aggregate_pe automatically generate \"smallestProteingroups\" column store ids proteingroups. delim Character. separator names ids.","code":""},{"path":"/reference/pe2se.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","text":"SummarizedExperiment object.","code":""},{"path":"/reference/pe2se.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the proteins SummarizedExperiment object from a QFeatures container — pe2se","text":"","code":"if (FALSE) { # Load example peptide data data(Silicosis_peptide) ecols <- grep(\"Intensity.\", colnames(Silicosis_peptide), value = TRUE)  # construct QFeatures object pe_peptides <- make_pe_parse(Silicosis_peptide, columns = ecols, remove_prefix = TRUE, log2transform = TRUE,mode = \"delim\")  # Filter, imputation pe <- filter_pe(pe_peptides, thr = 1,fraction = 0.4, filter_formula = ~ Reverse != '+' & Potential.contaminant !=\"+\" ) pe <- impute_pe(pe, fun = \"QRILC\", name = \"peptideImp\")  # Normalization pe <- normalize_pe(pe,method = \"quantiles\", i = \"peptideImp\", name = \"peptideNorm\")  # Summarize peptide value to protein quantity protein_pe <- DEP2::aggregate_pe(pe, fcol = \"Proteins\", i = \"peptideNorm\") class(protein_pe)  # Construct a SE object se <- pe2se(protein_pe) class(se) }"},{"path":"/reference/plot_Tsne.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot t-Sne — plot_Tsne","title":"Plot t-Sne — plot_Tsne","text":"plot_Tsne generates t-Sne plot using global variable features","code":""},{"path":"/reference/plot_Tsne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot t-Sne — plot_Tsne","text":"","code":"plot_Tsne(   object,   indicate = c(\"condition\", \"replicate\"),   label = FALSE,   n = nrow(object),   point_size = 4,   label_size = 3,   plot = TRUE,   if_square = FALSE,   features = \"features\",   perplexity = 2,   theseed = NULL,   ... )"},{"path":"/reference/plot_Tsne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot t-Sne — plot_Tsne","text":"object SummarizedExperiment (DEGdata) object, Data object differentially enriched proteins annotated (output test_diff() (test_diff_deg()) add_rejections()). indicate Character, Sets color, shape facet_wrap plot based columns experimental design (colData). label Logical, Whether add sample labels. n Integer(1), Sets number top variable proteins consider. point_size Integer(1), Sets size points. label_size Integer(1), Sets size labels. plot Logical(1), TRUE (default) PCA plot produced. Otherwise (FALSE), data PCA plot based returned. if_square Logical(1), TRUE plot features Character(1), feature name plot title, \"proteins\",\"genes\", default \"features\" perplexity Perplexity parameter (bigger 3 * perplexity < nrow(X) - 1. See Rtsne(). theseed integer(1),Set random seed. ... parameters Rtsne().","code":""},{"path":"/reference/plot_Tsne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot t-Sne — plot_Tsne","text":"scatter plot (generated ggplot).","code":""},{"path":"/reference/plot_Tsne.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot t-Sne — plot_Tsne","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531  # t-SNE plot plot_Tsne(imputed) #> The random seed of umap is 14545 #> Warning: Use of `Tsne_df[[indicate[1]]]` is discouraged. #> ℹ Use `.data[[indicate[1]]]` instead. #> Warning: Use of `Tsne_df[[indicate[2]]]` is discouraged. #> ℹ Use `.data[[indicate[2]]]` instead."},{"path":"/reference/plot_cond.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","title":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","text":"plot_cond generates histogram number proteins per condition stacks overlapping conditions. function inherited DEP package.","code":""},{"path":"/reference/plot_cond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","text":"","code":"plot_cond(dep, plot = TRUE)"},{"path":"/reference/plot_cond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","text":"dep SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() add_rejections()). plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), data barplot based returned.","code":""},{"path":"/reference/plot_cond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","text":"histogram (generated ggplot)","code":""},{"path":"/reference/plot_cond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot frequency of significant conditions per protein\nand the overlap in proteins between conditions — plot_cond","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Analysis filt <- filter_se(se, thr = 0, fraction = 0.3, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8832 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff)  # Plot histogram with overlaps plot_cond(dep) #> Error in loadNamespace(x): there is no package called ‘DEP’"},{"path":"/reference/plot_cond_freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot frequency of significant conditions per protein — plot_cond_freq","title":"Plot frequency of significant conditions per protein — plot_cond_freq","text":"plot_cond_freq generates histogram number significant conditions per protein.","code":""},{"path":"/reference/plot_cond_freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot frequency of significant conditions per protein — plot_cond_freq","text":"","code":"plot_cond_freq(dep, plot = TRUE)"},{"path":"/reference/plot_cond_freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot frequency of significant conditions per protein — plot_cond_freq","text":"dep SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() add_rejections()). plot Logical(1), TRUE (default) histogram produced. Otherwise (FALSE), data histogram based returned.","code":""},{"path":"/reference/plot_cond_freq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot frequency of significant conditions per protein — plot_cond_freq","text":"histogram (generated ggplot)","code":""},{"path":"/reference/plot_cond_freq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot frequency of significant conditions per protein — plot_cond_freq","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Analysis filt <- filter_se(se, thr = 0, fraction = 0.3, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8832 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff)  # Plot frequency of significant conditions plot_cond_freq(dep) #> Error in loadNamespace(x): there is no package called ‘DEP’"},{"path":"/reference/plot_cond_overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot conditions overlap — plot_cond_overlap","title":"Plot conditions overlap — plot_cond_overlap","text":"plot_cond_overlap generates histogram number proteins per condition overlapping conditions.","code":""},{"path":"/reference/plot_cond_overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot conditions overlap — plot_cond_overlap","text":"","code":"plot_cond_overlap(dep, plot = TRUE)"},{"path":"/reference/plot_cond_overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot conditions overlap — plot_cond_overlap","text":"dep SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() add_rejections()). plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), data barplot based returned.","code":""},{"path":"/reference/plot_cond_overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot conditions overlap — plot_cond_overlap","text":"histogram (generated ggplot)","code":""},{"path":"/reference/plot_cond_overlap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot conditions overlap — plot_cond_overlap","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Analysis filt <- filter_se(se, thr = 0, fraction = 0.3, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8832 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinDet\") #> Imputing along margin 2 (samples/columns). diff <- test_diff(imputed,type = \"control\", control = \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) dep <- add_rejections(diff)  # Plot condition overlap plot_cond_overlap(dep)"},{"path":"/reference/plot_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot correlation matrix — plot_cor","title":"Plot correlation matrix — plot_cor","text":"plot_cor generates Pearson correlation matrix.","code":""},{"path":"/reference/plot_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot correlation matrix — plot_cor","text":"","code":"plot_cor(   x,   significant = TRUE,   lower = -1,   upper = 1,   pal = \"PRGn\",   pal_rev = FALSE,   indicate = NULL,   font_size = 12,   plot = TRUE,   add_values = FALSE,   value_size = 10,   digits = 2,   ... )"},{"path":"/reference/plot_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot correlation matrix — plot_cor","text":"x SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() add_rejections()). significant Logical(1), Whether filter significant proteins. lower Integer(1), Sets lower limit color scale. upper Integer(1), Sets upper limit color scale. pal Character(1), Sets color panel (RColorBrewer). pal_rev Logical(1), Whether invert color palette. indicate Character, Sets additional annotation top heatmap based columns experimental design (colData). font_size Integer(1), Sets size labels. plot Logical(1), TRUE (default) correlation matrix plot produced. Otherwise (FALSE), data correlation matrix plot based returned. add_values Logical(1). Display distance value heatmap. value_size Numeric(1). Font size distance. digits Integer(1), indicating number decimal places distance. ... Additional arguments Heatmap function depicted Heatmap","code":""},{"path":"/reference/plot_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot correlation matrix — plot_cor","text":"heatmap plot (generated Heatmap)","code":""},{"path":"/reference/plot_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot correlation matrix — plot_cor","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter, normalize and impute missing values filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" norm <- normalize_vsn(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found imputed <- impute(norm, fun = \"MinProb\", q = 0.01) #> Error: se does not inherit from class SummarizedExperiment  # Test for differentially expressed proteins diff <- test_diff(imputed, \"control\", \"Ctrl\") #> Error in eval(expr, envir, enclos): object 'imputed' not found dep <- add_rejections(diff, alpha = 0.05, lfc = 1) #> Error in (function (classes, fdef, mtable) {    methods <- .findInheritedMethods(classes, fdef, mtable)    if (length(methods) == 1L)         return(methods[[1L]])    else if (length(methods) == 0L) {        cnames <- paste0(\"\\\"\", vapply(classes, as.character,             \"\"), \"\\\"\", collapse = \", \")        stop(gettextf(\"unable to find an inherited method for function %s for signature %s\",             sQuote(fdef@generic), sQuote(cnames)), domain = NA)    }    else stop(\"Internal error in finding inherited methods; didn't return a unique method\",         domain = NA)})(list(structure(\"standardGeneric\", package = \"methods\")), new(\"nonstandardGenericFunction\",     .Data = function (diff, alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     {        standardGeneric(\"add_rejections\")    }, generic = structure(\"add_rejections\", package = \"DEP2\"),     package = \"DEP2\", group = list(), valueClass = character(0),     signature = c(\"diff\", \"alpha\", \"lfc\", \"thresholdmethod\",     \"curvature\", \"x0_fold\"), default = NULL, skeleton = (function (diff,         alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\",         \"add_rejections\"), domain = NA))(diff, alpha, lfc, thresholdmethod,         curvature, x0_fold, ...)), <environment>): unable to find an inherited method for function ‘add_rejections’ for signature ‘\"standardGeneric\"’  # Plot correlation matrix plot_cor(dep) #> Error in eval(expr, envir, enclos): object 'dep' not found"},{"path":"/reference/plot_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot protein coverage — plot_coverage","title":"Plot protein coverage — plot_coverage","text":"plot_coverage generates barplot protein coverage samples.","code":""},{"path":"/reference/plot_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot protein coverage — plot_coverage","text":"","code":"plot_coverage(se, plot = TRUE, features_type = \"features\")"},{"path":"/reference/plot_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot protein coverage — plot_coverage","text":"se SummarizedExperiment, Data object plot observation frequency. plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), data barplot based returned. features_type Character(1), type features used title, like 'proteins', 'genes', 'peptides', default 'features'","code":""},{"path":"/reference/plot_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot protein coverage — plot_coverage","text":"Barplot protein coverage samples (generated ggplot)","code":""},{"path":"/reference/plot_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot protein coverage — plot_coverage","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter and plot coverage filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" plot_coverage(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found"},{"path":"/reference/plot_cvs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot sample coefficient of variation whitin group — plot_cvs","title":"Plot sample coefficient of variation whitin group — plot_cvs","text":"Plot sample coefficient variation whitin group","code":""},{"path":"/reference/plot_cvs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot sample coefficient of variation whitin group — plot_cvs","text":"","code":"plot_cvs(se)"},{"path":"/reference/plot_cvs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot sample coefficient of variation whitin group — plot_cvs","text":"se SummarizedExperiment data object","code":""},{"path":"/reference/plot_cvs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot sample coefficient of variation whitin group — plot_cvs","text":"histogram plot row coefficient variation (standard deviation / mean) condition","code":""},{"path":"/reference/plot_cvs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot sample coefficient of variation whitin group — plot_cvs","text":"","code":"data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 plot_cvs(imputed)"},{"path":"/reference/plot_detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize intensities of proteins with missing values — plot_detect","title":"Visualize intensities of proteins with missing values — plot_detect","text":"plot_detect generates density CumSum plots protein intensities without missing values","code":""},{"path":"/reference/plot_detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize intensities of proteins with missing values — plot_detect","text":"","code":"plot_detect(se)"},{"path":"/reference/plot_detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize intensities of proteins with missing values — plot_detect","text":"se SummarizedExperiment, Data object missing values.","code":""},{"path":"/reference/plot_detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize intensities of proteins with missing values — plot_detect","text":"Density CumSum plots intensities proteins without missing values (generated ggplot).","code":""},{"path":"/reference/plot_detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize intensities of proteins with missing values — plot_detect","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Construct SE ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\")  # Filter filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula   # Plot intensities of proteins with missing values plot_detect(filt)"},{"path":"/reference/plot_diff_hist.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a Gaussian distribution for L2FC of each contrast — plot_diff_hist","title":"Fit a Gaussian distribution for L2FC of each contrast — plot_diff_hist","text":"plot_diff_hist fit Gaussian distribution L2FC contrast. L2FC value firstly filter outlier, fit normal curve based likelihood.","code":""},{"path":"/reference/plot_diff_hist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a Gaussian distribution for L2FC of each contrast — plot_diff_hist","text":"","code":"plot_diff_hist(object, contrasts = NULL, plot = T)"},{"path":"/reference/plot_diff_hist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a Gaussian distribution for L2FC of each contrast — plot_diff_hist","text":"object SummarizedExperiment DEGdata output test_diff test_diff_deg contrasts Character, contrast object plot Logical(1), TRUE return histogram(s) L2FC contras fitted normal curve. FALSE return fitting result, mu sigma Gaussian distribution","code":""},{"path":"/reference/plot_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Gower's distance matrix — plot_dist","title":"Plot Gower's distance matrix — plot_dist","text":"plot_dist generates distance matrix heatmap using Gower's distance.","code":""},{"path":"/reference/plot_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Gower's distance matrix — plot_dist","text":"","code":"plot_dist(   x,   significant = TRUE,   pal = \"YlOrRd\",   pal_rev = TRUE,   indicate = NULL,   font_size = 12,   plot = TRUE,   add_values = FALSE,   value_size = 10,   digits = 2,   ... )"},{"path":"/reference/plot_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Gower's distance matrix — plot_dist","text":"x SummarizedExperiment DEGdata object, differentially expressed/enriched proteins genes annotated (output test_diff() add_rejections()). significant Logical(1), Whether filter significant proteins. pal Character(1), Sets color panel (RColorBrewer). pal_rev Logical(1), Whether invert color palette. indicate Character, Sets additional annotation top heatmap based columns experimental design (colData). font_size Integer(1), Sets size labels. plot Logical(1), TRUE (default) distance matrix plot produced. Otherwise (FALSE), data distance matrix plot based returned. add_values Logical(1). Display distance value heatmap. value_size Numeric(1). Font size distance. digits Integer(1), indicating number decimal places distance. ... Additional arguments Heatmap function depicted Heatmap","code":""},{"path":"/reference/plot_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Gower's distance matrix — plot_dist","text":"heatmap plot (generated Heatmap)","code":""},{"path":"/reference/plot_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Gower's distance matrix — plot_dist","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter, normalize and impute missing values filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" norm <- normalize_vsn(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found imputed <- impute(norm, fun = \"MinProb\", q = 0.01) #> Error: se does not inherit from class SummarizedExperiment  # Test for differentially expressed proteins diff <- test_diff(imputed, \"control\", \"Ctrl\") #> Error in eval(expr, envir, enclos): object 'imputed' not found dep <- add_rejections(diff, alpha = 0.05, lfc = 1) #> Error in (function (classes, fdef, mtable) {    methods <- .findInheritedMethods(classes, fdef, mtable)    if (length(methods) == 1L)         return(methods[[1L]])    else if (length(methods) == 0L) {        cnames <- paste0(\"\\\"\", vapply(classes, as.character,             \"\"), \"\\\"\", collapse = \", \")        stop(gettextf(\"unable to find an inherited method for function %s for signature %s\",             sQuote(fdef@generic), sQuote(cnames)), domain = NA)    }    else stop(\"Internal error in finding inherited methods; didn't return a unique method\",         domain = NA)})(list(structure(\"standardGeneric\", package = \"methods\")), new(\"nonstandardGenericFunction\",     .Data = function (diff, alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     {        standardGeneric(\"add_rejections\")    }, generic = structure(\"add_rejections\", package = \"DEP2\"),     package = \"DEP2\", group = list(), valueClass = character(0),     signature = c(\"diff\", \"alpha\", \"lfc\", \"thresholdmethod\",     \"curvature\", \"x0_fold\"), default = NULL, skeleton = (function (diff,         alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\",         \"add_rejections\"), domain = NA))(diff, alpha, lfc, thresholdmethod,         curvature, x0_fold, ...)), <environment>): unable to find an inherited method for function ‘add_rejections’ for signature ‘\"standardGeneric\"’  # Plot correlation matrix plot_dist(dep) #> Error in eval(expr, envir, enclos): object 'dep' not found"},{"path":"/reference/plot_frequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot protein overlap between samples — plot_frequency","title":"Plot protein overlap between samples — plot_frequency","text":"plot_frequency generates barplot protein overlap samples","code":""},{"path":"/reference/plot_frequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot protein overlap between samples — plot_frequency","text":"","code":"plot_frequency(se, plot = TRUE)"},{"path":"/reference/plot_frequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot protein overlap between samples — plot_frequency","text":"se SummarizedExperiment, Data object plot observation frequency. plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), data barplot based returned.","code":""},{"path":"/reference/plot_frequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot protein overlap between samples — plot_frequency","text":"Barplot overlap protein identifications samples (generated ggplot)","code":""},{"path":"/reference/plot_frequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot protein overlap between samples — plot_frequency","text":"","code":"# Load example data(Silicosis_pg) data_unique <- make_unique(Silicosis_pg, \"Gene.names\", \"Protein.IDs\", delim = \";\") # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols, mode = \"delim\", sep = \"_\")  # Filter and plot frequency filt <- filter_se(se, thr = 0, fraction = 0.3) #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.3 in each row  plot_frequency(filt)"},{"path":"/reference/plot_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a heatmap — plot_heatmap","title":"Plot a heatmap — plot_heatmap","text":"plot_heatmap generates heatmap selected features DEP DEG data.","code":""},{"path":"/reference/plot_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a heatmap — plot_heatmap","text":"","code":"# S4 method for SummarizedExperiment plot_heatmap(   object,   type = c(\"centered\", \"contrast\"),   manual_contrast = NULL,   kmeans = FALSE,   k = 6,   color = c(\"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\",     \"Spectral\"),   col_limit = 6,   indicate = NULL,   row_font_size = 6,   col_font_size = 10,   clustering_distance = c(\"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\",     \"minkowski\", \"pearson\", \"spearman\", \"kendall\", \"gower\"),   split_order = NULL,   label_few_peptide_rows = FALSE,   chooseToshow = NULL,   plot = TRUE,   seed = 42,   ... )  # S4 method for DEGdata plot_heatmap(   object,   type = c(\"centered\", \"contrast\"),   manual_contrast = NULL,   kmeans = FALSE,   k = 6,   color = c(\"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\",     \"Spectral\"),   col_limit = 6,   indicate = NULL,   row_font_size = 6,   col_font_size = 10,   clustering_distance = c(\"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\",     \"minkowski\", \"pearson\", \"spearman\", \"kendall\", \"gower\"),   split_order = NULL,   label_few_peptide_rows = FALSE,   chooseToshow = NULL,   plot = TRUE,   seed = 42,   ... )"},{"path":"/reference/plot_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a heatmap — plot_heatmap","text":"object SummarizedExperiment DEGDdata object differentially enriched proteins annotated (output test_diff() add_rejections()). type type 'contrast' 'centered', type data scaling used plotting. Either fold change ('contrast') centered log2-intensity ('centered'). manual_contrast Character. plot significant proteins certain contrasts. kmeans Logical(1), Whether perform k-means clustering. k Integer(1), Sets number k-means clusters, k must less row heatmap color Character(1), sets color panel (RColorBrewer). can palette name \"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\", \"Spectral\". col_limit Integer(1), Sets outer limits color scale. indicate Character, Sets additional annotation top heatmap based columns experimental design (colData). applicable type = 'centered'. row_font_size Integer(1), Font size row name col_font_size Integer(1), Font size columns label. clustering_distance Character(1).\"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\", \"minkowski\", \"pearson\", \"spearman\", \"kendall\" \"gower\", Function used calculate clustering distance (proteins samples). Based Heatmap daisy. split_order integer vector 1:k. order cluster slices heatmap. NULL, slices order based clustering distance. Work Kmeans = TRUE. label_few_peptide_rows Logic(1) TRUE, label proteins peptide color. Proteins one peptide show purple name heatmap, two peptide show blue name. chooseToshow Character vector chosen proteins/peptides names. null, plot chosen proteins/peptides plot Logical(1) TRUE (default) heatmap produced. Otherwise (FALSE), data heatmap based returned. seed Integer(1), random seed effect kmeans cluster heatmap. Preset seed repeatable cluster result. ... parameters Heatmap.","code":""},{"path":"/reference/plot_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a heatmap — plot_heatmap","text":"return heatmap (generated Heatmap) data.frame plot = F.","code":""},{"path":"/reference/plot_heatmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a heatmap — plot_heatmap","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"manual\", control  = c(\"W4_vs_PBS\"), fdr.type = \"Storey's qvalue\") #> Error: run test_diff() with a valid control. #> Valid controls are: 'PBS', 'W10', 'W2', 'W4', 'W6', 'W9' dep <- add_rejections(diff, alpha = 0.01,lfc = 2) #> Error in (function (classes, fdef, mtable) {    methods <- .findInheritedMethods(classes, fdef, mtable)    if (length(methods) == 1L)         return(methods[[1L]])    else if (length(methods) == 0L) {        cnames <- paste0(\"\\\"\", vapply(classes, as.character,             \"\"), \"\\\"\", collapse = \", \")        stop(gettextf(\"unable to find an inherited method for function %s for signature %s\",             sQuote(fdef@generic), sQuote(cnames)), domain = NA)    }    else stop(\"Internal error in finding inherited methods; didn't return a unique method\",         domain = NA)})(list(structure(\"standardGeneric\", package = \"methods\")), new(\"nonstandardGenericFunction\",     .Data = function (diff, alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     {        standardGeneric(\"add_rejections\")    }, generic = structure(\"add_rejections\", package = \"DEP2\"),     package = \"DEP2\", group = list(), valueClass = character(0),     signature = c(\"diff\", \"alpha\", \"lfc\", \"thresholdmethod\",     \"curvature\", \"x0_fold\"), default = NULL, skeleton = (function (diff,         alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\",         \"add_rejections\"), domain = NA))(diff, alpha, lfc, thresholdmethod,         curvature, x0_fold, ...)), <environment>): unable to find an inherited method for function ‘add_rejections’ for signature ‘\"standardGeneric\"’  # Heatmap plot_heatmap(dep) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'plot_heatmap': object 'dep' not found"},{"path":"/reference/plot_imputation.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize imputation — plot_imputation","title":"Visualize imputation — plot_imputation","text":"plot_imputation generates density plots conditions input objects, e.g. imputation.","code":""},{"path":"/reference/plot_imputation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize imputation — plot_imputation","text":"","code":"plot_imputation(se, ...)"},{"path":"/reference/plot_imputation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize imputation — plot_imputation","text":"se SummarizedExperiment, Data object, e.g. imputation (output normalize_vsn()). ... SummarizedExperiment object(s), E.g. data object imputation (output impute()).","code":""},{"path":"/reference/plot_imputation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize imputation — plot_imputation","text":"Density plots conditions conditions input objects, e.g. imputation (generated ggplot).","code":""},{"path":"/reference/plot_imputation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize imputation — plot_imputation","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Construct SE ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\")  # Filter and normalization filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit.  # imputation imputed <- impute(norm, fun = \"MinProb\", q = 0.01) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531  # Plot imputation plot_imputation(filt, norm, imputed)"},{"path":"/reference/plot_ma_RNA.html","id":null,"dir":"Reference","previous_headings":"","what":"MA-plot of RNA expression data — plot_ma_RNA","title":"MA-plot of RNA expression data — plot_ma_RNA","text":"Plot MA-plot differential test result test_diff().","code":""},{"path":"/reference/plot_ma_RNA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MA-plot of RNA expression data — plot_ma_RNA","text":"","code":"plot_ma_RNA(   x,   contrast = get_contrast(x)[1],   point_alpha = 0.2,   sig_color = \"red3\",   hlines = NULL,   title = contrast,   xlab = \"mean of normalized counts - log10 scale\",   ylim = NULL,   add_rug = FALSE,   intgenes = NULL,   intgenes_color = \"steelblue4\",   intgenes_size = 3,   label_fontsize = 3,   labels_repel = FALSE )"},{"path":"/reference/plot_ma_RNA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MA-plot of RNA expression data — plot_ma_RNA","text":"x DEGdata object, Test result differentially expressed/enriched proteins genes annotated (output test_diff()). contrast Character. plot certain contrasts. point_alpha Numeric(1), 0 1, transparency value points (0 = transparent, 1 = opaque) sig_color Charecter(1), Color use mark differentially expressed genes. Defaults red hlines Numeric(1), y coordinate (absolute value) draw horizontal lines, optional title title plot, optional xlab X axis label, defaults \"mean normalized counts - log10 scale\" ylim Vector two numeric values, Y axis limits restrict view. add_rug Logical, whether add rug plots margins intgenes Vector genes interest, highlighted plot intgenes_color. Gene symbols symbol column provided x, else identifiers specified row names intgenes_color Character(1), color use mark genes main plot. intgenes_size point size intgenes. label_fontsize Numeric(1), fontsize labels_intgenes labels_repel Logical, whether use geom_text_repel placing labels features mark labels_intgenes Logical, whether add gene identifiers/names close marked plots.","code":""},{"path":"/reference/plot_ma_RNA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MA-plot of RNA expression data — plot_ma_RNA","text":"ggplot object","code":""},{"path":"/reference/plot_ma_pro.html","id":null,"dir":"Reference","previous_headings":"","what":"MA-plot of quantity data — plot_ma_pro","title":"MA-plot of quantity data — plot_ma_pro","text":"Plot MA-plot differential test result.","code":""},{"path":"/reference/plot_ma_pro.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MA-plot of quantity data — plot_ma_pro","text":"","code":"plot_ma_pro(   x,   contrast,   point_alpha = 0.2,   sig_color = \"red3\",   hlines = NULL,   title = contrast,   xlab = \"mean of normalized counts - log10 scale\",   ylim = NULL,   add_rug = FALSE,   intgenes = NULL,   intgenes_color = \"steelblue4\",   intgenes_size = 3,   label_fontsize = 3,   labels_repel = FALSE )"},{"path":"/reference/plot_ma_pro.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MA-plot of quantity data — plot_ma_pro","text":"x SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() test_diff_deg()). contrast Character. plot certain contrasts. point_alpha Numeric(1), 0 1, transparency value points (0 = transparent, 1 = opaque) sig_color Charecter(1), Color use mark differentially expressed genes. Defaults red hlines Numeric(1), y coordinate (absolute value) draw horizontal lines, optional title title plot, optional xlab X axis label, defaults \"mean normalized counts - log10 scale\" ylim Vector two numeric values, Y axis limits restrict view. add_rug Logical, whether add rug plots margins intgenes Vector name, highlighted plot intgenes_color column provided x, else identifiers specified row names intgenes_color Character(1), color use mark genes main plot. intgenes_size point size intgenes. label_fontsize Numeric(1), fontsize labels_intgenes labels_repel Logical, whether use geom_text_repel placing labels features mark","code":""},{"path":"/reference/plot_ma_pro.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MA-plot of quantity data — plot_ma_pro","text":"ggplot object","code":""},{"path":"/reference/plot_missval.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a heatmap of proteins with missing values — plot_missval","title":"Plot a heatmap of proteins with missing values — plot_missval","text":"plot_missval generates heatmap proteins missing values discover whether values missing random .","code":""},{"path":"/reference/plot_missval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a heatmap of proteins with missing values — plot_missval","text":"","code":"plot_missval(se, ...)"},{"path":"/reference/plot_missval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a heatmap of proteins with missing values — plot_missval","text":"se SummarizedExperiment ... Additional arguments Heatmap function depicted Heatmap Data object missing values.","code":""},{"path":"/reference/plot_missval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a heatmap of proteins with missing values — plot_missval","text":"heatmap indicating whether values missing (0) (1) (generated Heatmap).","code":""},{"path":"/reference/plot_missval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a heatmap of proteins with missing values — plot_missval","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula   # Plot missing values heatmap plot_missval(filt)"},{"path":"/reference/plot_multi_heatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot heatmap of specified genes/proteins across multiple omics results — plot_multi_heatmap","title":"Plot heatmap of specified genes/proteins across multiple omics results — plot_multi_heatmap","text":"Plot heatmap specified genes/proteins across multiple omics results","code":""},{"path":"/reference/plot_multi_heatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot heatmap of specified genes/proteins across multiple omics results — plot_multi_heatmap","text":"","code":"plot_multi_heatmap(   omics_list,   choose_name,   to_upper = FALSE,   color = c(\"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\",     \"Spectral\"),   col_limit = 6,   width = 7,   height = 10,   row_font_size = 5,   col_font_size = 11,   ... )"},{"path":"/reference/plot_multi_heatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot heatmap of specified genes/proteins across multiple omics results — plot_multi_heatmap","text":"omics_list list composed SummarizedExperiment DEGdata objects. choose_name Character, vector specified identifiers. to_upper Logical, whether transform identifiers upper color Character(1), sets color panel (RColorBrewer). can palette name \"RdBu\", \"RdYlBu\", \"RdYlGn\", \"BrBG\", \"PiYG\", \"PRGn\", \"PuOr\", \"RdGy\", \"Spectral\". col_limit Integer(1), Sets outer limits color scale. width Numeric, width heatmap height Numeric, height heatmap row_font_size Numeric, size row label. ... parameters Heatmap","code":""},{"path":"/reference/plot_multi_heatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot heatmap of specified genes/proteins across multiple omics results — plot_multi_heatmap","text":"HeatmapList ComplexHeatmap package","code":""},{"path":"/reference/plot_multi_venn.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot venn plot of specified genes/proteins across multiple omics results — plot_multi_venn","title":"Plot venn plot of specified genes/proteins across multiple omics results — plot_multi_venn","text":"Plot venn plot significant candidate muitiple omics results, based identifiers('name')","code":""},{"path":"/reference/plot_multi_venn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot venn plot of specified genes/proteins across multiple omics results — plot_multi_venn","text":"","code":"plot_multi_venn(omics_list, to_upper = F, plot = T, background = NULL)"},{"path":"/reference/plot_multi_venn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot venn plot of specified genes/proteins across multiple omics results — plot_multi_venn","text":"omics_list list composed SummarizedExperiment DEGdata objects . to_upper Logical, whether transform identifiers upper plot Logical(1), return venn plot table. background NULL character vector names background protein/gene pool. background provided, plot_multi_venn consider candidates background.","code":""},{"path":"/reference/plot_multi_venn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot venn plot of specified genes/proteins across multiple omics results — plot_multi_venn","text":"venn plot ggVennDiagram table.","code":""},{"path":"/reference/plot_norm_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the fit normal for log2 fold change — plot_norm_distribution","title":"Plot the fit normal for log2 fold change — plot_norm_distribution","text":"Plot fit normal log2 fold change","code":""},{"path":"/reference/plot_norm_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the fit normal for log2 fold change — plot_norm_distribution","text":"","code":"plot_norm_distribution(object, contrast = get_contrast(object))"},{"path":"/reference/plot_norm_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the fit normal for log2 fold change — plot_norm_distribution","text":"object summarizedExperiment object contrast contrasts plot fitting normal curve.","code":""},{"path":"/reference/plot_norm_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the fit normal for log2 fold change — plot_norm_distribution","text":"histogram plot normal curve","code":""},{"path":"/reference/plot_norm_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the fit normal for log2 fold change — plot_norm_distribution","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Storey's qvalue plot_norm_distribution(diff, contrast = \"W4_vs_PBS\") #> Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0. #> ℹ Please use `after_stat(density)` instead. #> ℹ The deprecated feature was likely used in the DEP2 package. #>   Please report the issue to the authors."},{"path":"/reference/plot_normalization.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize normalization — plot_normalization","title":"Visualize normalization — plot_normalization","text":"plot_normalization generates boxplots conditions input objects, e.g. normalization.","code":""},{"path":"/reference/plot_normalization.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize normalization — plot_normalization","text":"","code":"plot_normalization(se, ...)"},{"path":"/reference/plot_normalization.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize normalization — plot_normalization","text":"se SummarizedExperiment, Data object, e.g. normalization (output make_se() make_se_parse()). ... Additional SummarizedExperiment object(s), E.g. data object normalization (output normalize_vsn).","code":""},{"path":"/reference/plot_normalization.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize normalization — plot_normalization","text":"Boxplots conditions input objects, e.g. normalization (generated ggplot). Adding components plot adjustments can easily done using ggplot2 syntax (.e. using '+')","code":""},{"path":"/reference/plot_normalization.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize normalization — plot_normalization","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Construct SE ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\")  # Filter and normalization filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit.  # Plot normalization plot_normalization(se, filt, norm)"},{"path":"/reference/plot_numbers.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot protein numbers — plot_numbers","title":"Plot protein numbers — plot_numbers","text":"plot_numbers generates barplot number identified proteins per sample.","code":""},{"path":"/reference/plot_numbers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot protein numbers — plot_numbers","text":"","code":"plot_numbers(se, plot = TRUE, features_type = \"proteins\")"},{"path":"/reference/plot_numbers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot protein numbers — plot_numbers","text":"se SummarizedExperiment, Data object plot protein numbers (output make_se() make_se_parse()). plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), data barplot based returned. features_type Character(1), type features used title, like 'proteins', 'genes', 'peptides', default 'features'","code":""},{"path":"/reference/plot_numbers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot protein numbers — plot_numbers","text":"Barplot number identified proteins per sample (generated ggplot)","code":""},{"path":"/reference/plot_numbers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot protein numbers — plot_numbers","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter and plot numbers filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" plot_numbers(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found"},{"path":"/reference/plot_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot PCA — plot_pca","title":"Plot PCA — plot_pca","text":"plot_pca generates PCA plot using top variable features","code":""},{"path":"/reference/plot_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot PCA — plot_pca","text":"","code":"plot_pca(   object,   x = 1,   y = 2,   indicate = c(\"condition\", \"replicate\"),   label = FALSE,   n = 500,   point_size = 4,   label_size = 3,   plot = TRUE,   features = \"features\",   if_square = FALSE )"},{"path":"/reference/plot_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot PCA — plot_pca","text":"object SummarizedExperiment (DEGdata) object, Data object differentially enriched proteins annotated (output test_diff() (test_diff_deg()) add_rejections()). x Integer(1), Sets principle component plot x-axis. y Integer(1), Sets principle component plot y-axis. indicate Character, Sets color, shape facet_wrap plot based columns experimental design (colData). label Logical, Whether add sample labels. n Integer(1), Sets number top variable proteins consider. point_size Integer(1), Sets size points. label_size Integer(1), Sets size labels. plot Logical(1), TRUE (default) PCA plot produced. Otherwise (FALSE), data PCA plot based returned. features Character(1), feature name plot title, \"proteins\",\"genes\", default \"features\" if_square Logical(1), TRUE plot ","code":""},{"path":"/reference/plot_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot PCA — plot_pca","text":"scatter plot (generated ggplot).","code":""},{"path":"/reference/plot_pca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot PCA — plot_pca","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter, normalize and impute missing values filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" norm <- normalize_vsn(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found imputed <- impute(norm, fun = \"MinProb\", q = 0.01) #> Error: se does not inherit from class SummarizedExperiment  # Test for differentially expressed proteins diff <- test_diff(imputed, \"control\", \"Ctrl\") #> Error in eval(expr, envir, enclos): object 'imputed' not found dep <- add_rejections(diff, alpha = 0.05, lfc = 1) #> Error in (function (classes, fdef, mtable) {    methods <- .findInheritedMethods(classes, fdef, mtable)    if (length(methods) == 1L)         return(methods[[1L]])    else if (length(methods) == 0L) {        cnames <- paste0(\"\\\"\", vapply(classes, as.character,             \"\"), \"\\\"\", collapse = \", \")        stop(gettextf(\"unable to find an inherited method for function %s for signature %s\",             sQuote(fdef@generic), sQuote(cnames)), domain = NA)    }    else stop(\"Internal error in finding inherited methods; didn't return a unique method\",         domain = NA)})(list(structure(\"standardGeneric\", package = \"methods\")), new(\"nonstandardGenericFunction\",     .Data = function (diff, alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     {        standardGeneric(\"add_rejections\")    }, generic = structure(\"add_rejections\", package = \"DEP2\"),     package = \"DEP2\", group = list(), valueClass = character(0),     signature = c(\"diff\", \"alpha\", \"lfc\", \"thresholdmethod\",     \"curvature\", \"x0_fold\"), default = NULL, skeleton = (function (diff,         alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\",         \"add_rejections\"), domain = NA))(diff, alpha, lfc, thresholdmethod,         curvature, x0_fold, ...)), <environment>): unable to find an inherited method for function ‘add_rejections’ for signature ‘\"standardGeneric\"’  # Plot PCA plot_pca(dep) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'assay': object 'dep' not found plot_pca(dep, indicate = \"condition\") #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'assay': object 'dep' not found"},{"path":"/reference/plot_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot values for a protein/gene of interest — plot_single","title":"Plot values for a protein/gene of interest — plot_single","text":"plot_single generates barplot protein/gene interest.","code":""},{"path":"/reference/plot_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot values for a protein/gene of interest — plot_single","text":"","code":"plot_single(object, proteins, type = c(\"contrast\", \"centered\"), plot = TRUE)"},{"path":"/reference/plot_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot values for a protein/gene of interest — plot_single","text":"object SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() add_rejections()). proteins Character, name(s) protein(s)/gene(s) plot. type 'contrast' 'centered', type data scaling used plotting. Either fold change ('contrast') centered log2-intensity ('centered'). plot Logical(1), TRUE (default) barplot produced. Otherwise (FALSE), summaries barplot based returned.","code":""},{"path":"/reference/plot_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot values for a protein/gene of interest — plot_single","text":"barplot (generated ggplot).","code":""},{"path":"/reference/plot_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot values for a protein/gene of interest — plot_single","text":"","code":"# Load example data <- UbiLength #> Error in eval(expr, envir, enclos): object 'UbiLength' not found data <- data[data$Reverse != \"+\" & data$Potential.contaminant != \"+\",] #> Error in data$Reverse: object of type 'closure' is not subsettable data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\") #> Error: proteins is not a data frame  # Make SummarizedExperiment columns <- grep(\"LFQ.\", colnames(data_unique)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'grep': error in evaluating the argument 'x' in selecting a method for function 'colnames': object 'data_unique' not found exp_design <- UbiLength_ExpDesign #> Error in eval(expr, envir, enclos): object 'UbiLength_ExpDesign' not found se <- make_se(data_unique, columns, exp_design) #> Error in eval(expr, envir, enclos): object 'data_unique' not found  # Filter, normalize and impute missing values filt <- filter_missval(se, thr = 0) #> Error in filter_missval(se, thr = 0): could not find function \"filter_missval\" norm <- normalize_vsn(filt) #> Error in eval(expr, envir, enclos): object 'filt' not found imputed <- impute(norm, fun = \"MinProb\", q = 0.01) #> Error: se does not inherit from class SummarizedExperiment  # Test for differentially expressed proteins diff <- test_diff(imputed, \"control\", \"Ctrl\") #> Error in eval(expr, envir, enclos): object 'imputed' not found dep <- add_rejections(diff, alpha = 0.05, lfc = 1) #> Error in (function (classes, fdef, mtable) {    methods <- .findInheritedMethods(classes, fdef, mtable)    if (length(methods) == 1L)         return(methods[[1L]])    else if (length(methods) == 0L) {        cnames <- paste0(\"\\\"\", vapply(classes, as.character,             \"\"), \"\\\"\", collapse = \", \")        stop(gettextf(\"unable to find an inherited method for function %s for signature %s\",             sQuote(fdef@generic), sQuote(cnames)), domain = NA)    }    else stop(\"Internal error in finding inherited methods; didn't return a unique method\",         domain = NA)})(list(structure(\"standardGeneric\", package = \"methods\")), new(\"nonstandardGenericFunction\",     .Data = function (diff, alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     {        standardGeneric(\"add_rejections\")    }, generic = structure(\"add_rejections\", package = \"DEP2\"),     package = \"DEP2\", group = list(), valueClass = character(0),     signature = c(\"diff\", \"alpha\", \"lfc\", \"thresholdmethod\",     \"curvature\", \"x0_fold\"), default = NULL, skeleton = (function (diff,         alpha = 0.05, lfc = 1, thresholdmethod = \"intersect\",         curvature = 1, x0_fold = 2, ...)     stop(gettextf(\"invalid call in method dispatch to '%s' (no default method)\",         \"add_rejections\"), domain = NA))(diff, alpha, lfc, thresholdmethod,         curvature, x0_fold, ...)), <environment>): unable to find an inherited method for function ‘add_rejections’ for signature ‘\"standardGeneric\"’  # Plot single proteins plot_single(dep, 'USP15') #> Error in eval(expr, envir, enclos): object 'dep' not found plot_single(dep, 'USP15', 'centered') #> Error in eval(expr, envir, enclos): object 'dep' not found plot_single(dep, c('USP15', 'CUL1')) #> Error in eval(expr, envir, enclos): object 'dep' not found plot_single(dep, c('USP15', 'CUL1'), plot = FALSE) #> Error in eval(expr, envir, enclos): object 'dep' not found"},{"path":"/reference/plot_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","title":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","text":"Plot distribution statistic valuse. develop statistics_plot","code":""},{"path":"/reference/plot_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","text":"","code":"plot_statistics(   object,   statistic = c(\"diff\", \"t.stastic\", \"p.val\", \"p.adj\"),   contrasts = NULL )"},{"path":"/reference/plot_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","text":"object SummarizedExperiment DEGdata obejct test_diff / test_diff_deg add_rejections statistic Character, c(\"diff\",\"t\",\"p.val\",\"p.adj\") contrasts Characters NULL, plot contrasts. NULL, plot tested contrasts objest.","code":""},{"path":"/reference/plot_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","text":"distribution histogram statistics","code":""},{"path":"/reference/plot_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the distribution of statistic valuse. develop from statistics_plot — plot_statistics","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Storey's qvalue dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # plot statistics distribution plot_statistics(dep, statistic = \"t.stastic\")  plot_statistics(dep, statistic = \"diff\")"},{"path":"/reference/plot_umap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Tsne — plot_umap","title":"Plot Tsne — plot_umap","text":"plot_umap generates umap plot using global variable features though umap.","code":""},{"path":"/reference/plot_umap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Tsne — plot_umap","text":"","code":"plot_umap(   object,   indicate = c(\"condition\", \"replicate\"),   label = FALSE,   n = nrow(object),   point_size = 4,   label_size = 3,   plot = TRUE,   if_square = FALSE,   features = \"features\",   n_neighbors = 3,   theseed = NULL,   ... )"},{"path":"/reference/plot_umap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Tsne — plot_umap","text":"object SummarizedExperiment (DEGdata) object, Data object differentially enriched proteins annotated (output test_diff() (test_diff_deg()) add_rejections()). indicate Character, Sets color, shape facet_wrap plot based columns experimental design (colData). label Logical, Whether add sample labels. n Integer(1), Sets number top variable proteins consider. point_size Integer(1), Sets size points. label_size Integer(1), Sets size labels. plot Logical(1), TRUE (default) PCA plot produced. Otherwise (FALSE), data PCA plot based returned. if_square Logical(1), TRUE plot features Character(1), feature name plot title, \"proteins\",\"genes\", default \"features\" n_neighbors Integer(1), constraining size local neighborhood UMAP look . theseed Integer(1),Set random_state umap. #' @param ...","code":""},{"path":"/reference/plot_umap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Tsne — plot_umap","text":"scatter plot (generated ggplot).","code":""},{"path":"/reference/plot_umap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Tsne — plot_umap","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531  # UMAP plot plot_umap(norm) #> The random_state of umap is 17531 #> Error in if (abs(val - target) < tolerance) {    break}: missing value where TRUE/FALSE needed"},{"path":"/reference/plot_volcano.html","id":null,"dir":"Reference","previous_headings":"","what":"Volcano plot — plot_volcano","title":"Volcano plot — plot_volcano","text":"plot_volcano generates volcano plot specified contrast.","code":""},{"path":"/reference/plot_volcano.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Volcano plot — plot_volcano","text":"","code":"plot_volcano(   object,   contrast = get_contrast(object)[1],   add_names = TRUE,   dot_size = 2,   label_size = 3,   label_number = 10,   label_trend = c(\"all\", \"up\", \"down\", \"none\"),   up_color = \"#B2182B\",   down_color = \"#2166AC\",   stable_color = \"#BEBEBE\",   chooseTolabel = NULL,   adjusted = FALSE,   plot = TRUE,   x_symmetry = TRUE,   add_threshold_line = c(\"none\", \"intersect\", \"curve\"),   fcCutoff = 1,   pCutoff = 0.05,   curvature = 0.6,   x0_fold = 2,   breaks = NULL,   highlight_PGs_with_few_peptides = F,   peptide_1_color = \"#A020F0\",   peptide_2_color = \"#0000FF\",   peptide_column = \"Peptides\" )"},{"path":"/reference/plot_volcano.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Volcano plot — plot_volcano","text":"object SummarizedExperiment, Data object differentially enriched proteins annotated (output test_diff() test_diff_deg() add_rejections()). contrast Character(1), Specifies contrast plot. add_names Logical(1), Whether plot names. dot_size numeric(1), size points. label_size numeric(1), Sets size name labels. label_number Integer(1). number plot name. Defalut NULL, label significant names. label_trend Character(1). one c(\"\",\"\",\"\"), plot significant, -regulated ones -regulated ones. up_color color upregulated points down_color color downregulated points stable_color color stable points chooseTolabel Character, Specify names plot, matter whether significant. adjusted Logical(1), Whether use adjusted p values. plot Logical(1), TRUE (default) volcano plot produced. Otherwise (FALSE), data volcano plot based returned. x_symmetry Logical(1), X-axis symmetric based 0. add_threshold_line Character(1), one c(\"none\", \"intersect\", \"curve\"). \"intersect\" draw intersect cutoff line according fcCutoff pCutoff. \"curve\" draw curve cutoff line according curvature x0_fold. fcCutoff numeric(1), Cutoff L2FC. pCutoff numeric(1), Cutoff p p adjusted value curvature numeric(1), Curvature curve cutoff line x0_fold numeric(1), fold x0 Sigma. breaks Numeric vector, position x-axis label. eg: seq(-10,10,= 5), c(-2, -1, 0, 1, 2). highlight_PGs_with_few_peptides logic(1), mark proteins peptides peptide_1_color peptide_2_color. Require peptide number variable(specified peptide_column) object. peptide_1_color color points 1 peptide. peptide_2_color color points 2 peptide. peptide_column Character(1), varable column name storing peptide number.","code":""},{"path":"/reference/plot_volcano.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Volcano plot — plot_volcano","text":"volcano plot (generated ggplot)","code":""},{"path":"/reference/plot_volcano.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Volcano plot — plot_volcano","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit. imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531 diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Storey's qvalue dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  plot_volcano(dep,contrast = \"W4_vs_PBS\")   dep <- add_rejections(diff, thresholdmethod = \"curve\") plot_volcano(dep,contrast = \"W4_vs_PBS\",add_threshold_line= \"curve\") #> add curve threshold line. Sigma = 0.406303310375271, x0 = 0.812606620750541, curvature = 0.6"},{"path":"/reference/reshape_long2wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshape a long table to wide — reshape_long2wide","title":"Reshape a long table to wide — reshape_long2wide","text":"Transform long-format table wide-format, row feature cols expression data identification information. output table can used input DEP2","code":""},{"path":"/reference/reshape_long2wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshape a long table to wide — reshape_long2wide","text":"","code":"reshape_long2wide(   long_table,   feature_col,   expression_col,   sample_col,   remove_sample_prefix = T,   remove_sample_suffix = T,   shrink_ident_cols = NULL,   extend_ident_cols = NULL )"},{"path":"/reference/reshape_long2wide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshape a long table to wide — reshape_long2wide","text":"long_table data.frame, long-format table feature_col character(1), unique identifier feature, \"protein.group\" protein, \"peptide.sequence\" peptides, \"precursor.Id\" precursors. expression_col character(1), expression column. sample_col character(1), samples column. samples column columns names output transformed table remove_sample_prefix logical(1), whether remove prefix samples. remove_sample_suffix logical(1), whether remove suffix samples. shrink_ident_cols NULL characters,variablesvariables (identification information, like score, protein.names) stored transformed table. variable multiple feature, paste character string. Else, store unique value. extend_ident_cols NULL characters,variables (identification information, like score, protein.names) stored transformed table, like . variables extended wide table like expression_col, value different sample store different colmun table.","code":""},{"path":"/reference/reshape_long2wide.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshape a long table to wide — reshape_long2wide","text":"data.frame wide format","code":""},{"path":"/reference/reshape_long2wide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reshape a long table to wide — reshape_long2wide","text":"","code":"# Read in a example long export table long_table <- read.csv(system.file(\"extdata/DIA-NN_Export.tsv.gz\",package = \"DEP2\"),sep = \"\\t\") head(long_table) #>                                                                             File.Name #> 1  C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_5fmol_inj1.mzML #> 2  C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_5fmol_inj2.mzML #> 3  C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_5fmol_inj3.mzML #> 4 C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_25fmol_inj1.mzML #> 5 C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_25fmol_inj2.mzML #> 6 C:\\\\Users\\\\proteo\\\\Desktop\\\\RD139_Feb2021\\\\mzML\\\\RD139_Narrow_UPS1_25fmol_inj3.mzML #>   Protein.Group Protein.Ids Protein.Names Genes PG.Quantity PG.Normalised #> 1        P33898      P33898    G3P2_ECOLI  gapC     1618640       1550550 #> 2        P33898      P33898    G3P2_ECOLI  gapC     1669670       1580930 #> 3        P33898      P33898    G3P2_ECOLI  gapC     1693210       1611420 #> 4        P33898      P33898    G3P2_ECOLI  gapC     1538390       1466180 #> 5        P33898      P33898    G3P2_ECOLI  gapC     1710590       1516660 #> 6        P33898      P33898    G3P2_ECOLI  gapC     1487440       1512390 #>   Genes.Quantity Genes.Normalised Genes.MaxLFQ Genes.MaxLFQ.Unique #> 1        1618640          1550550      1541640             1541640 #> 2        1669670          1580930      1542750             1542750 #> 3        1693210          1611420      1527090             1527090 #> 4        1538390          1466180      1535660             1535660 #> 5        1710590          1516660      1506910             1506910 #> 6        1487440          1512390      1486210             1486210 #>   Modified.Sequence Stripped.Sequence     Precursor.Id Precursor.Charge #> 1   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #> 2   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #> 3   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #> 4   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #> 5   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #> 6   AAAENIIPHTTGAAK   AAAENIIPHTTGAAK AAAENIIPHTTGAAK2                2 #>       Q.Value Protein.Q.Value  PG.Q.Value  GG.Q.Value Proteotypic #> 1 8.61030e-05     0.000603500 0.000593472 0.000594884           1 #> 2 1.04118e-04     0.000610128 0.000599520 0.000600601           1 #> 3 1.32547e-04     0.000695894 0.000685401 0.000686813           1 #> 4 8.23452e-05     0.000610128 0.000598802 0.000600601           1 #> 5 8.86211e-05     0.000684932 0.000672947 0.000674764           1 #> 6 1.15447e-04     0.000687285 0.000673401 0.000675676           1 #>   Precursor.Quantity Precursor.Normalised Label.Ratio      RT RT.Start RT.Stop #> 1             585552               575050           0 26.2347  26.0551 26.4140 #> 2             714354               691530           0 26.2847  26.0457 26.5238 #> 3             553888               537228           0 26.2243  26.0449 26.4035 #> 4             582536               565425           0 27.1925  27.0128 27.3718 #> 5             605009               529203           0 27.0657  26.8864 27.3044 #> 6             483906               488140           0 26.8906  26.7110 27.0699 #>       iRT Predicted.RT Predicted.iRT Lib.Q.Value Ms1.Profile.Corr Ms1.Area #> 1 26.8898      26.2833       26.8305 8.61772e-05         0.828587   331771 #> 2 26.8898      26.3814       26.8007 8.61772e-05         0.000000        0 #> 3 26.8898      26.2363       26.8867 8.61772e-05         0.792160   941024 #> 4 26.8898      27.1476       26.9223 8.61772e-05         0.938746   599337 #> 5 26.8898      27.0569       26.8871 8.61772e-05         0.969395  1190120 #> 6 26.8898      26.8503       26.9224 8.61772e-05         0.959186   828001 #>   Evidence   CScore Decoy.Evidence MS2.Scan #> 1  4.84916 0.998191              0    26297 #> 2  3.72305 0.998172              0    26372 #> 3  4.80073 0.998183              0    26297 #> 4  4.54677 0.998704              0    27497 #> 5  4.23394 0.998795              0    27347 #> 6  4.21429 0.998653              0    27122  # Reshape to a wide expression table wide_table <- reshape_long2wide(long_table,sample_col = \"File.Name\",                                 feature_col = \"Precursor.Id\", expression_col = \"Precursor.Normalised\") head(wide_table) #>                          Precursor.Id X5fmol_inj1 X5fmol_inj2 X5fmol_inj3 #> 1                    AAAENIIPHTTGAAK2      575050      691530      537228 #> 2                    AAAENIIPHTTGAAK3      606721      648603      516066 #> 3                   AADGQMVPFSAFSSSR2     1321990     1210640     1340600 #> 4                   AADILRDDLANRGPVR3      508771      506306      488182 #> 5                   AADILRDDLANRGPVR4      198130      161177      149399 #> 6 AAEELEKEGINC(UniMod:4)NLTLLFSFAQAR3     1968710     1853150     2008230 #>   X25fmol_inj1 X25fmol_inj2 X25fmol_inj3 #> 1       565425       529203       488140 #> 2       718276       787171       662301 #> 3      1454250      1394310      1067680 #> 4       496371       146527       495867 #> 5       168853       147297       118770 #> 6      1766760      1757760      1509600  # If do not remove prefix or suffix of samples wide_table2 <- reshape_long2wide(long_table,sample_col = \"File.Name\",                                  feature_col = \"Precursor.Id\", expression_col = \"Precursor.Normalised\",                                  remove_sample_prefix = FALSE, remove_sample_suffix = FALSE) colnames(wide_table2) #> [1] \"Precursor.Id\"                                                                  #> [2] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_5fmol_inj1.mzML\"  #> [3] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_5fmol_inj2.mzML\"  #> [4] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_5fmol_inj3.mzML\"  #> [5] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_25fmol_inj1.mzML\" #> [6] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_25fmol_inj2.mzML\" #> [7] \"C..Users.proteo.Desktop.RD139_Feb2021.mzML.RD139_Narrow_UPS1_25fmol_inj3.mzML\"  # Keep some identification information wide_table2 <- reshape_long2wide(long_table,sample_col = \"File.Name\",                                  feature_col = \"Precursor.Id\", expression_col = \"Precursor.Normalised\",                                  shrink_ident_cols = c(\"Protein.Names\",\"Protein.Group\",                                                        \"Stripped.Sequence\",\"Modified.Sequence\",                                                        \"Precursor.Charge\",\"Evidence\"),                                  extend_ident_cols = \"Q.Value\" ) str(wide_table2) #> 'data.frame':\t5720 obs. of  19 variables: #>  $ Precursor.Id       : chr  \"AAAENIIPHTTGAAK2\" \"AAAENIIPHTTGAAK3\" \"AADGQMVPFSAFSSSR2\" \"AADILRDDLANR3\" ... #>  $ X5fmol_inj1        : num  575050 606721 1321990 NA 508771 ... #>  $ X5fmol_inj2        : num  691530 648603 1210640 NA 506306 ... #>  $ X5fmol_inj3        : num  537228 516066 1340600 NA 488182 ... #>  $ X25fmol_inj1       : num  565425 718276 1454250 79901 496371 ... #>  $ X25fmol_inj2       : num  529203 787171 1394310 94191 146527 ... #>  $ X25fmol_inj3       : num  488140 662301 1067680 43877 495867 ... #>  $ Protein.Names      : chr  \"G3P2_ECOLI\" \"G3P2_ECOLI\" \"ACRB_ECOLI\" \"FLIG_ECOLI\" ... #>  $ Protein.Group      : chr  \"P33898\" \"P33898\" \"P31224\" \"P0ABZ1\" ... #>  $ Stripped.Sequence  : chr  \"AAAENIIPHTTGAAK\" \"AAAENIIPHTTGAAK\" \"AADGQMVPFSAFSSSR\" \"AADILRDDLANR\" ... #>  $ Modified.Sequence  : chr  \"AAAENIIPHTTGAAK\" \"AAAENIIPHTTGAAK\" \"AADGQMVPFSAFSSSR\" \"AADILRDDLANR\" ... #>  $ Precursor.Charge   : int  2 3 2 3 3 4 3 2 3 3 ... #>  $ Evidence           : chr  \"4.84916;3.72305;4.80073;4.54677;4.23394;4.21429\" \"3.34231;4.35038;3.88619;5.35532;4.93782;4.49777\" \"3.49415;3.19957;3.47656;4.03331;4.03771;3.75486\" \"NA;NA;NA;3.09877;4.047;2.88724\" ... #>  $ Q.Value.5fmol_inj1 : num  8.61e-05 2.47e-04 1.61e-04 NA 1.25e-04 ... #>  $ Q.Value.5fmol_inj2 : num  0.000104 0.000104 0.000104 NA 0.000104 ... #>  $ Q.Value.5fmol_inj3 : num  0.000133 0.000192 0.000168 NA 0.000133 ... #>  $ Q.Value.25fmol_inj1: num  8.23e-05 8.23e-05 9.49e-05 7.03e-04 9.49e-05 ... #>  $ Q.Value.25fmol_inj2: num  8.86e-05 8.86e-05 8.86e-05 8.86e-05 4.90e-04 ... #>  $ Q.Value.25fmol_inj3: num  0.000115 0.000115 0.000184 0.000384 0.000115 ..."},{"path":"/reference/rlg_deg.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign a rlog transformed assay for DEGdata object — rlg_deg","title":"Assign a rlog transformed assay for DEGdata object — rlg_deg","text":"rlg_deg calulate rolg transformed assay based rlog()","code":""},{"path":"/reference/rlg_deg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign a rlog transformed assay for DEGdata object — rlg_deg","text":"","code":"rlg_deg(DEGdata, blind = FALSE, ...)"},{"path":"/reference/rlg_deg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign a rlog transformed assay for DEGdata object — rlg_deg","text":"DEGdata DEGdata object get_res blind logical, whether blind transformation experimental design. blind=TRUE used comparing samples manner unbiased prior information samples, example perform sample QA (quality assurance). blind=FALSE used transforming data downstream analysis, full use design information made. blind=FALSE skip re-estimation dispersion trend, already calculated. many genes large differences counts due experimental design, important set blind=FALSE downstream analysis. ... options rlog().","code":""},{"path":"/reference/rlg_deg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign a rlog transformed assay for DEGdata object — rlg_deg","text":"DEGdata rlog transform assay rlg slot","code":""},{"path":"/reference/run_app.html","id":null,"dir":"Reference","previous_headings":"","what":"Run shiny application in DEP2 — run_app","title":"Run shiny application in DEP2 — run_app","text":"Run shiny application DEP2","code":""},{"path":"/reference/run_app.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run shiny application in DEP2 — run_app","text":"","code":"run_app()"},{"path":"/reference/run_app.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run shiny application in DEP2 — run_app","text":"","code":"if (FALSE) { DEP2::run_app() }"},{"path":"/reference/test_GSEA.html","id":null,"dir":"Reference","previous_headings":"","what":"GSEA data — test_GSEA","title":"GSEA data — test_GSEA","text":"Enrich biological functions significant candidate via representation analysis.","code":""},{"path":"/reference/test_GSEA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GSEA data — test_GSEA","text":"","code":"test_GSEA(   x,   type = c(\"GO\", \"KEGG\", \"REACTOME\", \"MSigDB\"),   species = \"Human\",   contrasts = NULL,   by_contrast = FALSE,   topn = NULL,   pAdjustMethod = \"BH\",   category = NULL,   subcategory = NULL,   ... )"},{"path":"/reference/test_GSEA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GSEA data — test_GSEA","text":"x SummarizedExperiment/DEGdata output add_adjections charachter vector containing candidate identifier(SYMBOL, EntrezID, UniprotID ENSEMBL). type Character, one \"GO\",\"KEGG\",\"REACTOME\" \"MSigDB\". database enrichment analysis. species species name. contrasts Character, analyse results contrasts. by_contrast Logical(1). true, draw enrichment contrast, else draw total significant candidates. topn Integer(1), use topn list significant foldchange pAdjustMethod Character, one \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"\", \"fdr\", \"none\". category, subcategory Character. Work type \"MSigDB\". Use subset MSigDB. can run msigdbr::msigdbr_collections() get options. ... parameters GSEA() except cutoff setting","code":""},{"path":"/reference/test_GSEA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GSEA data — test_GSEA","text":"gseaResult object ","code":""},{"path":"/reference/test_GSEA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GSEA data — test_GSEA","text":"","code":"if (FALSE) { # Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") norm <- normalize_vsn(filt) imputed <- impute(norm, fun = \"MinProb\", q = 0.05) diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") # GSEA check_organismDB_depends(organism = \"Mouse\") # check annotation package of Mouse res_gsea <- test_GSEA(diff, contrasts = \"W4_vs_PBS\", species = \"Mouse\",type = \"GO\") }"},{"path":"/reference/test_ORA.html","id":null,"dir":"Reference","previous_headings":"","what":"ORA for differenatial test result — test_ORA","title":"ORA for differenatial test result — test_ORA","text":"Enrich biological functions significant candidate via representation analysis.","code":""},{"path":"/reference/test_ORA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORA for differenatial test result — test_ORA","text":"","code":"test_ORA(   x,   contrasts = NULL,   type = c(\"GO\", \"KEGG\", \"REACTOME\"),   species = \"Human\",   by_contrast = FALSE,   pAdjustMethod = c(\"BH\", \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BY\", \"fdr\",     \"none\"),   ... )"},{"path":"/reference/test_ORA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORA for differenatial test result — test_ORA","text":"x SummarizedExperiment/DEGdata output add_adjections charachter vector containing candidate identifier(SYMBOL, EntrezID, UniprotID ENSEMBL). contrasts Character, analyse results contrasts. type Character, one \"GO\",\"KEGG\",\"REACTOME\". datasets enrichment analysis. species species name. by_contrast Logical(1). true, draw enrichment contrast, else draw total significant candidates. pAdjustMethod Character, one \"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"\", \"fdr\", \"none\". ... parameters enricher() except cutoff setting","code":""},{"path":"/reference/test_ORA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORA for differenatial test result — test_ORA","text":"enrichResult compareClusterResult object according by_contrast.","code":""},{"path":"/reference/test_ORA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORA for differenatial test result — test_ORA","text":"","code":"if (FALSE) { # Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\")  # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") norm <- normalize_vsn(filt)  # Impute missing values using different functions imputed <- impute(norm, fun = \"MinProb\", q = 0.05)  # Test for differentially expressed proteins diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # GO enrichment check_organismDB_depends(organism = \"Mouse\") # check annotation package of Mouse res_ora <- test_ORA(dep, contrasts = \"W4_vs_PBS\", species = \"Mouse\",type = \"GO\") enrichplot::dotplot(res_ora) }"},{"path":"/reference/test_PPI.html","id":null,"dir":"Reference","previous_headings":"","what":"Protein-protein interaction analysis — test_PPI","title":"Protein-protein interaction analysis — test_PPI","text":"test_PPI search protein-protein interaction significant candidate based local STRING database.","code":""},{"path":"/reference/test_PPI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Protein-protein interaction analysis — test_PPI","text":"","code":"test_PPI(   x,   contrasts = NULL,   species = \"Human\",   STRING.version = \"11.5\",   choose_scores = NULL,   score_cutoff = 400 )"},{"path":"/reference/test_PPI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Protein-protein interaction analysis — test_PPI","text":"x SummarizedExperiment/DEGdata output add_rejections charachter vector containing candidate identifiers(SYMBOL, EntrezID, UniprotID ENSEMBL). contrasts Character, specifies contrasts get significant candidates. species species name. STRING.version Character(1),version STRING data. choose_scores NULL \"combined_score\" subset c(\"neighborhood\",\"fusion\",\"cooccurence\",\"coexpression\", \"experimental\",\"database\",\"textmining\"). NULL \"combined_score\", cutoff scores combining evidence, otherwise subset. score_cutoff numeric lager 400, required lowest interaction scores. score lowwer 400 means interaction unconfident","code":""},{"path":"/reference/test_PPI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Protein-protein interaction analysis — test_PPI","text":"data.frame PPI information","code":""},{"path":"/reference/test_PPI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Protein-protein interaction analysis — test_PPI","text":"Identifiers x firstly transformed entrezID mapped relative STRING id. Next protein-protein interaction exctracted STRING.link.detail. local STRING data (including protein.info, protein.aliases protein.links.detailed) necessary function. absent, test_PPI download STRING automatically according species STRING.version.","code":""},{"path":"/reference/test_PPI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Protein-protein interaction analysis — test_PPI","text":"","code":"if (FALSE) { # Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Differential test ecols <- grep(\"LFQ.\", colnames(data_unique)) se <- make_se_parse(data_unique, ecols,mode = \"delim\") filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") norm <- normalize_vsn(filt) imputed <- impute(norm, fun = \"MinProb\", q = 0.05) diff <- test_diff(imputed, type = \"control\", control  = c(\"PBS\"), fdr.type = \"Storey's qvalue\") dep <- add_rejections(diff, alpha = 0.01,lfc = 2)  # PPI construct if(check_PPI_depends()){    # Load STRING data. If local STRING is missing, PPI_res will download to system.file(\"PPIdata\", \"Mouse\",package = \"DEP2\")   load_PPIdata(speciesname = \"Mouse\")    PPI_res <- test_PPI(dep, contrasts = \"W4_vs_PBS\", species = \"Mouse\",                       STRING.version = \"11.5\",score_cutoff = 400)   head(PPI_res) } }"},{"path":"/reference/test_diff.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential enrichment/expression test — test_diff","title":"Differential enrichment/expression test — test_diff","text":"test_diff performs differential enrichment/expression test based protein/peptide-wise linear models empirical Bayes statistics using limma. False Discovery Rates estimated using \"Strimmer's qvalue\", \"Benjamini-Hochberg fdr\" \"Storey's qvalue\".","code":""},{"path":"/reference/test_diff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential enrichment/expression test — test_diff","text":"","code":"test_diff(   se,   type = c(\"all\", \"control\", \"manual\"),   control = NULL,   test = NULL,   design_formula = formula(~0 + condition),   fdr.type = c(\"Strimmer's qvalue(t)\", \"Strimmer's qvalue(p)\", \"BH\", \"Storey's qvalue\") )"},{"path":"/reference/test_diff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential enrichment/expression test — test_diff","text":"se SummarizedExperiment, Proteomics data quantity table (output make_se(), make_se_parse()), re-aggregate peptide quantity aggregateFeatures() ). proteomics data directly quantity table, adviced first remove low quanlity undesired rows filter_se(), missing values imputed impute(). Normalization recommended workflow. type \"control\", \"\" \"manual\", type contrasts tested. can possible pairwise comparisons (\"\"), limited comparisons versus control (\"control\"), manually defined contrasts (\"manual\"). control Character(1), condition contrasts generated type = \"control\" (control condition appropriate). test Character, contrasts tested type = \"manual\". formatted \"conditionA_vs_conditionB\" c(\"conditionA_vs_conditionC\", \"conditionB_vs_conditionC\"). design_formula Formula, Used create design matrix. fdr.type Character(1), method control false discovery rate, one \"Strimmer's qvalue(t)\",\"Strimmer's qvalue(p)\",\"BH\",\"Storey's qvalue\". \"Strimmer's qvalue\" calculate fdr vis fdrtool() using t-statistic p values limma. \"BH\" calculate fdr vis p.adjust() using \"BH\" method . \"Storey's qvalue\"  calculate fdr vis stats::qvalue().","code":""},{"path":"/reference/test_diff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential enrichment/expression test — test_diff","text":"SummarizedExperiment object DEGdata containing diff, test result limma fdr estimates differential expression.","code":""},{"path":"/reference/test_diff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential enrichment/expression test — test_diff","text":"","code":"# Load example data(Silicosis_pg) data <- Silicosis_pg data_unique <- make_unique(data, \"Gene.names\", \"Protein.IDs\", delim = \";\")  # Make SummarizedExperiment ecols <- grep(\"LFQ.\", colnames(data_unique))   ## Load experiement design data(Silicosis_ExpDesign) exp_design <- Silicosis_ExpDesign se <- make_se(data_unique, ecols, exp_design)  # Filter and normalize filt <- filter_se(se, thr = 0, fraction = 0.4, filter_formula = ~ Reverse != \"+\" & Potential.contaminant!=\"+\") #> filter base on missing number is <= 0 in at least one condition. #> filter base on missing number fraction < 0.4 in each row #> filter base on giving formula  norm <- normalize_vsn(filt) #> vsn2: 8762 x 20 matrix (1 stratum).  #> Please use 'meanSdPlot' to verify the fit.  # Impute missing values using different functions imputed <- impute(norm, fun = \"MinProb\", q = 0.05) #> Imputing along margin 2 (samples/columns). #> [1] 0.3026531  # Test for differentially expressed proteins diff <- test_diff(imputed, \"control\", \"PBS\") #> Tested contrasts: W10_vs_PBS, W2_vs_PBS, W4_vs_PBS, W6_vs_PBS, W9_vs_PBS #> Strimmer's qvalue(t) diff <- test_diff(imputed, \"manual\", test = \"PBS_vs_W6\") #> Tested contrasts: PBS_vs_W6 #> Strimmer's qvalue(t) diff <- test_diff(imputed, \"manual\", test = \"PBS_vs_W6\", fdr.type = \"Storey's qvalue\") #> Tested contrasts: PBS_vs_W6 #> Storey's qvalue"},{"path":"/reference/test_diff_deg.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential expression test on a DESeqDataSet — test_diff_deg","title":"Differential expression test on a DESeqDataSet — test_diff_deg","text":"test_diff_deg performs differential expression test based DESeq2 package format test results DESeq() results().","code":""},{"path":"/reference/test_diff_deg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential expression test on a DESeqDataSet — test_diff_deg","text":"","code":"test_diff_deg(   dds,   type = c(\"all\", \"control\", \"manual\"),   control = NULL,   test_contrasts = NULL,   contrast_upon = \"condition\",   filter_ihw = FALSE,   independentFiltering = TRUE,   lfcshark = FALSE,   ... )"},{"path":"/reference/test_diff_deg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential expression test on a DESeqDataSet — test_diff_deg","text":"dds DESeqDataSet object. type \"control\", \"\" \"manual\", type contrasts tested. can possible pairwise comparisons (\"\"), limited comparisons versus control (\"control\"), manually defined contrasts (\"manual\"). control Character(1), condition contrasts generated type = \"control\" (control condition appropriate). test_contrasts Character, contrasts tested type = \"manual\". formatted \"SampleA_vs_SampleB\" c(\"SampleA_vs_SampleC\", \"SampleB_vs_SampleC\"). contrast_upon Character, contrast bulid upon column experimentdesign. filter_ihw logical(1),Whether use ihw perform independent filtering p-value adjustment, default FALSE. See results independentFiltering logical(1), whether independent filtering applied automatically, default TRUE. See results lfcshark logical(1),whether use lfcshark, default FALSE. See results ... Parameters transmitted DESeq2","code":""},{"path":"/reference/theme_DEP1.html","id":null,"dir":"Reference","previous_headings":"","what":"DEP ggplot theme 1 — theme_DEP1","title":"DEP ggplot theme 1 — theme_DEP1","text":"theme_DEP1 default ggplot theme inherited  used plotting DEP package horizontal x-axis labels.","code":""},{"path":"/reference/theme_DEP1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DEP ggplot theme 1 — theme_DEP1","text":"","code":"theme_DEP1()"},{"path":"/reference/theme_DEP1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DEP ggplot theme 1 — theme_DEP1","text":"ggplot theme","code":""},{"path":"/reference/theme_DEP2.html","id":null,"dir":"Reference","previous_headings":"","what":"DEP ggplot theme 2 — theme_DEP2","title":"DEP ggplot theme 2 — theme_DEP2","text":"theme_DEP2 ggplot theme DEP package used plotting DEP package vertical x-axis labels.","code":""},{"path":"/reference/theme_DEP2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DEP ggplot theme 2 — theme_DEP2","text":"","code":"theme_DEP2()"},{"path":"/reference/theme_DEP2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DEP ggplot theme 2 — theme_DEP2","text":"ggplot theme","code":""}]
